<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet href="file:///C|/Users/unkov/.samp/pawn/xml/pawndoc.xsl" type="text/xsl"?>
<doc source="C:\Users\unkov\Documents\samp-warboot\gamemodes\main.pwn">
	<assembly>
		<name>main.pwn</name>
	</assembly>

	<!-- general -->
	<general>
		<summary>Prints a string to the server console (not in-game chat) and logs (server_log.txt).</summary> <param name="string">The string to print</param> <seealso name="printf"/><p/> <summary>Outputs a formatted string on the console (the server window, not the in-game chat).</summary> <param name="format">The format string</param> <param name="">Indefinite number of arguments of any tag</param> <seealso name="print"/> <seealso name="format"/> <remarks>The format string or its output should not exceed 1024 characters. Anything beyond that length can lead to a server to crash.</remarks> <remarks>This function doesn't support <a href="#strpack">packed</a> strings.</remarks> <remarks> <b>Format Specifiers:</b><p/> <ul> <li><b><c>%i</c></b> - integer (whole number)</li> <li><b><c>%d</c></b> - integer (whole number).</li> <li><b><c>%s</c></b> - string</li> <li><b><c>%f</c></b> - floating-point number (Float: tag)</li> <li><b><c>%c</c></b> - ASCII character</li> <li><b><c>%x</c></b> - hexadecimal number</li> <li><b><c>%b</c></b> - binary number</li> <li><b><c>%%</c></b> - literal <b><c>%</c></b></li> <li><b><c>%q</c></b> - escape a text for SQLite. (Added in <b>0.3.7 R2</b>)</li> </ul> </remarks> <remarks>The values for the placeholders follow in the exact same order as parameters in the call. For example, <b><c>"I am %i years old"</c></b> - the <b><c>%i</c></b> will be replaced with an Integer variable, which is the person's age.</remarks> <remarks>You may optionally put a number between the <b><c>%</c></b> and the letter of the placeholder code. This number indicates the field width; if the size of the parameter to print at the position of the placeholder is smaller than the field width, the field is expanded with spaces. To cut the number of decimal places beeing shown of a float, you can add <b><c>.&lt;max number&gt;</c></b> between the <b><c>%</c></b> and the <b><c>f</c></b>. (example: <b><c>%.2f</c></b>)</remarks><p/> MySQL plugin R41-4 <p/> <library name="y_utils">  <section>  Description  </section>  Misc functions used throughout.  <section>  Version  </section>  0.1.3  <section>  Functions  </section>  <subsection>Stock</subsection>  <ul>  <symbol name="StrToLower">Convert a whole string to lower-case.</symbol>  <symbol name="StrToUpper">Convert a whole string to upper-case.</symbol>  <symbol name="Random">Generate a random number, optionally takes lower and upper bounds.</symbol>  <symbol name="RandomFloat">Same as <symbolref name="Random" />, but for floats.</symbol>  <symbol name="StripNL">Strips the newline characters from the end of a string.</symbol>  <symbol name="StripL">Remove whitespace from the start of a string.</symbol>  <symbol name="Strip">Remove whitespace from both ends of a string.</symbol>  <symbol name="endofline">Check if the given position is the end of a string (ignoring whitespace).</symbol>  <symbol name="chrfind">Return the first position (after <symbolref name="start" />) of the given character.</symbol>  <symbol name="chrfindp">Like <symbolref name="chrfind" />, but without the upper-bounds check.</symbol>  <symbol name="bernstein">Generate the Bernstein hash of the given string.</symbol>  <symbol name="ishex">Is the given string hexadecimal?</symbol>  <symbol name="unpack">Version of <symbolref name="strunpack" /> that returns the result.</symbol>  <symbol name="returnstringarg">Get the string passed as a variable argument from the given index.</symbol>  <symbol name="va_return">Like <symbolref name="sprintf" />, formats a string and returns the result.</symbol>  <symbol name="isnumeric">Is the given string a number?</symbol>  <symbol name="hexstr">Return the value of the given hexadecimal string.</symbol>  <symbol name="boolstr">Return the value of the given boolean string.</symbol>  <symbol name="binstr">Return the value of the given binary string.</symbol>  <symbol name="rawMemcpy">Copy memory between two address, instead of two arrays.</symbol>  <symbol name="memset">Set all of an array to a value.</symbol>  <symbol name="rawMemset">Set all of a given memory region to a value.</symbol>  <symbol name="ReturnPlayerName">Return a player's name.</symbol>  <symbol name="ftouch">Ensures that a file exists, but nothing more.</symbol>  <symbol name="InterpolateColour">Get the colour (in 3D RGB space) between two other colours.</symbol>  <symbol name="SkipWhitespace">Return the first position in a string of a non-whitespace character.</symbol>  <symbol name="Trim">Get the first and last positions of non-whitespace characters in the string.  Like  <symbolref name="Strip" />, but doesn't modify the string.</symbol>  <symbol name="Sum">Get the total (sum) of an array.</symbol>  <symbol name="Mean">Get the mathematical mean of an array.</symbol>  <symbol name="Mode">Get the mathematical mode of an array.</symbol>  <symbol name="Median">Get the mathematical median of an array.</symbol>  <symbol name="Range">Get the mathematical range of an array.</symbol>  </ul>  <subsection>Inline</subsection>  <ul>  <symbol name="UCMP">Unsigned compare.</symbol>  <symbol name="VALID_PLAYERID">Check if a player ID is valid (in range).</symbol>  <symbol name="IS_IN_RANGE">Check if a number is in range.</symbol>  <symbol name="NOT_IN_RANGE">Check if a number is outside a range.</symbol>  <symbol name="ceildiv">Divide two numbers and round up.</symbol>  <symbol name="floordiv">Divide two numbers and round down.</symbol>  <symbol name="isnull">Checks if a string is NULL (<c>\1\0</c> or <c>\0</c>).</symbol>  <symbol name="isodd">Checks if a number is odd.</symbol>  <symbol name="iseven">Checks if a number is even.</symbol>  <symbol name="strcpy">Copy one string to another.</symbol>  <symbol name="GetIP">Return the encoded (32-bit) version of a player's IP.</symbol>  <synonym name="getstring" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="GetString" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="getstringarg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="GetStringArg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="ReturnStringArg" for="returnstringarg"> (there are a lot)</synonym>  <synonym name="InterpolateColor" for="InterpolateColour" />  <synonym name="StripR" for="StripNL" />  </ul>  <section>  Variables  </section>  <subsection>Global</subsection>  <ul>  <symbol name="TRUE">True hack for infinate loops.</symbol>  <symbol name="FALSE">False hack for one-time loops.</symbol>  <symbol name="NULL">1 long string for passing via Call(Remote|Local)Function.</symbol>  </ul>  </library> <p/> <transition keep="true" target="_script_init_fix_state : true"/>  <transition keep="true" target="_ALS : _ALS_go"/> <p/> <library name="y_stringhash">  <section>  Description  </section>  Allows you to hash strings at compile time to use them in a switch.  <section>  Version  </section>  2.0  <section>  Functions  </section>  <subsection>  Stock  </subsection><ul>  <symbol name="YHash">Generate a string hash at run time.</symbol>  </ul><section>  Definitions  </section><ul>  <symbol name="_H">Generate a string hash at compile time.</symbol>  <symbol name="_I">Generate a case insensitive string hash at compile time.</symbol>  </ul>  </library> <p/> <library name="y_remote">  <section>  Description  </section>  Wrapper for "__CallRemoteFunction".  Enforces some features like no returns  and arrays being followed by their length.  <section>  Version  </section>  1.0  <section>  Macros  </section><ul>  <symbol name="remotefunc">Define a function to be called remotely (use like "stock").</symbol>  <symbol name="broadcastfunc">Call the function, but in all scripts.</symbol>  <symbol name="localfunc">Call the function by name, not address, in the current script.</symbol>  </ul><section>Compile options</section><ul>  <symbol name="YSI_NO_MASTER">Disable all knowledge of other scripts.</symbol>  </ul>  </library> <p/> <library name="y_hooks">  <section>  Description  </section>  Automatically hooks any callbacks with a very simple syntax.  <section>  Version  </section>  2.0  </library> <p/> <library name="y_hooks">  <section>  Description  </section>  Automatically hooks any callbacks with a very simple syntax.  <section>  Version  </section>  2.0  </library> <p/> <library name="y_hooks">  <section>  Description  </section>  Automatically hooks any callbacks with a very simple syntax.  <section>  Version  </section>  2.0  </library> <p/> <library name="y_hooks">  <section>  Description  </section>  Automatically hooks any callbacks with a very simple syntax.  <section>  Version  </section>  2.0  </library> 
	</general>

	<members>

		<!-- enumerations -->
		<member name="T:AMX_FUNCSTUBNT" value="2">
			<tagname value="AMX_FUNCSTUBNT"/>
			<member name="C:AMX_FUNCSTUBNT_ADDRESS" value="0">
			</member>
			<member name="C:AMX_FUNCSTUBNT_NAMEOFS" value="1">
			</member>
			<referrer name="GetPublicAddressFromIndex"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeAddressFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarAddressFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagIDFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="IsTagIndexStrong"/>
			<referrer name="IsTagIndexWeak"/>
		</member>
		<member name="T:AMX_HDR" value="17">
			<tagname value="AMX_HDR"/>
			<member name="C:AMX_HDR_SIZE" value="0">
			</member>
			<member name="C:AMX_HDR_MAGIC" value="1">
			</member>
			<member name="C:AMX_HDR_FILE_VERSION" value="2">
			</member>
			<member name="C:AMX_HDR_AMX_VERSION" value="3">
			</member>
			<member name="C:AMX_HDR_FLAGS" value="4">
			</member>
			<member name="C:AMX_HDR_DEFSIZE" value="5">
			</member>
			<member name="C:AMX_HDR_COD" value="6">
			</member>
			<member name="C:AMX_HDR_DAT" value="7">
			</member>
			<member name="C:AMX_HDR_HEA" value="8">
			</member>
			<member name="C:AMX_HDR_STP" value="9">
			</member>
			<member name="C:AMX_HDR_CIP" value="10">
			</member>
			<member name="C:AMX_HDR_PUBLICS" value="11">
			</member>
			<member name="C:AMX_HDR_NATIVES" value="12">
			</member>
			<member name="C:AMX_HDR_LIBRARIES" value="13">
			</member>
			<member name="C:AMX_HDR_PUBVARS" value="14">
			</member>
			<member name="C:AMX_HDR_TAGS" value="15">
			</member>
			<member name="C:AMX_HDR_NAMETABLE" value="16">
			</member>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmInit"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="AsmGetJumpAddressFromOffset"/>
			<referrer name="AsmGetCode"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="AddressofResolveFoundStart"/>
			<referrer name="Indirect_Init"/>
			<referrer name="DumpAMX_WriteAMXData"/>
			<referrer name="DumpAMX_WriteAMXCode"/>
			<referrer name="DumpAMX_Write"/>
			<referrer name="Hooks_OnCodeInit"/>
		</member>
		<member name="T:AsmContext" value="21">
			<tagname value="AsmContext"/>
			<member name="C:AsmContext_buffer" value="0">
			</member>
			<member name="C:AsmContext_buffer_size" value="1">
			</member>
			<member name="C:AsmContext_buffer_offset" value="2">
			</member>
			<member name="C:AsmContext_error" value="3">
			</member>
			<member name="C:AsmContext_error_handler" value="4">
			</member>
			<member name="C:AsmContext_label_names" value="5">
				<size value="8"/>
			</member>
			<member name="C:AsmContext_labels" value="13">
				<size value="8"/>
			</member>
			<referrer name="AddressofResolveFoundStart"/>
			<referrer name="AddressofResolveFoundEnd"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
		</member>
		<member name="T:CodeScanMatcher" value="171">
			<tagname value="CodeScanMatcher"/>
			<member name="C:CodeScanMatcher_func" value="0">
			</member>
			<member name="C:CodeScanMatcher_user_data" value="1">
			</member>
			<member name="C:CodeScanMatcher_code" value="2">
				<size value="128"/>
			</member>
			<member name="C:CodeScanMatcher_len" value="130">
			</member>
			<member name="C:CodeScanMatcher_offset" value="131">
				<size value="2"/>
			</member>
			<member name="C:CodeScanMatcher_start" value="133">
				<size value="2"/>
			</member>
			<member name="C:CodeScanMatcher_holeidx" value="135">
				<size value="2"/>
			</member>
			<member name="C:CodeScanMatcher_holes" value="137">
				<size value="32"/>
			</member>
			<member name="C:CodeScanMatcher_next" value="169">
			</member>
			<member name="C:CodeScanMatcher_flags" value="170">
			</member>
			<referrer name="CodeScanDeref"/>
			<referrer name="AddressofResolve"/>
		</member>
		<member name="T:CodeScanner" value="164">
			<tagname value="CodeScanner"/>
			<member name="C:CodeScanMatch_func" value="0">
			</member>
			<member name="C:CodeScanMatch_size" value="1">
			</member>
			<member name="C:CodeScanMatch_type" value="2">
			</member>
			<member name="C:CodeScanMatch_heap" value="3">
			</member>
			<member name="C:CodeScanMatch_stack" value="4">
			</member>
			<member name="C:CodeScanMatch_params" value="5">
			</member>
			<member name="C:CodeScanMatch_cip" value="6">
			</member>
			<member name="C:CodeScanMatch_holes" value="7">
				<size value="16"/>
			</member>
			<member name="C:CodeScanMatch_hole_count" value="23">
			</member>
			<member name="C:CodeScanMatch_name" value="24">
				<size value="8"/>
			</member>
			<member name="C:CodeScanner_first" value="32">
			</member>
			<member name="C:CodeScanner_minn" value="33">
			</member>
			<member name="C:CodeScanner_jump_switch" value="34">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_jump_target" value="66">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_jump_stack" value="98">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_jump_heap" value="130">
				<size value="32"/>
			</member>
			<member name="C:CodeScanner_state" value="162">
			</member>
			<member name="C:CodeScanner_param" value="163">
			</member>
			<referrer name="AddressofResolve"/>
		</member>
		<member name="T:DisasmContext" value="5">
			<tagname value="DisasmContext"/>
			<member name="C:DisasmContext_start_ip" value="0">
			</member>
			<member name="C:DisasmContext_end_ip" value="1">
			</member>
			<member name="C:DisasmContext_nip" value="2">
			</member>
			<member name="C:DisasmContext_cip" value="3">
			</member>
			<member name="C:DisasmContext_opcode" value="4">
				<tagname value="Opcode"/>
			</member>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="DumpAMX_WriteAMXCode"/>
			<referrer name="ThirdParty_OnCodeInit"/>
			<referrer name="Hooks_GetStubEntry"/>
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
		</member>
		<member name="T:E_CHAIN_HOOK" value="17">
			<tagname value="E_CHAIN_HOOK"/>
			<member name="C:E_CHAIN_HOOK_NAME" value="0">
				<size value="16"/>
			</member>
			<member name="C:E_CHAIN_HOOK_VALUE" value="16">
			</member>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_DoAllHooks"/>
		</member>
		<member name="T:E_HOOK_NAME_REPLACEMENT_DATA" value="34">
			<tagname value="E_HOOK_NAME_REPLACEMENT_DATA"/>
			<member name="C:E_HOOK_NAME_REPLACEMENT_SHORT" value="0">
				<size value="16"/>
			</member>
			<member name="C:E_HOOK_NAME_REPLACEMENT_LONG" value="16">
				<size value="16"/>
			</member>
			<member name="C:E_HOOK_NAME_REPLACEMENT_MIN" value="32">
			</member>
			<member name="C:E_HOOK_NAME_REPLACEMENT_MAX" value="33">
			</member>
		</member>
		<member name="T:OpcodeInsnInfo" value="17">
			<tagname value="OpcodeInsnInfo"/>
			<member name="C:OpcodeInsnInfo_name" value="0">
				<size value="15"/>
			</member>
			<member name="C:OpcodeInsnInfo_num_opers" value="15">
			</member>
			<member name="C:OpcodeInsnInfo_needs_reloc" value="16">
				<tagname value="bool"/>
			</member>
		</member>
		<member name="T:__E_COMPILER_ENUM" value="4">
			<tagname value="__E_COMPILER_ENUM"/>
			<member name="C:__E_COMPILER_ENUM_ENTRY" value="0">
				<size value="3"/>
			</member>
			<member name="C:__E_COMPILER_ENUM_AFTER" value="3">
			</member>
		</member>
		<member name="T:e_DIALOG_RESPONSE_INFO" value="131">
			<tagname value="e_DIALOG_RESPONSE_INFO"/>
			<member name="C:E_DIALOG_RESPONSE_Response" value="0">
			</member>
			<member name="C:E_DIALOG_RESPONSE_Listitem" value="1">
			</member>
			<member name="C:E_DIALOG_RESPONSE_InputText" value="2">
				<size value="129"/>
			</member>
			<referrer name="AsyncDialogsHandler"/>
			<referrer name="Account_RegisterHandler"/>
			<referrer name="Account_EmailDialogHandler"/>
			<referrer name="Account_LoginDialog"/>
		</member>

		<!-- constants -->
		<member name="C:AMX_HDR_OFFSET_AMX_VERSION" value="7">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_CIP" value="28">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_COD" value="12">
			<referrer name="GetAmxHeaderNow"/>
			<referrer name="DumpAMX_WriteAMXHeader"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_DAT" value="16">
			<referrer name="GetAmxHeaderNow"/>
			<referrer name="DumpAMX_WriteAMXHeader"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_DEFSIZE" value="10">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_FILE_VERSION" value="6">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_FLAGS" value="8">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_HEA" value="20">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_LIBRARIES" value="40">
			<referrer name="GetAmxHeaderNow"/>
			<referrer name="DumpAMX_WriteAMXHeader"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_MAGIC" value="4">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_NAMETABLE" value="52">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_NATIVES" value="36">
			<referrer name="GetAmxHeaderNow"/>
			<referrer name="DumpAMX_WriteAMXHeader"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_PUBLICS" value="32">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_PUBVARS" value="44">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_SIZE" value="0">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_STP" value="24">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:AMX_HDR_OFFSET_TAGS" value="48">
			<referrer name="GetAmxHeaderNow"/>
		</member>
		<member name="C:EOS" value="0">
			<referrer name="strcopy"/>
			<referrer name="Account_ResetInfo"/>
		</member>
		<member name="C:INVALID_MAP" value="0">
			<tagname value="Map"/>
		</member>
		<member name="C:KICK_KICKEROFFLINE" value="2">
			<referrer name="AdvancedKick"/>
		</member>
		<member name="C:KICK_SUCCESS" value="1">
			<referrer name="KickEx"/>
			<referrer name="AdvancedKick"/>
		</member>
		<member name="C:KICK_TARGETOFFLINE" value="3">
			<referrer name="AdvancedKick"/>
		</member>
		<member name="C:NUM_OPCODES" value="138">
			<referrer name="IsOpcodeValid"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="UnrelocateOpcode"/>
			<referrer name="GetOpcodeInstructionInformation"/>
			<referrer name="GetOpcodeInstructionName"/>
			<referrer name="GetOpcodeInstructionParameters"/>
			<referrer name="GetOpcodeInstructionRelocatable"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmNext"/>
			<referrer name="AsmEmitOpcode"/>
		</member>
		<member name="C:PAWN_PLUS_DIALOG_ID" value="20523">
			<referrer name="AwaitAsyncDialog"/>
			<referrer name="AwaitAsyncDialogStr"/>
			<referrer name="ShowPlayerAsyncDialog"/>
			<referrer name="ShowPlayerAsyncDialogStr"/>
			<referrer name="AsyncDialogsHandler"/>
			PawnPlus v1.3.1 by IllidanS4 *
		</member>
		<member name="C:__COMPILER_DEFAULT" value="0">
			<tagname value="__CompilerDefault"/>
			<referrer name="AMX_GetEntryPointer"/>
			<referrer name="Cell_ReverseBits"/>
			<referrer name="Cell_ReverseNibbles"/>
			<referrer name="Cell_CountBits"/>
			<referrer name="Cell_GetLowestBit"/>
			<referrer name="Cell_GetLowestBitEx"/>
			<referrer name="Cell_CountBlanks"/>
			<referrer name="Cell_GetLowestBlank"/>
			<referrer name="Cell_GetLowestBlankEx"/>
			<referrer name="Cell_GetLowestComponent"/>
			<referrer name="Cell_GetLowestEmpty"/>
			<referrer name="Base64Encode"/>
			<referrer name="PrintArg"/>
			<referrer name="Hooks_NumArgs"/>
		</member>
		<member name="C:__Pawn" value="778">
		</member>
		<member name="C:__PawnBuild" value="10">
		</member>
		<member name="C:cellbits" value="32">
			<referrer name="Base64Encode"/>
			<referrer name="Base64Decode"/>
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanNOPMatch"/>
			<referrer name="AddressofResolveFoundEnd"/>
			<referrer name="_yH@"/>
		</member>
		<member name="C:cellmax" value="2147483647">
			<referrer name="operator!(Float:)"/>
			<referrer name="Range"/>
			<referrer name="CodeScanGetFunctionAsm"/>
			<referrer name="CodeScanGetMatchAsm"/>
			<referrer name="Colours_SAMPToGT"/>
			<referrer name="YHNPS_Insert"/>
			<referrer name="YHNPS_Push"/>
		</member>
		<member name="C:cellmin" value="-2147483648">
			<referrer name="operator-(Float:)"/>
			<referrer name="Random"/>
			<referrer name="endofline"/>
			<referrer name="ishex"/>
			<referrer name="isnumeric"/>
			<referrer name="SkipWhitespace"/>
			<referrer name="Trim"/>
			<referrer name="Range"/>
			<referrer name="YHash"/>
			<referrer name="CallN"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
			<referrer name="CallNative"/>
			<referrer name="CallNativeByAddress"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="CodeScanInit"/>
			<referrer name="YHNPS_Find"/>
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
		</member>
		<member name="C:debug" value="2">
			<referrer name="RelocateOpcodeNow"/>
		</member>
		<member name="C:false" value="0">
			<tagname value="bool"/>
			<referrer name="Server_CrashDetectExists"/>
			<referrer name="Server_IsLongCallEnabled"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="OnGameModeInit"/>
			<referrer name="YVers_Callback"/>
			<referrer name="Utils_PreSort"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="RelocateOpcodeNow"/>
			<referrer name="GetOpcodeInstructionRelocatable"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmWrite"/>
			<referrer name="O@A_"/>
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanGetFuncName"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanFindOneFastPattern3"/>
			<referrer name="CodeScanFindOneFastPattern2"/>
			<referrer name="CodeScanRunFastPrescan"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="AddressofResolve"/>
			<referrer name="DumpAMX_WriteAMXHeader"/>
			<referrer name="DumpAMX_Write"/>
			<referrer name="SetColour"/>
			<referrer name="GetColour"/>
			<referrer name="GetColourStream"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_IsolateName"/>
			<referrer name="Account_RegisterHandler"/>
			<referrer name="Account_EmailDialogHandler"/>
			<referrer name="Account_LoginDialog"/>
			<referrer name="OnPlayerRegister"/>
			<referrer name="OnPasswordChecked"/>
		</member>
		<member name="C:hash_bernstein" value="0">
			<tagname value="e_HASH_TYPE"/>
			<referrer name="YHash"/>
			<referrer name="SetColour"/>
			<referrer name="GetColour"/>
			<referrer name="GetColourStream"/>
		</member>
		<member name="C:hash_fnv1" value="1">
			<tagname value="e_HASH_TYPE"/>
			<referrer name="YHash"/>
		</member>
		<member name="C:hash_fnv1a" value="2">
			<tagname value="e_HASH_TYPE"/>
			<referrer name="YHash"/>
		</member>
		<member name="C:tag_uid_unknown" value="0">
			<tagname value="tag_uid"/>
		</member>
		<member name="C:true" value="1">
			<tagname value="bool"/>
			<referrer name="OnJITCompile"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="boolstr"/>
			<referrer name="Utils_PreSort"/>
			<referrer name="ResetStaticAmxHeader"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="GetTagNameFromID"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmWrite"/>
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="AsmEmitJrelLabelStringize"/>
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanGetFuncName"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanFindOneFastPattern3"/>
			<referrer name="CodeScanFindOneFastPattern2"/>
			<referrer name="CodeScanRunFastPrescan"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="AddressofResolve"/>
			<referrer name="DumpAMX_WriteAMXData"/>
			<referrer name="DumpAMX_WriteAMXHeader"/>
			<referrer name="DumpAMX_WriteAMXCode"/>
			<referrer name="DumpAMX_Write"/>
			<referrer name="SetColour"/>
			<referrer name="_SetColourHash"/>
			<referrer name="GetColour"/>
			<referrer name="GetColourStream"/>
			<referrer name="GetColourHash"/>
			<referrer name="Colours_DoHashParse"/>
			<referrer name="mysql_aquery"/>
			<referrer name="mysql_aquery_s"/>
			<referrer name="__ppAsyncMySQLHandler"/>
			<referrer name="AdvancedKick"/>
			<referrer name="Database_Connect"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="Hooks_GetFunctionWritePoint"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="_Hooks_RepairStub"/>
			<referrer name="Account_RegisterHandler"/>
			<referrer name="Account_LoginDialog"/>
			<referrer name="OnPlayerAccountChecked"/>
			<referrer name="Indirection_OnGameModeInit"/>
		</member>

		<!-- variables -->
		<member name="F:@_">
			<attribute name="public"/>
			<referrer name="K@"/>
			<referrer name="D@"/>
			<referrer name="@@_SetColoursCanHaveSpaces"/>
			<referrer name="@@_SetColourHash"/>
		</member>
		<member name="F:AMX_BASE_ADDRESS">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetEntryPrefix"/>
			<referrer name="AMX_GetEntrySuffix"/>
			<referrer name="AMX_GetName"/>
			<referrer name="AMX_GetNamePrefix"/>
			<referrer name="AMX_GetNameSuffix"/>
			<referrer name="AMX_GetStringFromEntry"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_InvalidateName"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="_Hooks_RepairStub"/>
		</member>
		<member name="F:AMX_HEADER_AMX_VERSION">
			<referrer name="Debug_OnCodeInit"/>
		</member>
		<member name="F:AMX_HEADER_CIP">
			<referrer name="Debug_OnCodeInit"/>
		</member>
		<member name="F:AMX_HEADER_COD">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetGlobal"/>
			<referrer name="AMX_TraceCode"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="ThirdParty_OnCodeInit"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
		</member>
		<member name="F:AMX_HEADER_DAT">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_TraceCode"/>
			<referrer name="AMX_TraceMemory"/>
		</member>
		<member name="F:AMX_HEADER_DEFSIZE">
			<referrer name="Debug_OnCodeInit"/>
		</member>
		<member name="F:AMX_HEADER_FILE_VERSION">
			<referrer name="Debug_OnCodeInit"/>
		</member>
		<member name="F:AMX_HEADER_FLAGS">
			<referrer name="Debug_OnCodeInit"/>
		</member>
		<member name="F:AMX_HEADER_HEA">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_TraceMemory"/>
		</member>
		<member name="F:AMX_HEADER_LIBRARIES">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_HEADER_MAGIC">
			<referrer name="Debug_OnCodeInit"/>
		</member>
		<member name="F:AMX_HEADER_NAMETABLE">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_HEADER_NATIVES">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetBaseCount"/>
			<referrer name="AMX_GetEntryFromNativeIndex"/>
			<referrer name="AMX_GetNativeIndexFromEntry"/>
			<referrer name="Hooks_SortPublics"/>
		</member>
		<member name="F:AMX_HEADER_PUBLICS">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetBaseCount"/>
			<referrer name="AMX_GetEntryFromPublicIndex"/>
			<referrer name="AMX_GetPublicIndexFromEntry"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="_Hooks_RepairStub"/>
			<referrer name="Hooks_RepairJITInit"/>
		</member>
		<member name="F:AMX_HEADER_PUBVARS">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_HEADER_SIZE">
			<referrer name="Debug_OnCodeInit"/>
		</member>
		<member name="F:AMX_HEADER_STP">
			<referrer name="Debug_OnCodeInit"/>
		</member>
		<member name="F:AMX_HEADER_TAGS">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetBaseCount"/>
		</member>
		<member name="F:AMX_REAL_ADDRESS">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="Hooks_WriteFunction"/>
		</member>
		<member name="F:AMX_REAL_DATA">
			<referrer name="Debug_OnCodeInit"/>
			<referrer name="AMX_GetGlobalAddress"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
		</member>
		<member name="F:ASM_ARGUMENTS_OFFSET">
			<referrer name="AsmGetArgOffset"/>
		</member>
		<member name="F:ASM_CALLER_FRAME_OFFSET">
		</member>
		<member name="F:ASM_CTRL_CIP">
		</member>
		<member name="F:ASM_CTRL_COD">
		</member>
		<member name="F:ASM_CTRL_DAT">
		</member>
		<member name="F:ASM_CTRL_FRM">
		</member>
		<member name="F:ASM_CTRL_HEA">
		</member>
		<member name="F:ASM_CTRL_JIT">
		</member>
		<member name="F:ASM_CTRL_JMP">
		</member>
		<member name="F:ASM_CTRL_STK">
		</member>
		<member name="F:ASM_CTRL_STP">
		</member>
		<member name="F:ASM_LOCALS_OFFSET">
		</member>
		<member name="F:ASM_RETURN_ADDR_OFFSET">
		</member>
		<member name="F:AsyncDialogResponseHandler">
			<tagname value="CallbackHandler"/>
			<referrer name="_pp@on_init@PPAsyncDialogs"/>
			<referrer name="_pp@on_exit@PPAsyncDialogs"/>
		</member>
		<member name="F:FALSE">
			<tagname value="bool"/>
			<referrer name="Hooks_RepairJITInit"/>
		</member>
		<member name="F:I@">
			<referrer name="_@_SetColoursCanHaveSpaces"/>
			<referrer name="SetColoursCanHaveSpaces"/>
			<referrer name="SetColourHash"/>
			<referrer name="_@_SetColourHash"/>
		</member>
		<member name="F:INDIRECTION_DATA">
			<referrer name="Indirect_Call"/>
			<referrer name="Indirect_Callstring"/>
			<referrer name="Indirect_Callvoid"/>
			<referrer name="Indirect_Array"/>
		</member>
		<member name="F:INDIRECTION_TAG">
			<referrer name="Indirect_Call"/>
			<referrer name="Indirect_Callstring"/>
			<referrer name="Indirect_Callvoid"/>
			<referrer name="Indirect_Array"/>
		</member>
		<member name="F:J@">
			<referrer name="_@_SetColoursCanHaveSpaces"/>
			<referrer name="SetColoursCanHaveSpaces"/>
			<referrer name="SetColourHash"/>
			<referrer name="_@_SetColourHash"/>
		</member>
		<member name="F:NULL">
		</member>
		<member name="F:O@V_">
			<referrer name="O@A_"/>
			<referrer name="AddressofResolve"/>
			<referrer name="Hooks_GenerateContinue"/>
		</member>
		<member name="F:PlayerDialogTasks">
			<tagname value="Task"/>
			<referrer name="AwaitAsyncDialog"/>
			<referrer name="AwaitAsyncDialogStr"/>
			<referrer name="ShowPlayerAsyncDialog"/>
			<referrer name="ShowPlayerAsyncDialogStr"/>
			<referrer name="AsyncDialogsHandler"/>
		</member>
		<member name="F:Q@">
			<referrer name="K@"/>
			<referrer name="G@"/>
		</member>
		<member name="F:SAMP_INCLUDES_VERSION">
			<attribute name="public"/>
		</member>
		<member name="F:TRUE">
			<tagname value="bool"/>
		</member>
		<member name="F:UNIQUE_SYMBOL_DOESNT_EXIST">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:UNIQUE_SYMBOL_LESS_THAN_100">
		</member>
		<member name="F:YSIM_VERMAX">
		</member>
		<member name="F:YSIM_VERRET">
		</member>
		<member name="F:YSI_FILTERSCRIPT">
			<tagname value="bool"/>
			<referrer name="Server_IsFilterscript"/>
			<referrer name="Server_IsGameMode"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="OnGameModeInit"/>
			<referrer name="OnFilterScriptExit"/>
			<referrer name="OnGameModeExit"/>
			<referrer name="ScriptInit_OnCodeInit"/>
		</member>
		<member name="F:YSI_gDebugLevel">
			<referrer name="Debug_Level"/>
		</member>
		<member name="F:YSI_gPlayerIP">
			<referrer name="OnPlayerConnect"/>
			<referrer name="OnPlayerDisconnect"/>
		</member>
		<member name="F:YSI_gUnsafeHugeString">
		</member>
		<member name="F:YSI_g_sActiveHooks">
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="OnRuntimeError"/>
		</member>
		<member name="F:YSI_g_sCallData">
			<referrer name="K@"/>
			<referrer name="D@"/>
			<referrer name="F@"/>
		</member>
		<member name="F:YSI_g_sCheckSpaces">
			<tagname value="bool"/>
			<referrer name="_SetColoursCanHaveSpaces"/>
			<referrer name="SetColour"/>
			<referrer name="GetColour"/>
			<referrer name="GetColourStream"/>
		</member>
		<member name="F:YSI_g_sCodeEnd">
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="CGen_UseCodeSpace"/>
		</member>
		<member name="F:YSI_g_sCodeSpace">
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="ThirdParty_OnCodeInit"/>
			<referrer name="CGen_UseCodeSpace"/>
			<referrer name="CGen_GetCodeSpace"/>
			<referrer name="CGen_AddCodeSpace"/>
		</member>
		<member name="F:YSI_g_sColours">
			<referrer name="_SetColourHash"/>
			<referrer name="GetColourStream"/>
			<referrer name="GetColourHash"/>
		</member>
		<member name="F:YSI_g_sInitFSIdx">
			<referrer name="CGen_OnCodeInit"/>
			<referrer name="_Hooks_RepairStub"/>
			<referrer name="Hooks_RepairJITInit"/>
		</member>
		<member name="F:YSI_g_sInitFSPtr">
			<referrer name="_Hooks_RepairStubFS"/>
			<referrer name="Hooks_RepairJITInit"/>
		</member>
		<member name="F:YSI_g_sInitFSRep">
			<referrer name="_Hooks_RepairStub"/>
			<referrer name="Hooks_RepairJITInit"/>
		</member>
		<member name="F:YSI_g_sInitGMIdx">
			<referrer name="CGen_OnCodeInit"/>
			<referrer name="_Hooks_RepairStub"/>
			<referrer name="Hooks_RepairJITInit"/>
		</member>
		<member name="F:YSI_g_sInitGMPtr">
			<referrer name="_Hooks_RepairStubGM"/>
			<referrer name="Hooks_RepairJITInit"/>
		</member>
		<member name="F:YSI_g_sInitGMRep">
			<referrer name="_Hooks_RepairStub"/>
			<referrer name="Hooks_RepairJITInit"/>
		</member>
		<member name="F:YSI_g_sInitPublicDiff">
			<referrer name="Hooks_SortPublics"/>
			<referrer name="_Hooks_RepairStub"/>
		</member>
		<member name="F:YSI_g_sNPSBaseCall">
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
		</member>
		<member name="F:YSI_g_sNPSReplace">
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
		</member>
		<member name="F:YSI_g_sNPSStack">
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
		</member>
		<member name="F:YSI_g_sNPSTrampoline">
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
		</member>
		<member name="F:YSI_g_sPropCaller">
			<referrer name="K@"/>
			<referrer name="D@"/>
		</member>
		<member name="F:YSI_g_sPropEmpty">
			<referrer name="K@"/>
			<referrer name="D@"/>
			<referrer name="T@"/>
		</member>
		<member name="F:YSI_g_sPropReturn">
			<referrer name="D@"/>
			<referrer name="L@"/>
			<referrer name="X@"/>
		</member>
		<member name="F:YSI_g_sPropVarArg">
			<referrer name="K@"/>
			<referrer name="D@"/>
			<referrer name="L@"/>
			<referrer name="T@"/>
		</member>
		<member name="F:YSI_g_sReplacePtr">
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sReplacements">
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sReplacementsLongOrder">
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sReplacementsShortOrder">
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_SortReplacements"/>
		</member>
		<member name="F:YSI_g_sScriptInitState">
			<tagname value="E_SCRIPTINIT_STATE"/>
			<referrer name="Server_JITExists"/>
			<referrer name="Server_JITComplete"/>
			<referrer name="Server_CacheLoaded"/>
			<referrer name="Server_CacheSaved"/>
			<referrer name="ScriptInit_CallOnCodeInit"/>
			<referrer name="OnJITCompile"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="OnGameModeInit"/>
		</member>
		<member name="F:YSI_g_sSortedOnce">
			<tagname value="bool"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="_Hooks_RepairStub"/>
		</member>
		<member name="F:YSI_g_sTempRet">
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
		</member>
		<member name="F:YSI_g_sYSIM_STRING">
			<referrer name="K@"/>
		</member>
		<member name="F:YSI_g_sYSI_MAX_STRING">
			<referrer name="K@"/>
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:Y_UNIQUE_000_to_099_CALLED">
		</member>
		<member name="F:_PP@TMP1">
		</member>
		<member name="F:_PP@TMP2">
		</member>
		<member name="F:_PP@TMP3">
		</member>
		<member name="F:_PP@TRUE">
		</member>
		<member name="F:__ARR">
		</member>
		<member name="F:__REF">
		</member>
		<member name="F:__YSI_gsCompilerEnum">
		</member>
		<member name="F:__date">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__file">
		</member>
		<member name="F:__gOnce">
		</member>
		<member name="F:__time">
		</member>
		<member name="F:account_Email">
			<referrer name="Account_ReturnEmail"/>
			<referrer name="Account_SetEmail"/>
			<referrer name="Account_ResetInfo"/>
		</member>
		<member name="F:account_ID">
			<referrer name="Account_ReturnID"/>
			<referrer name="Account_SetID"/>
			<referrer name="Account_ResetInfo"/>
		</member>
		<member name="F:account_Name">
			<referrer name="Account_ReturnName"/>
			<referrer name="Account_SetName"/>
			<referrer name="Account_ResetInfo"/>
		</member>
		<member name="F:account_Password">
			<referrer name="Account_ReturnPassword"/>
			<referrer name="Account_SetPassword"/>
			<referrer name="Account_ResetInfo"/>
		</member>
		<member name="F:account_Password_Attempts">
			<referrer name="Account_ReturnLoginAttempts"/>
			<referrer name="Account_SetLoginAttempts"/>
		</member>
		<member name="F:auth_RaceCheck">
			<referrer name="@yH_OnPlayerConnect@002"/>
			<referrer name="@yH_OnPlayerDisconnect@002"/>
			<referrer name="account_CheckIfExists"/>
		</member>
		<member name="F:gBase">
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanInit"/>
		</member>
		<member name="F:gCodBase">
			<referrer name="CodeScanRunFastPrescan"/>
			<referrer name="CodeScanInit"/>
		</member>
		<member name="F:gCodBase">
			<referrer name="DisasmInit"/>
			<referrer name="DisasmReloc"/>
			<referrer name="DisasmWriteCode"/>
		</member>
		<member name="F:gCodeScanCallback_match">
			<referrer name="AddressofResolve"/>
		</member>
		<member name="F:gDat">
			<referrer name="CodeScanRun"/>
			<referrer name="CodeScanInit"/>
			<referrer name="CodeScanGetMatchFunc"/>
			<referrer name="CodeScanGetMatchAddress"/>
		</member>
		<member name="F:gHdr">
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanInit"/>
		</member>
		<member name="F:gHdr">
			<referrer name="ResetStaticAmxHeader"/>
			<referrer name="GetAmxHeader"/>
			<referrer name="GetAmxHeaderComponent"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
		</member>
		<member name="F:gInitialized">
			<tagname value="bool"/>
			<referrer name="ResetStaticAmxHeader"/>
			<referrer name="GetAmxHeader"/>
			<referrer name="GetAmxHeaderComponent"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
		</member>
		<member name="F:gOP_CASETBL">
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanInit"/>
		</member>
		<member name="F:gOP_NOP">
			<referrer name="CodeScanInit"/>
			<referrer name="CodeScanNOPMatch"/>
		</member>
		<member name="F:gOpArgCount">
			<referrer name="CodeScanRunFastPrescan"/>
		</member>
		<member name="F:gPreviousWriteOffset">
			<referrer name="AsmEmitInstruction"/>
			<referrer name="AsmEmitJumpLabelInstruction"/>
			<referrer name="AsmGetPreviousWriteOffset"/>
		</member>
		<member name="F:g_args">
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="Call"/>
			<referrer name="CallN"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
		</member>
		<member name="F:g_nargs">
			<referrer name="Push"/>
			<referrer name="Pop"/>
			<referrer name="Call"/>
			<referrer name="CallN"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
		</member>
		<member name="F:gsCodSize">
			<referrer name="Indirect_Call"/>
			<referrer name="Indirect_Callstring"/>
			<referrer name="Indirect_Callvoid"/>
			<referrer name="Indirect_Array"/>
			<referrer name="Indirect_GetMeta_"/>
			<referrer name="Indirect_SetMeta_"/>
			<referrer name="Indirect_Claim_"/>
			<referrer name="Indirect_Release_"/>
			<referrer name="Indirect_Ref_"/>
			<referrer name="Indirect_Ptr_"/>
			<referrer name="Indirect_DeRef_"/>
			<referrer name="Indirect_DePtr_"/>
			<referrer name="Indirect_Init"/>
		</member>
		<member name="F:handle_Sql">
			<tagname value="MySQL"/>
			<referrer name="Database_ReturnHandle"/>
			<referrer name="Database_Connect"/>
		</member>
		<member name="F:insn_table">
			<referrer name="GetOpcodeInstructionInformation"/>
			<referrer name="GetOpcodeInstructionName"/>
			<referrer name="GetOpcodeInstructionParameters"/>
			<referrer name="GetOpcodeInstructionRelocatable"/>
		</member>
		<member name="F:opcode_table">
			<tagname value="Opcode"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="RelocateOpcode"/>
			<referrer name="UnrelocateOpcode"/>
		</member>
		<member name="F:opcode_table_is_ready">
			<tagname value="bool"/>
			<referrer name="InitOpcodeTable"/>
			<referrer name="RelocateOpcode"/>
			<referrer name="UnrelocateOpcode"/>
		</member>

		<!-- functions -->
		<member name="M:operator!(Handle:)" syntax="operator!(Handle:)(handle)">
			<tagname value="bool"/>
			<stacksize value="3"/>
			<dependency name="handle_alive"/>
			<param name="handle">
				<paraminfo>Handle </paraminfo>
			</param>
		</member>
		<member name="M:operator!(Float:)" syntax="operator!(Float:)(oper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="cellmax"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator!=(Handle:,Handle:)" syntax="operator!=(Handle:,Handle:)(arg1, arg2)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="operator==(Handle:,Handle:)"/>
			<param name="arg1">
				<paraminfo>Handle </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Handle </paraminfo>
			</param>
		</member>
		<member name="M:operator!=(Iter:,Iter:)" syntax="operator!=(Iter:,Iter:)(arg1, arg2)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="operator==(Iter:,Iter:)"/>
			<param name="arg1">
				<paraminfo>Iter </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Iter </paraminfo>
			</param>
		</member>
		<member name="M:operator!=(String@Const:,String@Const:)" syntax="operator!=(String@Const:,String@Const:)(arg1, arg2)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="operator==(String@Const:,String@Const:)"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator!=(String@Const:,String:)" syntax="operator!=(String@Const:,String:)(arg1, arg2)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="operator==(String@Const:,String:)"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator!=(String:,String@Const:)" syntax="operator!=(String:,String@Const:)(arg1, arg2)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="operator==(String:,String@Const:)"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator!=(String:,String:)" syntax="operator!=(String:,String:)(arg1, arg2)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="operator==(String:,String:)"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariantBuffer:,_:)" syntax="operator+(AmxVariantBuffer:,_:)(arg1, arg2)">
			<tagname value="AmxVariantBuffer"/>
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator+(AmxStringBuffer:,_:)" syntax="operator+(AmxStringBuffer:,_:)(arg1, arg2)">
			<tagname value="AmxStringBuffer"/>
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator%(AmxVariantBuffer:,AmxVariantBuffer:)" syntax="operator%(AmxVariantBuffer:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariantBuffer:,AmxVariantBuffer:)" syntax="operator/(AmxVariantBuffer:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariantBuffer:,AmxVariantBuffer:)" syntax="operator*(AmxVariantBuffer:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariantBuffer:,AmxVariantBuffer:)" syntax="operator-(AmxVariantBuffer:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariantBuffer:,AmxVariantBuffer:)" syntax="operator+(AmxVariantBuffer:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariantBuffer:,ConstAmxVariant:)" syntax="operator%(AmxVariantBuffer:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariantBuffer:,ConstAmxVariant:)" syntax="operator/(AmxVariantBuffer:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariantBuffer:,ConstAmxVariant:)" syntax="operator*(AmxVariantBuffer:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariantBuffer:,ConstAmxVariant:)" syntax="operator-(AmxVariantBuffer:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariantBuffer:,ConstAmxVariant:)" syntax="operator+(AmxVariantBuffer:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariantBuffer:,AmxVariant:)" syntax="operator%(AmxVariantBuffer:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariantBuffer:,AmxVariant:)" syntax="operator/(AmxVariantBuffer:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariantBuffer:,AmxVariant:)" syntax="operator*(AmxVariantBuffer:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariantBuffer:,AmxVariant:)" syntax="operator-(AmxVariantBuffer:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariantBuffer:,AmxVariant:)" syntax="operator+(AmxVariantBuffer:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariantBuffer:,AmxStringBuffer:)" syntax="operator%(AmxVariantBuffer:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariantBuffer:,AmxStringBuffer:)" syntax="operator/(AmxVariantBuffer:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariantBuffer:,AmxStringBuffer:)" syntax="operator*(AmxVariantBuffer:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariantBuffer:,AmxStringBuffer:)" syntax="operator-(AmxVariantBuffer:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariantBuffer:,AmxStringBuffer:)" syntax="operator+(AmxVariantBuffer:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariantBuffer:,ConstAmxString:)" syntax="operator%(AmxVariantBuffer:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariantBuffer:,ConstAmxString:)" syntax="operator/(AmxVariantBuffer:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariantBuffer:,ConstAmxString:)" syntax="operator*(AmxVariantBuffer:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariantBuffer:,ConstAmxString:)" syntax="operator-(AmxVariantBuffer:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariantBuffer:,ConstAmxString:)" syntax="operator+(AmxVariantBuffer:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariantBuffer:,AmxString:)" syntax="operator%(AmxVariantBuffer:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariantBuffer:,AmxString:)" syntax="operator/(AmxVariantBuffer:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariantBuffer:,AmxString:)" syntax="operator*(AmxVariantBuffer:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariantBuffer:,AmxString:)" syntax="operator-(AmxVariantBuffer:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariantBuffer:,AmxString:)" syntax="operator+(AmxVariantBuffer:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariantBuffer:,String@Const:)" syntax="operator%(AmxVariantBuffer:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariantBuffer:,String@Const:)" syntax="operator/(AmxVariantBuffer:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariantBuffer:,String@Const:)" syntax="operator*(AmxVariantBuffer:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariantBuffer:,String@Const:)" syntax="operator-(AmxVariantBuffer:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariantBuffer:,String@Const:)" syntax="operator+(AmxVariantBuffer:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariantBuffer:,String:)" syntax="operator%(AmxVariantBuffer:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariantBuffer:,String:)" syntax="operator/(AmxVariantBuffer:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariantBuffer:,String:)" syntax="operator*(AmxVariantBuffer:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariantBuffer:,String:)" syntax="operator-(AmxVariantBuffer:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariantBuffer:,String:)" syntax="operator+(AmxVariantBuffer:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariantBuffer:,Float:)" syntax="operator%(AmxVariantBuffer:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariantBuffer:,Float:)" syntax="operator/(AmxVariantBuffer:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariantBuffer:,Float:)" syntax="operator*(AmxVariantBuffer:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariantBuffer:,Float:)" syntax="operator-(AmxVariantBuffer:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariantBuffer:,Float:)" syntax="operator+(AmxVariantBuffer:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariantBuffer:,_:)" syntax="operator%(AmxVariantBuffer:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator/(AmxVariantBuffer:,_:)" syntax="operator/(AmxVariantBuffer:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator*(AmxVariantBuffer:,_:)" syntax="operator*(AmxVariantBuffer:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator-(AmxVariantBuffer:,_:)" syntax="operator-(AmxVariantBuffer:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator%(ConstAmxVariant:,AmxVariantBuffer:)" syntax="operator%(ConstAmxVariant:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxVariant:,AmxVariantBuffer:)" syntax="operator/(ConstAmxVariant:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxVariant:,AmxVariantBuffer:)" syntax="operator*(ConstAmxVariant:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxVariant:,AmxVariantBuffer:)" syntax="operator-(ConstAmxVariant:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxVariant:,AmxVariantBuffer:)" syntax="operator+(ConstAmxVariant:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxVariant:,ConstAmxVariant:)" syntax="operator%(ConstAmxVariant:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxVariant:,ConstAmxVariant:)" syntax="operator/(ConstAmxVariant:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxVariant:,ConstAmxVariant:)" syntax="operator*(ConstAmxVariant:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxVariant:,ConstAmxVariant:)" syntax="operator-(ConstAmxVariant:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxVariant:,ConstAmxVariant:)" syntax="operator+(ConstAmxVariant:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxVariant:,AmxVariant:)" syntax="operator%(ConstAmxVariant:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxVariant:,AmxVariant:)" syntax="operator/(ConstAmxVariant:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxVariant:,AmxVariant:)" syntax="operator*(ConstAmxVariant:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxVariant:,AmxVariant:)" syntax="operator-(ConstAmxVariant:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxVariant:,AmxVariant:)" syntax="operator+(ConstAmxVariant:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxVariant:,AmxStringBuffer:)" syntax="operator%(ConstAmxVariant:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxVariant:,AmxStringBuffer:)" syntax="operator/(ConstAmxVariant:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxVariant:,AmxStringBuffer:)" syntax="operator*(ConstAmxVariant:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxVariant:,AmxStringBuffer:)" syntax="operator-(ConstAmxVariant:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxVariant:,AmxStringBuffer:)" syntax="operator+(ConstAmxVariant:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxVariant:,ConstAmxString:)" syntax="operator%(ConstAmxVariant:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxVariant:,ConstAmxString:)" syntax="operator/(ConstAmxVariant:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxVariant:,ConstAmxString:)" syntax="operator*(ConstAmxVariant:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxVariant:,ConstAmxString:)" syntax="operator-(ConstAmxVariant:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxVariant:,ConstAmxString:)" syntax="operator+(ConstAmxVariant:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxVariant:,AmxString:)" syntax="operator%(ConstAmxVariant:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxVariant:,AmxString:)" syntax="operator/(ConstAmxVariant:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxVariant:,AmxString:)" syntax="operator*(ConstAmxVariant:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxVariant:,AmxString:)" syntax="operator-(ConstAmxVariant:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxVariant:,AmxString:)" syntax="operator+(ConstAmxVariant:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxVariant:,String@Const:)" syntax="operator%(ConstAmxVariant:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxVariant:,String@Const:)" syntax="operator/(ConstAmxVariant:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxVariant:,String@Const:)" syntax="operator*(ConstAmxVariant:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxVariant:,String@Const:)" syntax="operator-(ConstAmxVariant:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxVariant:,String@Const:)" syntax="operator+(ConstAmxVariant:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxVariant:,String:)" syntax="operator%(ConstAmxVariant:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxVariant:,String:)" syntax="operator/(ConstAmxVariant:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxVariant:,String:)" syntax="operator*(ConstAmxVariant:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxVariant:,String:)" syntax="operator-(ConstAmxVariant:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxVariant:,String:)" syntax="operator+(ConstAmxVariant:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxVariant:,Float:)" syntax="operator%(ConstAmxVariant:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxVariant:,Float:)" syntax="operator/(ConstAmxVariant:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxVariant:,Float:)" syntax="operator*(ConstAmxVariant:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxVariant:,Float:)" syntax="operator-(ConstAmxVariant:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxVariant:,Float:)" syntax="operator+(ConstAmxVariant:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxVariant:,_:)" syntax="operator%(ConstAmxVariant:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator/(ConstAmxVariant:,_:)" syntax="operator/(ConstAmxVariant:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator*(ConstAmxVariant:,_:)" syntax="operator*(ConstAmxVariant:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator-(ConstAmxVariant:,_:)" syntax="operator-(ConstAmxVariant:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator+(ConstAmxVariant:,_:)" syntax="operator+(ConstAmxVariant:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator%(AmxVariant:,AmxVariantBuffer:)" syntax="operator%(AmxVariant:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariant:,AmxVariantBuffer:)" syntax="operator/(AmxVariant:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariant:,AmxVariantBuffer:)" syntax="operator*(AmxVariant:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariant:,AmxVariantBuffer:)" syntax="operator-(AmxVariant:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariant:,AmxVariantBuffer:)" syntax="operator+(AmxVariant:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariant:,ConstAmxVariant:)" syntax="operator%(AmxVariant:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariant:,ConstAmxVariant:)" syntax="operator/(AmxVariant:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariant:,ConstAmxVariant:)" syntax="operator*(AmxVariant:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariant:,ConstAmxVariant:)" syntax="operator-(AmxVariant:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariant:,ConstAmxVariant:)" syntax="operator+(AmxVariant:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariant:,AmxVariant:)" syntax="operator%(AmxVariant:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariant:,AmxVariant:)" syntax="operator/(AmxVariant:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariant:,AmxVariant:)" syntax="operator*(AmxVariant:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariant:,AmxVariant:)" syntax="operator-(AmxVariant:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariant:,AmxVariant:)" syntax="operator+(AmxVariant:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariant:,AmxStringBuffer:)" syntax="operator%(AmxVariant:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariant:,AmxStringBuffer:)" syntax="operator/(AmxVariant:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariant:,AmxStringBuffer:)" syntax="operator*(AmxVariant:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariant:,AmxStringBuffer:)" syntax="operator-(AmxVariant:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariant:,AmxStringBuffer:)" syntax="operator+(AmxVariant:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariant:,ConstAmxString:)" syntax="operator%(AmxVariant:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariant:,ConstAmxString:)" syntax="operator/(AmxVariant:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariant:,ConstAmxString:)" syntax="operator*(AmxVariant:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariant:,ConstAmxString:)" syntax="operator-(AmxVariant:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariant:,ConstAmxString:)" syntax="operator+(AmxVariant:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariant:,AmxString:)" syntax="operator%(AmxVariant:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariant:,AmxString:)" syntax="operator/(AmxVariant:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariant:,AmxString:)" syntax="operator*(AmxVariant:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariant:,AmxString:)" syntax="operator-(AmxVariant:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariant:,AmxString:)" syntax="operator+(AmxVariant:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariant:,String@Const:)" syntax="operator%(AmxVariant:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariant:,String@Const:)" syntax="operator/(AmxVariant:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariant:,String@Const:)" syntax="operator*(AmxVariant:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariant:,String@Const:)" syntax="operator-(AmxVariant:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariant:,String@Const:)" syntax="operator+(AmxVariant:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariant:,String:)" syntax="operator%(AmxVariant:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariant:,String:)" syntax="operator/(AmxVariant:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariant:,String:)" syntax="operator*(AmxVariant:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariant:,String:)" syntax="operator-(AmxVariant:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariant:,String:)" syntax="operator+(AmxVariant:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariant:,Float:)" syntax="operator%(AmxVariant:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxVariant:,Float:)" syntax="operator/(AmxVariant:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxVariant:,Float:)" syntax="operator*(AmxVariant:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariant:,Float:)" syntax="operator-(AmxVariant:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxVariant:,Float:)" syntax="operator+(AmxVariant:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxVariant:,_:)" syntax="operator%(AmxVariant:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator/(AmxVariant:,_:)" syntax="operator/(AmxVariant:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator*(AmxVariant:,_:)" syntax="operator*(AmxVariant:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator-(AmxVariant:,_:)" syntax="operator-(AmxVariant:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator+(AmxVariant:,_:)" syntax="operator+(AmxVariant:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxVariant </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator%(AmxStringBuffer:,AmxVariantBuffer:)" syntax="operator%(AmxStringBuffer:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxStringBuffer:,AmxVariantBuffer:)" syntax="operator/(AmxStringBuffer:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxStringBuffer:,AmxVariantBuffer:)" syntax="operator*(AmxStringBuffer:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxStringBuffer:,AmxVariantBuffer:)" syntax="operator-(AmxStringBuffer:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxStringBuffer:,AmxVariantBuffer:)" syntax="operator+(AmxStringBuffer:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxStringBuffer:,ConstAmxVariant:)" syntax="operator%(AmxStringBuffer:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxStringBuffer:,ConstAmxVariant:)" syntax="operator/(AmxStringBuffer:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxStringBuffer:,ConstAmxVariant:)" syntax="operator*(AmxStringBuffer:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxStringBuffer:,ConstAmxVariant:)" syntax="operator-(AmxStringBuffer:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxStringBuffer:,ConstAmxVariant:)" syntax="operator+(AmxStringBuffer:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxStringBuffer:,AmxVariant:)" syntax="operator%(AmxStringBuffer:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxStringBuffer:,AmxVariant:)" syntax="operator/(AmxStringBuffer:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxStringBuffer:,AmxVariant:)" syntax="operator*(AmxStringBuffer:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxStringBuffer:,AmxVariant:)" syntax="operator-(AmxStringBuffer:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxStringBuffer:,AmxVariant:)" syntax="operator+(AmxStringBuffer:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxStringBuffer:,AmxStringBuffer:)" syntax="operator%(AmxStringBuffer:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxStringBuffer:,AmxStringBuffer:)" syntax="operator/(AmxStringBuffer:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxStringBuffer:,AmxStringBuffer:)" syntax="operator*(AmxStringBuffer:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxStringBuffer:,AmxStringBuffer:)" syntax="operator-(AmxStringBuffer:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxStringBuffer:,AmxStringBuffer:)" syntax="operator+(AmxStringBuffer:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxStringBuffer:,ConstAmxString:)" syntax="operator%(AmxStringBuffer:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxStringBuffer:,ConstAmxString:)" syntax="operator/(AmxStringBuffer:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxStringBuffer:,ConstAmxString:)" syntax="operator*(AmxStringBuffer:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxStringBuffer:,ConstAmxString:)" syntax="operator-(AmxStringBuffer:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxStringBuffer:,ConstAmxString:)" syntax="operator+(AmxStringBuffer:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxStringBuffer:,AmxString:)" syntax="operator%(AmxStringBuffer:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxStringBuffer:,AmxString:)" syntax="operator/(AmxStringBuffer:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxStringBuffer:,AmxString:)" syntax="operator*(AmxStringBuffer:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxStringBuffer:,AmxString:)" syntax="operator-(AmxStringBuffer:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxStringBuffer:,AmxString:)" syntax="operator+(AmxStringBuffer:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxStringBuffer:,String@Const:)" syntax="operator%(AmxStringBuffer:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxStringBuffer:,String@Const:)" syntax="operator/(AmxStringBuffer:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxStringBuffer:,String@Const:)" syntax="operator*(AmxStringBuffer:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxStringBuffer:,String@Const:)" syntax="operator-(AmxStringBuffer:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxStringBuffer:,String@Const:)" syntax="operator+(AmxStringBuffer:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxStringBuffer:,String:)" syntax="operator%(AmxStringBuffer:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxStringBuffer:,String:)" syntax="operator/(AmxStringBuffer:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxStringBuffer:,String:)" syntax="operator*(AmxStringBuffer:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxStringBuffer:,String:)" syntax="operator-(AmxStringBuffer:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxStringBuffer:,String:)" syntax="operator+(AmxStringBuffer:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxStringBuffer:,Float:)" syntax="operator%(AmxStringBuffer:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxStringBuffer:,Float:)" syntax="operator/(AmxStringBuffer:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxStringBuffer:,Float:)" syntax="operator*(AmxStringBuffer:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxStringBuffer:,Float:)" syntax="operator-(AmxStringBuffer:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxStringBuffer:,Float:)" syntax="operator+(AmxStringBuffer:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxStringBuffer:,_:)" syntax="operator%(AmxStringBuffer:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator/(AmxStringBuffer:,_:)" syntax="operator/(AmxStringBuffer:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator*(AmxStringBuffer:,_:)" syntax="operator*(AmxStringBuffer:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator-(AmxStringBuffer:,_:)" syntax="operator-(AmxStringBuffer:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator%(ConstAmxString:,AmxVariantBuffer:)" syntax="operator%(ConstAmxString:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxString:,AmxVariantBuffer:)" syntax="operator/(ConstAmxString:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxString:,AmxVariantBuffer:)" syntax="operator*(ConstAmxString:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxString:,AmxVariantBuffer:)" syntax="operator-(ConstAmxString:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxString:,AmxVariantBuffer:)" syntax="operator+(ConstAmxString:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxString:,ConstAmxVariant:)" syntax="operator%(ConstAmxString:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxString:,ConstAmxVariant:)" syntax="operator/(ConstAmxString:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxString:,ConstAmxVariant:)" syntax="operator*(ConstAmxString:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxString:,ConstAmxVariant:)" syntax="operator-(ConstAmxString:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxString:,ConstAmxVariant:)" syntax="operator+(ConstAmxString:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxString:,AmxVariant:)" syntax="operator%(ConstAmxString:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxString:,AmxVariant:)" syntax="operator/(ConstAmxString:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxString:,AmxVariant:)" syntax="operator*(ConstAmxString:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxString:,AmxVariant:)" syntax="operator-(ConstAmxString:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxString:,AmxVariant:)" syntax="operator+(ConstAmxString:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxString:,AmxStringBuffer:)" syntax="operator%(ConstAmxString:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxString:,AmxStringBuffer:)" syntax="operator/(ConstAmxString:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxString:,AmxStringBuffer:)" syntax="operator*(ConstAmxString:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxString:,AmxStringBuffer:)" syntax="operator-(ConstAmxString:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxString:,AmxStringBuffer:)" syntax="operator+(ConstAmxString:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxString:,ConstAmxString:)" syntax="operator%(ConstAmxString:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxString:,ConstAmxString:)" syntax="operator/(ConstAmxString:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxString:,ConstAmxString:)" syntax="operator*(ConstAmxString:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxString:,ConstAmxString:)" syntax="operator-(ConstAmxString:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxString:,ConstAmxString:)" syntax="operator+(ConstAmxString:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxString:,AmxString:)" syntax="operator%(ConstAmxString:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxString:,AmxString:)" syntax="operator/(ConstAmxString:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxString:,AmxString:)" syntax="operator*(ConstAmxString:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxString:,AmxString:)" syntax="operator-(ConstAmxString:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxString:,AmxString:)" syntax="operator+(ConstAmxString:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxString:,String@Const:)" syntax="operator%(ConstAmxString:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxString:,String@Const:)" syntax="operator/(ConstAmxString:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxString:,String@Const:)" syntax="operator*(ConstAmxString:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxString:,String@Const:)" syntax="operator-(ConstAmxString:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxString:,String@Const:)" syntax="operator+(ConstAmxString:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxString:,String:)" syntax="operator%(ConstAmxString:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxString:,String:)" syntax="operator/(ConstAmxString:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxString:,String:)" syntax="operator*(ConstAmxString:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxString:,String:)" syntax="operator-(ConstAmxString:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxString:,String:)" syntax="operator+(ConstAmxString:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxString:,Float:)" syntax="operator%(ConstAmxString:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(ConstAmxString:,Float:)" syntax="operator/(ConstAmxString:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator*(ConstAmxString:,Float:)" syntax="operator*(ConstAmxString:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxString:,Float:)" syntax="operator-(ConstAmxString:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator+(ConstAmxString:,Float:)" syntax="operator+(ConstAmxString:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator%(ConstAmxString:,_:)" syntax="operator%(ConstAmxString:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator/(ConstAmxString:,_:)" syntax="operator/(ConstAmxString:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator*(ConstAmxString:,_:)" syntax="operator*(ConstAmxString:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator-(ConstAmxString:,_:)" syntax="operator-(ConstAmxString:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator+(ConstAmxString:,_:)" syntax="operator+(ConstAmxString:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator%(AmxString:,AmxVariantBuffer:)" syntax="operator%(AmxString:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxString:,AmxVariantBuffer:)" syntax="operator/(AmxString:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxString:,AmxVariantBuffer:)" syntax="operator*(AmxString:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxString:,AmxVariantBuffer:)" syntax="operator-(AmxString:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxString:,AmxVariantBuffer:)" syntax="operator+(AmxString:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxString:,ConstAmxVariant:)" syntax="operator%(AmxString:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxString:,ConstAmxVariant:)" syntax="operator/(AmxString:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxString:,ConstAmxVariant:)" syntax="operator*(AmxString:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxString:,ConstAmxVariant:)" syntax="operator-(AmxString:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxString:,ConstAmxVariant:)" syntax="operator+(AmxString:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxString:,AmxVariant:)" syntax="operator%(AmxString:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxString:,AmxVariant:)" syntax="operator/(AmxString:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxString:,AmxVariant:)" syntax="operator*(AmxString:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxString:,AmxVariant:)" syntax="operator-(AmxString:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxString:,AmxVariant:)" syntax="operator+(AmxString:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxString:,AmxStringBuffer:)" syntax="operator%(AmxString:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxString:,AmxStringBuffer:)" syntax="operator/(AmxString:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxString:,AmxStringBuffer:)" syntax="operator*(AmxString:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxString:,AmxStringBuffer:)" syntax="operator-(AmxString:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxString:,AmxStringBuffer:)" syntax="operator+(AmxString:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxString:,ConstAmxString:)" syntax="operator%(AmxString:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxString:,ConstAmxString:)" syntax="operator/(AmxString:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxString:,ConstAmxString:)" syntax="operator*(AmxString:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxString:,ConstAmxString:)" syntax="operator-(AmxString:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxString:,ConstAmxString:)" syntax="operator+(AmxString:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxString:,AmxString:)" syntax="operator%(AmxString:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxString:,AmxString:)" syntax="operator/(AmxString:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxString:,AmxString:)" syntax="operator*(AmxString:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxString:,AmxString:)" syntax="operator-(AmxString:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxString:,AmxString:)" syntax="operator+(AmxString:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxString:,String@Const:)" syntax="operator%(AmxString:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxString:,String@Const:)" syntax="operator/(AmxString:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxString:,String@Const:)" syntax="operator*(AmxString:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxString:,String@Const:)" syntax="operator-(AmxString:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxString:,String@Const:)" syntax="operator+(AmxString:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxString:,String:)" syntax="operator%(AmxString:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxString:,String:)" syntax="operator/(AmxString:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxString:,String:)" syntax="operator*(AmxString:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxString:,String:)" syntax="operator-(AmxString:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxString:,String:)" syntax="operator+(AmxString:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxString:,Float:)" syntax="operator%(AmxString:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(AmxString:,Float:)" syntax="operator/(AmxString:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator*(AmxString:,Float:)" syntax="operator*(AmxString:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxString:,Float:)" syntax="operator-(AmxString:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator+(AmxString:,Float:)" syntax="operator+(AmxString:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator%(AmxString:,_:)" syntax="operator%(AmxString:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator/(AmxString:,_:)" syntax="operator/(AmxString:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator*(AmxString:,_:)" syntax="operator*(AmxString:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator-(AmxString:,_:)" syntax="operator-(AmxString:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator+(AmxString:,_:)" syntax="operator+(AmxString:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator%(String@Const:,AmxVariantBuffer:)" syntax="operator%(String@Const:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String@Const:,AmxVariantBuffer:)" syntax="operator/(String@Const:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String@Const:,AmxVariantBuffer:)" syntax="operator*(String@Const:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String@Const:,AmxVariantBuffer:)" syntax="operator-(String@Const:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator+(String@Const:,AmxVariantBuffer:)" syntax="operator+(String@Const:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator%(String@Const:,ConstAmxVariant:)" syntax="operator%(String@Const:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String@Const:,ConstAmxVariant:)" syntax="operator/(String@Const:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String@Const:,ConstAmxVariant:)" syntax="operator*(String@Const:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String@Const:,ConstAmxVariant:)" syntax="operator-(String@Const:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator+(String@Const:,ConstAmxVariant:)" syntax="operator+(String@Const:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator%(String@Const:,AmxVariant:)" syntax="operator%(String@Const:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String@Const:,AmxVariant:)" syntax="operator/(String@Const:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String@Const:,AmxVariant:)" syntax="operator*(String@Const:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String@Const:,AmxVariant:)" syntax="operator-(String@Const:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator+(String@Const:,AmxVariant:)" syntax="operator+(String@Const:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator%(String@Const:,AmxStringBuffer:)" syntax="operator%(String@Const:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String@Const:,AmxStringBuffer:)" syntax="operator/(String@Const:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String@Const:,AmxStringBuffer:)" syntax="operator*(String@Const:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String@Const:,AmxStringBuffer:)" syntax="operator-(String@Const:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator+(String@Const:,AmxStringBuffer:)" syntax="operator+(String@Const:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator%(String@Const:,ConstAmxString:)" syntax="operator%(String@Const:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String@Const:,ConstAmxString:)" syntax="operator/(String@Const:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String@Const:,ConstAmxString:)" syntax="operator*(String@Const:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String@Const:,ConstAmxString:)" syntax="operator-(String@Const:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator+(String@Const:,ConstAmxString:)" syntax="operator+(String@Const:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator%(String@Const:,AmxString:)" syntax="operator%(String@Const:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String@Const:,AmxString:)" syntax="operator/(String@Const:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String@Const:,AmxString:)" syntax="operator*(String@Const:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String@Const:,AmxString:)" syntax="operator-(String@Const:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator+(String@Const:,AmxString:)" syntax="operator+(String@Const:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String@Const:,String@Const:)" syntax="operator/(String@Const:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String@Const:,String@Const:)" syntax="operator*(String@Const:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String@Const:,String@Const:)" syntax="operator-(String@Const:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String@Const:,String:)" syntax="operator/(String@Const:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String@Const:,String:)" syntax="operator*(String@Const:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String@Const:,String:)" syntax="operator-(String@Const:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator%(String@Const:,Float:)" syntax="operator%(String@Const:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String@Const:,Float:)" syntax="operator/(String@Const:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String@Const:,Float:)" syntax="operator*(String@Const:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String@Const:,Float:)" syntax="operator-(String@Const:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator+(String@Const:,Float:)" syntax="operator+(String@Const:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator%(String@Const:,_:)" syntax="operator%(String@Const:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator/(String@Const:,_:)" syntax="operator/(String@Const:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator*(String@Const:,_:)" syntax="operator*(String@Const:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator-(String@Const:,_:)" syntax="operator-(String@Const:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator+(String@Const:,_:)" syntax="operator+(String@Const:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator%(String:,AmxVariantBuffer:)" syntax="operator%(String:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String:,AmxVariantBuffer:)" syntax="operator/(String:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String:,AmxVariantBuffer:)" syntax="operator*(String:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String:,AmxVariantBuffer:)" syntax="operator-(String:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator+(String:,AmxVariantBuffer:)" syntax="operator+(String:,AmxVariantBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator%(String:,ConstAmxVariant:)" syntax="operator%(String:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String:,ConstAmxVariant:)" syntax="operator/(String:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String:,ConstAmxVariant:)" syntax="operator*(String:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String:,ConstAmxVariant:)" syntax="operator-(String:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator+(String:,ConstAmxVariant:)" syntax="operator+(String:,ConstAmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator%(String:,AmxVariant:)" syntax="operator%(String:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String:,AmxVariant:)" syntax="operator/(String:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String:,AmxVariant:)" syntax="operator*(String:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String:,AmxVariant:)" syntax="operator-(String:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator+(String:,AmxVariant:)" syntax="operator+(String:,AmxVariant:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator%(String:,AmxStringBuffer:)" syntax="operator%(String:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String:,AmxStringBuffer:)" syntax="operator/(String:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String:,AmxStringBuffer:)" syntax="operator*(String:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String:,AmxStringBuffer:)" syntax="operator-(String:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator+(String:,AmxStringBuffer:)" syntax="operator+(String:,AmxStringBuffer:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator%(String:,ConstAmxString:)" syntax="operator%(String:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String:,ConstAmxString:)" syntax="operator/(String:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String:,ConstAmxString:)" syntax="operator*(String:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String:,ConstAmxString:)" syntax="operator-(String:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator+(String:,ConstAmxString:)" syntax="operator+(String:,ConstAmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator%(String:,AmxString:)" syntax="operator%(String:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String:,AmxString:)" syntax="operator/(String:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String:,AmxString:)" syntax="operator*(String:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String:,AmxString:)" syntax="operator-(String:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator+(String:,AmxString:)" syntax="operator+(String:,AmxString:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String:,String@Const:)" syntax="operator/(String:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String:,String@Const:)" syntax="operator*(String:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String:,String@Const:)" syntax="operator-(String:,String@Const:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String:,String:)" syntax="operator/(String:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String:,String:)" syntax="operator*(String:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String:,String:)" syntax="operator-(String:,String:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator%(String:,Float:)" syntax="operator%(String:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(String:,Float:)" syntax="operator/(String:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator*(String:,Float:)" syntax="operator*(String:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String:,Float:)" syntax="operator-(String:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator+(String:,Float:)" syntax="operator+(String:,Float:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator%(String:,_:)" syntax="operator%(String:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator/(String:,_:)" syntax="operator/(String:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator*(String:,_:)" syntax="operator*(String:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator-(String:,_:)" syntax="operator-(String:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator+(String:,_:)" syntax="operator+(String:,_:)(arg1, arg2)">
			<stacksize value="1"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
			</param>
		</member>
		<member name="M:operator++(AmxVariantBuffer:)" syntax="operator++(AmxVariantBuffer:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator++(ConstAmxVariant:)" syntax="operator++(ConstAmxVariant:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator++(AmxVariant:)" syntax="operator++(AmxVariant:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator++(AmxStringBuffer:)" syntax="operator++(AmxStringBuffer:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator++(ConstAmxString:)" syntax="operator++(ConstAmxString:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator++(AmxString:)" syntax="operator++(AmxString:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator++(String@Const:)" syntax="operator++(String@Const:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator++(String:)" syntax="operator++(String:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator--(AmxVariantBuffer:)" syntax="operator--(AmxVariantBuffer:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariantBuffer:)" syntax="operator-(AmxVariantBuffer:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator--(ConstAmxVariant:)" syntax="operator--(ConstAmxVariant:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxVariant:)" syntax="operator-(ConstAmxVariant:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator--(AmxVariant:)" syntax="operator--(AmxVariant:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxVariant:)" syntax="operator-(AmxVariant:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator--(AmxStringBuffer:)" syntax="operator--(AmxStringBuffer:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxStringBuffer:)" syntax="operator-(AmxStringBuffer:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:operator--(ConstAmxString:)" syntax="operator--(ConstAmxString:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(ConstAmxString:)" syntax="operator-(ConstAmxString:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator--(AmxString:)" syntax="operator--(AmxString:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator-(AmxString:)" syntax="operator-(AmxString:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:operator--(String@Const:)" syntax="operator--(String@Const:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String@Const:)" syntax="operator-(String@Const:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator--(String:)" syntax="operator--(String:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator-(String:)" syntax="operator-(String:)(arg)">
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator%(_:,Float:)" syntax="operator%(_:,Float:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator%(Float:,_:)" syntax="operator%(Float:,_:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator%(Float:,Float:)" syntax="operator%(Float:,Float:)(oper1, oper2)">
			<stacksize value="1"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator!=(Float:,_:)" syntax="operator!=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator!=(Float:,Float:)" syntax="operator!=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="RandomFloat"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(_:,Float:)" syntax="operator-(_:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatsub"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:,_:)" syntax="operator-(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatsub"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator+(Float:,_:)" syntax="operator+(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatadd"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator/(_:,Float:)" syntax="operator/(_:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatdiv"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(Float:,_:)" syntax="operator/(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatdiv"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator*(Float:,_:)" syntax="operator*(Float:,_:)(oper1, oper2)">
			<tagname value="Float"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatmul"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator++(Float:)" syntax="operator++(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<dependency name="operator+(Float:,Float:)"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:)" syntax="operator-(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<referrer name="RandomFloat"/>
			<dependency name="cellmin"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator--(Float:)" syntax="operator--(Float:)(oper)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<dependency name="operator-(Float:,Float:)"/>
			<param name="oper">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator-(Float:,Float:)" syntax="operator-(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator--(Float:)"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator+(Float:,Float:)" syntax="operator+(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator++(Float:)"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator/(Float:,Float:)" syntax="operator/(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="__TU"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator*(Float:,Float:)" syntax="operator*(Float:,Float:)(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="RandomFloat"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator==(Float:,Float:)" syntax="operator==(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator==(Float:,_:)" syntax="operator==(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;(Float:,Float:)" syntax="operator&gt;(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;(Float:,_:)" syntax="operator&gt;(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;(_:,Float:)" syntax="operator&gt;(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;=(Float:,Float:)" syntax="operator&gt;=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&gt;=(Float:,_:)" syntax="operator&gt;=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&gt;=(_:,Float:)" syntax="operator&gt;=(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;(Float:,Float:)" syntax="operator&lt;(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="RandomFloat"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;(Float:,_:)" syntax="operator&lt;(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&lt;(_:,Float:)" syntax="operator&lt;(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;=(Float:,Float:)" syntax="operator&lt;=(Float:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:operator&lt;=(Float:,_:)" syntax="operator&lt;=(Float:,_:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="oper2">
			</param>
		</member>
		<member name="M:operator&lt;=(_:,Float:)" syntax="operator&lt;=(_:,Float:)(oper1, oper2)">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<dependency name="float"/>
			<dependency name="floatcmp"/>
			<param name="oper1">
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:_:operator=(__CompilerDefault:)" syntax="_:operator=(__CompilerDefault:)(a)">
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:bool:operator=(__CompilerDefault:)" syntax="bool:operator=(__CompilerDefault:)(a)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Float:operator=(__CompilerDefault:)" syntax="Float:operator=(__CompilerDefault:)(a)">
			<tagname value="Float"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:File:operator=(__CompilerDefault:)" syntax="File:operator=(__CompilerDefault:)(a)">
			<tagname value="File"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:DB:operator=(__CompilerDefault:)" syntax="DB:operator=(__CompilerDefault:)(a)">
			<tagname value="DB"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:DBResult:operator=(__CompilerDefault:)" syntax="DBResult:operator=(__CompilerDefault:)(a)">
			<tagname value="DBResult"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Text:operator=(__CompilerDefault:)" syntax="Text:operator=(__CompilerDefault:)(a)">
			<tagname value="Text"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:PlayerText:operator=(__CompilerDefault:)" syntax="PlayerText:operator=(__CompilerDefault:)(a)">
			<tagname value="PlayerText"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Menu:operator=(__CompilerDefault:)" syntax="Menu:operator=(__CompilerDefault:)(a)">
			<tagname value="Menu"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Text3D:operator=(__CompilerDefault:)" syntax="Text3D:operator=(__CompilerDefault:)(a)">
			<tagname value="Text3D"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:PlayerText3D:operator=(__CompilerDefault:)" syntax="PlayerText3D:operator=(__CompilerDefault:)(a)">
			<tagname value="PlayerText3D"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:filemode:operator=(__CompilerDefault:)" syntax="filemode:operator=(__CompilerDefault:)(a)">
			<tagname value="filemode"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:seek_whence:operator=(__CompilerDefault:)" syntax="seek_whence:operator=(__CompilerDefault:)(a)">
			<tagname value="seek_whence"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Language:operator=(__CompilerDefault:)" syntax="Language:operator=(__CompilerDefault:)(a)">
			<tagname value="Language"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Bit:operator=(__CompilerDefault:)" syntax="Bit:operator=(__CompilerDefault:)(a)">
			<tagname value="Bit"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Style:operator=(__CompilerDefault:)" syntax="Style:operator=(__CompilerDefault:)(a)">
			<tagname value="Style"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:XML:operator=(__CompilerDefault:)" syntax="XML:operator=(__CompilerDefault:)(a)">
			<tagname value="XML"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Bintree:operator=(__CompilerDefault:)" syntax="Bintree:operator=(__CompilerDefault:)(a)">
			<tagname value="Bintree"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Group:operator=(__CompilerDefault:)" syntax="Group:operator=(__CompilerDefault:)(a)">
			<tagname value="Group"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Timer:operator=(__CompilerDefault:)" syntax="Timer:operator=(__CompilerDefault:)(a)">
			<tagname value="Timer"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:INI:operator=(__CompilerDefault:)" syntax="INI:operator=(__CompilerDefault:)(a)">
			<tagname value="INI"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:ConstString:operator=(__CompilerDefault:)" syntax="ConstString:operator=(__CompilerDefault:)(a)">
			<tagname value="ConstString"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:String:operator=(__CompilerDefault:)" syntax="String:operator=(__CompilerDefault:)(a)">
			<tagname value="String"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:error_level:operator=(__CompilerDefault:)" syntax="error_level:operator=(__CompilerDefault:)(a)">
			<tagname value="error_level"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:locale_category:operator=(__CompilerDefault:)" syntax="locale_category:operator=(__CompilerDefault:)(a)">
			<tagname value="locale_category"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:filter_type:operator=(__CompilerDefault:)" syntax="filter_type:operator=(__CompilerDefault:)(a)">
			<tagname value="filter_type"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:handler_flags:operator=(__CompilerDefault:)" syntax="handler_flags:operator=(__CompilerDefault:)(a)">
			<tagname value="handler_flags"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Variant:operator=(__CompilerDefault:)" syntax="Variant:operator=(__CompilerDefault:)(a)">
			<tagname value="Variant"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:ConstVariant:operator=(__CompilerDefault:)" syntax="ConstVariant:operator=(__CompilerDefault:)(a)">
			<tagname value="ConstVariant"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Iter:operator=(__CompilerDefault:)" syntax="Iter:operator=(__CompilerDefault:)(a)">
			<tagname value="Iter"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Handle:operator=(__CompilerDefault:)" syntax="Handle:operator=(__CompilerDefault:)(a)">
			<tagname value="Handle"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:tag_uid:operator=(__CompilerDefault:)" syntax="tag_uid:operator=(__CompilerDefault:)(a)">
			<tagname value="tag_uid"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Task:operator=(__CompilerDefault:)" syntax="Task:operator=(__CompilerDefault:)(a)">
			<tagname value="Task"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:LinkedList:operator=(__CompilerDefault:)" syntax="LinkedList:operator=(__CompilerDefault:)(a)">
			<tagname value="LinkedList"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:List:operator=(__CompilerDefault:)" syntax="List:operator=(__CompilerDefault:)(a)">
			<tagname value="List"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Map:operator=(__CompilerDefault:)" syntax="Map:operator=(__CompilerDefault:)(a)">
			<tagname value="Map"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:tag_op:operator=(__CompilerDefault:)" syntax="tag_op:operator=(__CompilerDefault:)(a)">
			<tagname value="tag_op"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:fork_level:operator=(__CompilerDefault:)" syntax="fork_level:operator=(__CompilerDefault:)(a)">
			<tagname value="fork_level"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Amx:operator=(__CompilerDefault:)" syntax="Amx:operator=(__CompilerDefault:)(a)">
			<tagname value="Amx"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Var:operator=(__CompilerDefault:)" syntax="Var:operator=(__CompilerDefault:)(a)">
			<tagname value="Var"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:amx_err:operator=(__CompilerDefault:)" syntax="amx_err:operator=(__CompilerDefault:)(a)">
			<tagname value="amx_err"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:str_create_mode:operator=(__CompilerDefault:)" syntax="str_create_mode:operator=(__CompilerDefault:)(a)">
			<tagname value="str_create_mode"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:AmxString:operator=(__CompilerDefault:)" syntax="AmxString:operator=(__CompilerDefault:)(a)">
			<tagname value="AmxString"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:ConstAmxString:operator=(__CompilerDefault:)" syntax="ConstAmxString:operator=(__CompilerDefault:)(a)">
			<tagname value="ConstAmxString"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:AmxStringBuffer:operator=(__CompilerDefault:)" syntax="AmxStringBuffer:operator=(__CompilerDefault:)(a)">
			<tagname value="AmxStringBuffer"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:AmxVariant:operator=(__CompilerDefault:)" syntax="AmxVariant:operator=(__CompilerDefault:)(a)">
			<tagname value="AmxVariant"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:ConstAmxVariant:operator=(__CompilerDefault:)" syntax="ConstAmxVariant:operator=(__CompilerDefault:)(a)">
			<tagname value="ConstAmxVariant"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:AmxVariantBuffer:operator=(__CompilerDefault:)" syntax="AmxVariantBuffer:operator=(__CompilerDefault:)(a)">
			<tagname value="AmxVariantBuffer"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Guard:operator=(__CompilerDefault:)" syntax="Guard:operator=(__CompilerDefault:)(a)">
			<tagname value="Guard"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:DynamicObject:operator=(__CompilerDefault:)" syntax="DynamicObject:operator=(__CompilerDefault:)(a)">
			<tagname value="DynamicObject"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:DynamicPickup:operator=(__CompilerDefault:)" syntax="DynamicPickup:operator=(__CompilerDefault:)(a)">
			<tagname value="DynamicPickup"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:DynamicCP:operator=(__CompilerDefault:)" syntax="DynamicCP:operator=(__CompilerDefault:)(a)">
			<tagname value="DynamicCP"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:DynamicRaceCP:operator=(__CompilerDefault:)" syntax="DynamicRaceCP:operator=(__CompilerDefault:)(a)">
			<tagname value="DynamicRaceCP"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:DynamicMapIcon:operator=(__CompilerDefault:)" syntax="DynamicMapIcon:operator=(__CompilerDefault:)(a)">
			<tagname value="DynamicMapIcon"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:DynamicText3D:operator=(__CompilerDefault:)" syntax="DynamicText3D:operator=(__CompilerDefault:)(a)">
			<tagname value="DynamicText3D"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:DynamicArea:operator=(__CompilerDefault:)" syntax="DynamicArea:operator=(__CompilerDefault:)(a)">
			<tagname value="DynamicArea"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:DynamicActor:operator=(__CompilerDefault:)" syntax="DynamicActor:operator=(__CompilerDefault:)(a)">
			<tagname value="DynamicActor"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:E_REGEX_GRAMMAR:operator=(__CompilerDefault:)" syntax="E_REGEX_GRAMMAR:operator=(__CompilerDefault:)(a)">
			<tagname value="E_REGEX_GRAMMAR"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:E_REGEX_FLAG:operator=(__CompilerDefault:)" syntax="E_REGEX_FLAG:operator=(__CompilerDefault:)(a)">
			<tagname value="E_REGEX_FLAG"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:E_MATCH_FLAG:operator=(__CompilerDefault:)" syntax="E_MATCH_FLAG:operator=(__CompilerDefault:)(a)">
			<tagname value="E_MATCH_FLAG"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Regex:operator=(__CompilerDefault:)" syntax="Regex:operator=(__CompilerDefault:)(a)">
			<tagname value="Regex"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:regex:operator=(__CompilerDefault:)" syntax="regex:operator=(__CompilerDefault:)(a)">
			<tagname value="regex"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:RegexMatch:operator=(__CompilerDefault:)" syntax="RegexMatch:operator=(__CompilerDefault:)(a)">
			<tagname value="RegexMatch"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:match_results:operator=(__CompilerDefault:)" syntax="match_results:operator=(__CompilerDefault:)(a)">
			<tagname value="match_results"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:PR_HandlerType:operator=(__CompilerDefault:)" syntax="PR_HandlerType:operator=(__CompilerDefault:)(a)">
			<tagname value="PR_HandlerType"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:PR_ValueType:operator=(__CompilerDefault:)" syntax="PR_ValueType:operator=(__CompilerDefault:)(a)">
			<tagname value="PR_ValueType"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:PR_PacketPriority:operator=(__CompilerDefault:)" syntax="PR_PacketPriority:operator=(__CompilerDefault:)(a)">
			<tagname value="PR_PacketPriority"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:PR_PacketReliability:operator=(__CompilerDefault:)" syntax="PR_PacketReliability:operator=(__CompilerDefault:)(a)">
			<tagname value="PR_PacketReliability"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:BitStream:operator=(__CompilerDefault:)" syntax="BitStream:operator=(__CompilerDefault:)(a)">
			<tagname value="BitStream"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:Opcode:operator=(__CompilerDefault:)" syntax="Opcode:operator=(__CompilerDefault:)(a)">
			<tagname value="Opcode"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:AsmError:operator=(__CompilerDefault:)" syntax="AsmError:operator=(__CompilerDefault:)(a)">
			<tagname value="AsmError"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:DisasmResult:operator=(__CompilerDefault:)" syntax="DisasmResult:operator=(__CompilerDefault:)(a)">
			<tagname value="DisasmResult"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:E_SORT_ORDER:operator=(__CompilerDefault:)" syntax="E_SORT_ORDER:operator=(__CompilerDefault:)(a)">
			<tagname value="E_SORT_ORDER"/>
			<stacksize value="1"/>
			<param name="a">
				<paraminfo>__CompilerDefault </paraminfo>
			</param>
		</member>
		<member name="M:signed:operator=(_:)" syntax="signed:operator=(_:)(a)">
			<tagname value="signed"/>
			<stacksize value="1"/>
			<param name="a">
			</param>
		</member>
		<member name="M:unsigned:operator=(_:)" syntax="unsigned:operator=(_:)(a)">
			<tagname value="unsigned"/>
			<stacksize value="1"/>
			<param name="a">
			</param>
		</member>
		<member name="M:String:operator=(_:)" syntax="String:operator=(_:)(arg)">
			<tagname value="String"/>
			<stacksize value="1"/>
			<param name="arg">
			</param>
		</member>
		<member name="M:String:operator=(Float:)" syntax="String:operator=(Float:)(arg)">
			<tagname value="String"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:String@Const:operator=(_:)" syntax="String@Const:operator=(_:)(arg)">
			<tagname value="String@Const"/>
			<stacksize value="1"/>
			<param name="arg">
			</param>
		</member>
		<member name="M:String@Const:operator=(Float:)" syntax="String@Const:operator=(Float:)(arg)">
			<tagname value="String@Const"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:AmxString:operator=(_:)" syntax="AmxString:operator=(_:)(arg)">
			<tagname value="AmxString"/>
			<stacksize value="1"/>
			<param name="arg">
			</param>
		</member>
		<member name="M:AmxString:operator=(Float:)" syntax="AmxString:operator=(Float:)(arg)">
			<tagname value="AmxString"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:ConstAmxString:operator=(_:)" syntax="ConstAmxString:operator=(_:)(arg)">
			<tagname value="ConstAmxString"/>
			<stacksize value="1"/>
			<param name="arg">
			</param>
		</member>
		<member name="M:ConstAmxString:operator=(Float:)" syntax="ConstAmxString:operator=(Float:)(arg)">
			<tagname value="ConstAmxString"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:AmxStringBuffer:operator=(_:)" syntax="AmxStringBuffer:operator=(_:)(arg)">
			<tagname value="AmxStringBuffer"/>
			<stacksize value="1"/>
			<param name="arg">
			</param>
		</member>
		<member name="M:AmxStringBuffer:operator=(Float:)" syntax="AmxStringBuffer:operator=(Float:)(arg)">
			<tagname value="AmxStringBuffer"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:AmxVariant:operator=(_:)" syntax="AmxVariant:operator=(_:)(arg)">
			<tagname value="AmxVariant"/>
			<stacksize value="1"/>
			<param name="arg">
			</param>
		</member>
		<member name="M:AmxVariant:operator=(Float:)" syntax="AmxVariant:operator=(Float:)(arg)">
			<tagname value="AmxVariant"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:ConstAmxVariant:operator=(_:)" syntax="ConstAmxVariant:operator=(_:)(arg)">
			<tagname value="ConstAmxVariant"/>
			<stacksize value="1"/>
			<param name="arg">
			</param>
		</member>
		<member name="M:ConstAmxVariant:operator=(Float:)" syntax="ConstAmxVariant:operator=(Float:)(arg)">
			<tagname value="ConstAmxVariant"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:AmxVariantBuffer:operator=(_:)" syntax="AmxVariantBuffer:operator=(_:)(arg)">
			<tagname value="AmxVariantBuffer"/>
			<stacksize value="1"/>
			<param name="arg">
			</param>
		</member>
		<member name="M:AmxVariantBuffer:operator=(Float:)" syntax="AmxVariantBuffer:operator=(Float:)(arg)">
			<tagname value="AmxVariantBuffer"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:String:operator=(AmxString:)" syntax="String:operator=(AmxString:)(arg)">
			<tagname value="String"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:String@Const:operator=(AmxString:)" syntax="String@Const:operator=(AmxString:)(arg)">
			<tagname value="String@Const"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:String:operator=(ConstAmxString:)" syntax="String:operator=(ConstAmxString:)(arg)">
			<tagname value="String"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:String@Const:operator=(ConstAmxString:)" syntax="String@Const:operator=(ConstAmxString:)(arg)">
			<tagname value="String@Const"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:String:operator=(AmxStringBuffer:)" syntax="String:operator=(AmxStringBuffer:)(arg)">
			<tagname value="String"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:String@Const:operator=(AmxStringBuffer:)" syntax="String@Const:operator=(AmxStringBuffer:)(arg)">
			<tagname value="String@Const"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxStringBuffer </paraminfo>
			</param>
		</member>
		<member name="M:Variant:operator=(AmxVariant:)" syntax="Variant:operator=(AmxVariant:)(arg)">
			<tagname value="Variant"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:Variant@Const:operator=(AmxVariant:)" syntax="Variant@Const:operator=(AmxVariant:)(arg)">
			<tagname value="Variant@Const"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:Variant:operator=(ConstAmxVariant:)" syntax="Variant:operator=(ConstAmxVariant:)(arg)">
			<tagname value="Variant"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:Variant@Const:operator=(ConstAmxVariant:)" syntax="Variant@Const:operator=(ConstAmxVariant:)(arg)">
			<tagname value="Variant@Const"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:Variant:operator=(AmxVariantBuffer:)" syntax="Variant:operator=(AmxVariantBuffer:)(arg)">
			<tagname value="Variant"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:Variant@Const:operator=(AmxVariantBuffer:)" syntax="Variant@Const:operator=(AmxVariantBuffer:)(arg)">
			<tagname value="Variant@Const"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxVariantBuffer </paraminfo>
			</param>
		</member>
		<member name="M:String@Const:operator=(String:)" syntax="String@Const:operator=(String:)(arg)">
			<tagname value="String@Const"/>
			<stacksize value="1"/>
			<referrer name="Account_RegisterHandler"/>
			<referrer name="Account_EmailDialogHandler"/>
			<referrer name="Account_LoginDialog"/>
			<param name="arg">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:String:operator=(String@Const:)" syntax="String:operator=(String@Const:)(arg)">
			<tagname value="String"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:AmxString:operator=(String:)" syntax="AmxString:operator=(String:)(arg)">
			<tagname value="AmxString"/>
			<attribute name="native"/>
			<referrer name="account_CheckIfExists"/>
			<referrer name="registerPlayer"/>
			<param name="arg">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:ConstAmxString:operator=(AmxString:)" syntax="ConstAmxString:operator=(AmxString:)(arg)">
			<tagname value="ConstAmxString"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxString </paraminfo>
			</param>
		</member>
		<member name="M:AmxString:operator=(String@Const:)" syntax="AmxString:operator=(String@Const:)(arg)">
			<tagname value="AmxString"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:AmxString:operator=(ConstAmxString:)" syntax="AmxString:operator=(ConstAmxString:)(arg)">
			<tagname value="AmxString"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>ConstAmxString </paraminfo>
			</param>
		</member>
		<member name="M:ConstAmxVariant:operator=(AmxVariant:)" syntax="ConstAmxVariant:operator=(AmxVariant:)(arg)">
			<tagname value="ConstAmxVariant"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>AmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:AmxVariant:operator=(Variant@Const:)" syntax="AmxVariant:operator=(Variant@Const:)(arg)">
			<tagname value="AmxVariant"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>Variant@Const </paraminfo>
			</param>
		</member>
		<member name="M:AmxVariant:operator=(ConstAmxVariant:)" syntax="AmxVariant:operator=(ConstAmxVariant:)(arg)">
			<tagname value="AmxVariant"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>ConstAmxVariant </paraminfo>
			</param>
		</member>
		<member name="M:operator==(String:,String:)" syntax="operator==(String:,String:)(arg1, arg2)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="operator!=(String:,String:)"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator==(String:,String@Const:)" syntax="operator==(String:,String@Const:)(arg1, arg2)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="operator!=(String:,String@Const:)"/>
			<param name="arg1">
				<paraminfo>String </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator==(String@Const:,String:)" syntax="operator==(String@Const:,String:)(arg1, arg2)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="operator!=(String@Const:,String:)"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:operator==(String@Const:,String@Const:)" syntax="operator==(String@Const:,String@Const:)(arg1, arg2)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="operator!=(String@Const:,String@Const:)"/>
			<param name="arg1">
				<paraminfo>String@Const </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>String@Const </paraminfo>
			</param>
		</member>
		<member name="M:Variant@Const:operator=(Variant:)" syntax="Variant@Const:operator=(Variant:)(arg)">
			<tagname value="Variant@Const"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>Variant </paraminfo>
			</param>
		</member>
		<member name="M:Variant:operator=(Variant@Const:)" syntax="Variant:operator=(Variant@Const:)(arg)">
			<tagname value="Variant"/>
			<stacksize value="1"/>
			<param name="arg">
				<paraminfo>Variant@Const </paraminfo>
			</param>
		</member>
		<member name="M:operator==(Iter:,Iter:)" syntax="operator==(Iter:,Iter:)(arg1, arg2)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="operator!=(Iter:,Iter:)"/>
			<param name="arg1">
				<paraminfo>Iter </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Iter </paraminfo>
			</param>
		</member>
		<member name="M:operator==(Handle:,Handle:)" syntax="operator==(Handle:,Handle:)(arg1, arg2)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="operator!=(Handle:,Handle:)"/>
			<referrer name="__ppAsyncMySQLError"/>
			<param name="arg1">
				<paraminfo>Handle </paraminfo>
			</param>
			<param name="arg2">
				<paraminfo>Handle </paraminfo>
			</param>
		</member>
		<member name="M:Expression:operator=(_:)" syntax="Expression:operator=(_:)(arg)">
			<tagname value="Expression"/>
			<stacksize value="4"/>
			<dependency name="expr_const"/>
			<param name="arg">
			</param>
		</member>
		<member name="M:Expression:operator=(Float:)" syntax="Expression:operator=(Float:)(arg)">
			<tagname value="Expression"/>
			<stacksize value="4"/>
			<dependency name="expr_const"/>
			<param name="arg">
				<paraminfo>Float </paraminfo>
			</param>
		</member>
		<member name="M:Expression:operator=(bool:)" syntax="Expression:operator=(bool:)(arg)">
			<tagname value="Expression"/>
			<stacksize value="4"/>
			<dependency name="expr_const"/>
			<param name="arg">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:@@_SetColourHash" syntax="@@_SetColourHash(hash, color, __m)">
			<tagname value="I@R"/>
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="@_"/>
			<dependency name="L@"/>
			<dependency name="_SetColourHash"/>
			<param name="hash">
			</param>
			<param name="color">
			</param>
			<param name="__m">
			</param>
		</member>
		<member name="M:@@_SetColoursCanHaveSpaces" syntax="@@_SetColoursCanHaveSpaces(set, __m)">
			<tagname value="I@R"/>
			<attribute name="public"/>
			<stacksize value="4"/>
			<dependency name="@_"/>
			<dependency name="L@"/>
			<dependency name="_SetColoursCanHaveSpaces"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="__m">
			</param>
		</member>
		<member name="M:@CO_CGen" syntax="@CO_CGen()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="@CO_Debug"/>
		</member>
		<member name="M:@CO_Debug" syntax="@CO_Debug()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<referrer name="@CO_CGen"/>
			<dependency name="@CO_YVers"/>
		</member>
		<member name="M:@CO_ScriptInit" syntax="@CO_ScriptInit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<referrer name="@CO_YVers"/>
		</member>
		<member name="M:@CO_YVers" syntax="@CO_YVers()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<referrer name="@CO_Debug"/>
			<dependency name="@CO_ScriptInit"/>
		</member>
		<member name="M:@_yHCheckpoint" syntax="@_yHCheckpoint()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHCommand" syntax="@_yHCommand()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHContainer" syntax="@_yHContainer()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHDynamic" syntax="@_yHDynamic()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHDynamicCP" syntax="@_yHDynamicCP()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHInventory" syntax="@_yHInventory()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHObject" syntax="@_yHObject()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHTextDraw" syntax="@_yHTextDraw()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@_yHUpdate" syntax="@_yHUpdate()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="_Hooks_AddReplacement"/>
		</member>
		<member name="M:@receivepacket" syntax="@receivepacket(packet[], size, source[])">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="packet">
				<paraminfo> [] </paraminfo>
				Contains the packet that was received.
			</param>
			<param name="size">
				Contains the number of <b>bytes</b> (not cells) that are in the packet
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
				Contains the IP address and the port number of the sender of this packet.
			</param>
			<summary>A packed was received.</summary>    <seealso name="@receivestring"/> <seealso name="sendpacket"/> <remarks>You must call this function before receiving the first packet. In other words, you should set up a port in main.</remarks> <remarks>If no port number has been explicitily chosen, the module will listen at port <c><b>9930</b></c>.</remarks> <remarks>This function does not work in the current SA:MP version!</remarks> <returns>The return value of this function is currently ignored.</returns>
		</member>
		<member name="M:@receivestring" syntax="@receivestring(message[], source[])">
			<attribute name="public"/>
			<stacksize value="1"/>
			<param name="message">
				<paraminfo> [] </paraminfo>
				Contains the message (a zero-terminated string) that was received.
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
				Contains the IP address and the port number of the sender of this packet.
			</param>
			<summary>A packed was received.</summary>   <seealso name="@receivepacket"/> <seealso name="sendstring"/> <remarks>The string is in unpacked format if the original packet contained a string in UTF-8 format. Note that messages in the ASCII character set are also UTF-8 compliant.</remarks> <remarks>This function does not work in the current SA:MP version!</remarks> <returns>The return value of this function is currently ignored.</returns>
		</member>
		<member name="M:@yH_OnGameModeExit@001" syntax="@yH_OnGameModeExit@001()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="closeSql"/>
		</member>
		<member name="M:@yH_OnGameModeInit@000" syntax="@yH_OnGameModeInit@000()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="Database_Connect"/>
		</member>
		<member name="M:@yH_OnPlayerConnect@002" syntax="@yH_OnPlayerConnect@002(playerid)">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="account_CheckIfExists"/>
			<dependency name="auth_RaceCheck"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:@yH_OnPlayerDisconnect@002" syntax="@yH_OnPlayerDisconnect@002(playerid, reason)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<dependency name="auth_RaceCheck"/>
			<param name="playerid">
			</param>
			<param name="reason">
			</param>
		</member>
		<member name="M:@yH_OnPlayerDisconnect@003" syntax="@yH_OnPlayerDisconnect@003(playerid, reason)">
			<attribute name="public"/>
			<stacksize value="4"/>
			<dependency name="Account_ResetInfo"/>
			<param name="playerid">
			</param>
			<param name="reason">
			</param>
		</member>
		<member name="M:@y_HOnPlayerCommandText" syntax="@y_HOnPlayerCommandText()">
			<attribute name="public"/>
			<stacksize value="1"/>
		</member>
		<member name="M:@y_HOnRconCommand" syntax="@y_HOnRconCommand()">
			<attribute name="public"/>
			<stacksize value="1"/>
		</member>
		<member name="M:AK_Kick" syntax="AK_Kick(playerid)">
			<stacksize value="3"/>
			<referrer name="KickEx"/>
			<referrer name="account_CheckIfExists"/>
			<dependency name="GetPlayerPing"/>
			<dependency name="Kick"/>
			<dependency name="wait_ms"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:AMX_DoNothing" syntax="AMX_DoNothing()">
			<stacksize value="1"/>
			<referrer name="AMX_GetGlobal"/>
		</member>
		<member name="M:AMX_DumpHeader" syntax="AMX_DumpHeader()">
			<stacksize value="41"/>
			<dependency name="AMX_GetName"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="printf"/>
			<dependency name="strunpack"/>
		</member>
		<member name="M:AMX_GetBaseCount" syntax="AMX_GetBaseCount(table, &amp;base, &amp;count)">
			<stacksize value="1"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetEntryPrefix"/>
			<referrer name="AMX_GetEntrySuffix"/>
			<referrer name="AMX_GetName"/>
			<referrer name="AMX_GetNamePrefix"/>
			<referrer name="AMX_GetNameSuffix"/>
			<dependency name="AMX_HEADER_LIBRARIES"/>
			<dependency name="AMX_HEADER_NAMETABLE"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_HEADER_PUBVARS"/>
			<dependency name="AMX_HEADER_TAGS"/>
			<dependency name="AMX_TABLE_LIBRARIES"/>
			<dependency name="AMX_TABLE_NATIVES"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="AMX_TABLE_PUBVARS"/>
			<dependency name="AMX_TABLE_TAGS"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="base">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetEntry" syntax="AMX_GetEntry(table, idx, &amp;buffer, pattern[], exact)">
			<stacksize value="42"/>
			<referrer name="AMX_GetPointer"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="Hooks_GetFunctionWritePoint"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetEntryFromNativeIndex" syntax="AMX_GetEntryFromNativeIndex(index)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<param name="index">
			</param>
		</member>
		<member name="M:AMX_GetEntryFromPublicIndex" syntax="AMX_GetEntryFromPublicIndex(index)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<param name="index">
			</param>
		</member>
		<member name="M:AMX_GetEntryPointer" syntax="AMX_GetEntryPointer(entry)">
			<stacksize value="1"/>
			<dependency name="__COMPILER_DEFAULT"/>
			<param name="entry">
			</param>
		</member>
		<member name="M:AMX_GetEntryPrefix" syntax="AMX_GetEntryPrefix(table, idx, &amp;buffer, pattern)">
			<stacksize value="9"/>
			<referrer name="AMX_GetPointerPrefix"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_CountInvalidPublics"/>
			<referrer name="CGen_OnCodeInit"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetEntrySuffix" syntax="AMX_GetEntrySuffix(table, idx, &amp;buffer, pattern)">
			<stacksize value="10"/>
			<referrer name="AMX_GetPointerSuffix"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetGlobal" syntax="AMX_GetGlobal()">
			<stacksize value="4"/>
			<referrer name="Debug_OnCodeInit"/>
			<dependency name="AMX_DoNothing"/>
			<dependency name="AMX_HEADER_COD"/>
		</member>
		<member name="M:AMX_GetGlobalAddress" syntax="AMX_GetGlobalAddress(...)">
			<stacksize value="2"/>
			<dependency name="AMX_REAL_DATA"/>
			<param name="...">
			</param>
		</member>
		<member name="M:AMX_GetName" syntax="AMX_GetName(table, idx, buffer[], pattern[], exact)">
			<stacksize value="10"/>
			<referrer name="AMX_DumpHeader"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetNamePrefix" syntax="AMX_GetNamePrefix(table, idx, buffer[], pattern)">
			<stacksize value="9"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetNameSuffix" syntax="AMX_GetNameSuffix(table, idx, buffer[], pattern)">
			<stacksize value="10"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetBaseCount"/>
			<dependency name="AMX_ReadString"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetNativeIndexFromEntry" syntax="AMX_GetNativeIndexFromEntry(entry)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<param name="entry">
			</param>
		</member>
		<member name="M:AMX_GetPointer" syntax="AMX_GetPointer(table, idx, &amp;buffer, pattern[], exact)">
			<stacksize value="9"/>
			<referrer name="AMX_GetValue"/>
			<dependency name="AMX_GetEntry"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetPointerPrefix" syntax="AMX_GetPointerPrefix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<referrer name="AMX_GetValuePrefix"/>
			<referrer name="ScriptInit_PreInitFuncs_"/>
			<referrer name="ScriptInit_PostInitFuncs_"/>
			<referrer name="ScriptInit_PreExitFuncs_"/>
			<referrer name="ScriptInit_PostExitFuncs_"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetPointerSuffix" syntax="AMX_GetPointerSuffix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<referrer name="AMX_GetValueSuffix"/>
			<dependency name="AMX_GetEntrySuffix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetPublicIndexFromEntry" syntax="AMX_GetPublicIndexFromEntry(entry)">
			<stacksize value="1"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<param name="entry">
			</param>
		</member>
		<member name="M:AMX_GetRelativeAddress" syntax="AMX_GetRelativeAddress(...)">
			<stacksize value="2"/>
			<param name="...">
			</param>
		</member>
		<member name="M:AMX_GetStringFromEntry" syntax="AMX_GetStringFromEntry(entry, str[], size)">
			<stacksize value="6"/>
			<referrer name="Hooks_GetAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_ReadString"/>
			<param name="entry">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AMX_GetValue" syntax="AMX_GetValue(table, idx, &amp;buffer, pattern[], exact)">
			<stacksize value="9"/>
			<dependency name="AMX_GetPointer"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="exact">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AMX_GetValuePrefix" syntax="AMX_GetValuePrefix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_GetValueSuffix" syntax="AMX_GetValueSuffix(table, idx, &amp;buffer, pattern)">
			<stacksize value="8"/>
			<dependency name="AMX_GetPointerSuffix"/>
			<param name="table">
				<paraminfo>E_AMX_TABLE </paraminfo>
			</param>
			<param name="idx">
			</param>
			<param name="buffer">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="pattern">
			</param>
		</member>
		<member name="M:AMX_OnCodeInit" syntax="AMX_OnCodeInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="AddressofResolve"/>
			<dependency name="Indirect_Init"/>
		</member>
		<member name="M:AMX_RawRead" syntax="AMX_RawRead(addr)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:AMX_RawWrite" syntax="AMX_RawWrite(addr, value)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AMX_Read" syntax="AMX_Read(addr)">
			<stacksize value="1"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_InvalidateName"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_CompareNextCell"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="CGen_OnCodeInit"/>
			<referrer name="_Hooks_RepairStub"/>
			<referrer name="Hooks_RepairJITInit"/>
			<referrer name="OnRuntimeError"/>
			<referrer name="YHNPS_Find"/>
			<referrer name="YHNPS_Insert"/>
			<referrer name="Hooks_OnCodeInit"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:AMX_ReadArray" syntax="AMX_ReadArray(addr, dest[], len)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_ReadString" syntax="AMX_ReadString(addr, str[], len)">
			<stacksize value="5"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetName"/>
			<referrer name="AMX_GetNamePrefix"/>
			<referrer name="AMX_GetNameSuffix"/>
			<referrer name="AMX_GetStringFromEntry"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<dependency name="swapchars"/>
			<param name="addr">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_ReadUnpackedString" syntax="AMX_ReadUnpackedString(addr, str[], len)">
			<stacksize value="2"/>
			<param name="addr">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_TraceCode" syntax="AMX_TraceCode(pattern[], &amp;addrRet, &amp;dataRet, size)">
			<stacksize value="4"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_HEADER_DAT"/>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="addrRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="dataRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AMX_TraceMemory" syntax="AMX_TraceMemory(pattern[], &amp;addrRet, &amp;dataRet, size)">
			<stacksize value="4"/>
			<dependency name="AMX_HEADER_DAT"/>
			<dependency name="AMX_HEADER_HEA"/>
			<param name="pattern">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="addrRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="dataRet">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AMX_Write" syntax="AMX_Write(addr, value)">
			<stacksize value="1"/>
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="ThirdParty_OnCodeInit"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_InvalidateName"/>
			<referrer name="Hooks_ComparePublics"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="_Hooks_RepairStub"/>
			<referrer name="Hooks_RepairJITInit"/>
			<referrer name="YHNPS_Insert"/>
			<referrer name="Hooks_OnCodeInit"/>
			<param name="addr">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AMX_WriteArray" syntax="AMX_WriteArray(addr, src[], len)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AMX_WriteString" syntax="AMX_WriteString(addr, str[], len)">
			<stacksize value="4"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<param name="addr">
			</param>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
		</member>
		<member name="M:AbsToRel" syntax="AbsToRel(address)">
			<stacksize value="3"/>
			<referrer name="ReadPhysMemory"/>
			<referrer name="WritePhysMemory"/>
			<referrer name="ReadPhysMemoryCell"/>
			<referrer name="WritePhysMemoryCell"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetDat"/>
			<param name="address">
			</param>
		</member>
		<member name="M:Account_EmailDialogHandler" syntax="Account_EmailDialogHandler(playerid)">
			<stacksize value="165"/>
			<referrer name="Account_EmailDialogHandler"/>
			<referrer name="OnPasswordHashed"/>
			<dependency name="String@Const:operator=(String:)"/>
			<dependency name="Account_SetEmail"/>
			<dependency name="E_DIALOG_RESPONSE_InputText"/>
			<dependency name="E_DIALOG_RESPONSE_Response"/>
			<dependency name="KickEx"/>
			<dependency name="Misc_ReturnName"/>
			<dependency name="Misc_ReturnName"/>
			<dependency name="ShowPlayerAsyncDialogStr"/>
			<dependency name="e_DIALOG_RESPONSE_INFO"/>
			<dependency name="false"/>
			<dependency name="registerPlayer"/>
			<dependency name="str_format"/>
			<dependency name="str_new"/>
			<dependency name="strlen"/>
			<dependency name="task_await_arr"/>
			<dependency name="task_yield"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Account_LoginDialog" syntax="Account_LoginDialog(playerid)">
			<stacksize value="68"/>
			<referrer name="Account_LoginDialog"/>
			<referrer name="OnPlayerAccountChecked"/>
			<referrer name="OnPasswordChecked"/>
			<dependency name="String@Const:operator=(String:)"/>
			<dependency name="Account_ReturnPassword"/>
			<dependency name="Account_ReturnPassword"/>
			<dependency name="E_DIALOG_RESPONSE_InputText"/>
			<dependency name="E_DIALOG_RESPONSE_Response"/>
			<dependency name="KickEx"/>
			<dependency name="Misc_ReturnName"/>
			<dependency name="Misc_ReturnName"/>
			<dependency name="ShowPlayerAsyncDialogStr"/>
			<dependency name="TogglePlayerSpectating"/>
			<dependency name="bcrypt_check"/>
			<dependency name="e_DIALOG_RESPONSE_INFO"/>
			<dependency name="false"/>
			<dependency name="str_format"/>
			<dependency name="str_new"/>
			<dependency name="task_await_arr"/>
			<dependency name="true"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Account_RegisterHandler" syntax="Account_RegisterHandler(playerid)">
			<stacksize value="165"/>
			<referrer name="Account_RegisterHandler"/>
			<referrer name="OnPlayerAccountChecked"/>
			<dependency name="String@Const:operator=(String:)"/>
			<dependency name="E_DIALOG_RESPONSE_InputText"/>
			<dependency name="E_DIALOG_RESPONSE_Response"/>
			<dependency name="KickEx"/>
			<dependency name="Misc_ReturnName"/>
			<dependency name="Misc_ReturnName"/>
			<dependency name="ShowPlayerAsyncDialogStr"/>
			<dependency name="TogglePlayerSpectating"/>
			<dependency name="bcrypt_hash"/>
			<dependency name="e_DIALOG_RESPONSE_INFO"/>
			<dependency name="false"/>
			<dependency name="str_format"/>
			<dependency name="str_new"/>
			<dependency name="strlen"/>
			<dependency name="task_await_arr"/>
			<dependency name="task_yield"/>
			<dependency name="true"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Account_ResetInfo" syntax="Account_ResetInfo(playerid)">
			<stacksize value="1"/>
			<referrer name="@yH_OnPlayerDisconnect@003"/>
			<dependency name="EOS"/>
			<dependency name="account_Email"/>
			<dependency name="account_Email"/>
			<dependency name="account_ID"/>
			<dependency name="account_Name"/>
			<dependency name="account_Name"/>
			<dependency name="account_Password"/>
			<dependency name="account_Password"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Account_ReturnEmail" syntax="Account_ReturnEmail(playerid)">
			<stacksize value="1"/>
			<referrer name="registerPlayer"/>
			<dependency name="Account_ReturnEmail"/>
			<dependency name="account_Email"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Account_ReturnID" syntax="Account_ReturnID(playerid)">
			<stacksize value="1"/>
			<dependency name="account_ID"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Account_ReturnLoginAttempts" syntax="Account_ReturnLoginAttempts(playerid)">
			<stacksize value="1"/>
			<referrer name="OnPasswordChecked"/>
			<dependency name="account_Password_Attempts"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Account_ReturnName" syntax="Account_ReturnName(playerid)">
			<stacksize value="1"/>
			<dependency name="Account_ReturnName"/>
			<dependency name="account_Name"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Account_ReturnPassword" syntax="Account_ReturnPassword(playerid)">
			<stacksize value="1"/>
			<referrer name="registerPlayer"/>
			<referrer name="Account_LoginDialog"/>
			<dependency name="Account_ReturnPassword"/>
			<dependency name="account_Password"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Account_SetEmail" syntax="Account_SetEmail(playerid, email[])">
			<stacksize value="6"/>
			<referrer name="Account_EmailDialogHandler"/>
			<referrer name="OnPlayerAccountChecked"/>
			<dependency name="account_Email"/>
			<dependency name="account_Email"/>
			<dependency name="strcopy"/>
			<param name="playerid">
			</param>
			<param name="email">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Account_SetID" syntax="Account_SetID(playerid, id)">
			<stacksize value="1"/>
			<referrer name="OnPlayerRegister"/>
			<dependency name="account_ID"/>
			<param name="playerid">
			</param>
			<param name="id">
			</param>
		</member>
		<member name="M:Account_SetLoginAttempts" syntax="Account_SetLoginAttempts(playerid, amount)">
			<stacksize value="1"/>
			<referrer name="OnPasswordChecked"/>
			<dependency name="account_Password_Attempts"/>
			<param name="playerid">
			</param>
			<param name="amount">
			</param>
		</member>
		<member name="M:Account_SetName" syntax="Account_SetName(playerid, name[])">
			<stacksize value="6"/>
			<dependency name="account_Name"/>
			<dependency name="account_Name"/>
			<dependency name="strcopy"/>
			<param name="playerid">
			</param>
			<param name="name">
				<paraminfo> [24] </paraminfo>
			</param>
		</member>
		<member name="M:Account_SetPassword" syntax="Account_SetPassword(playerid, pass[])">
			<stacksize value="6"/>
			<referrer name="OnPlayerAccountChecked"/>
			<referrer name="OnPasswordHashed"/>
			<referrer name="OnPasswordChecked"/>
			<dependency name="account_Password"/>
			<dependency name="account_Password"/>
			<dependency name="strcopy"/>
			<param name="playerid">
			</param>
			<param name="pass">
				<paraminfo> [61] </paraminfo>
			</param>
		</member>
		<member name="M:AddressofResolve" syntax="AddressofResolve()">
			<stacksize value="753"/>
			<referrer name="Indirect_Init"/>
			<referrer name="AMX_OnCodeInit"/>
			<dependency name="AddressofResolveFoundEnd"/>
			<dependency name="AddressofResolveFoundStart"/>
			<dependency name="CodeScanAddMatcher"/>
			<dependency name="CodeScanInit"/>
			<dependency name="CodeScanMatcher"/>
			<dependency name="CodeScanMatcherInit_"/>
			<dependency name="CodeScanMatcherPattern_"/>
			<dependency name="CodeScanRunFast"/>
			<dependency name="CodeScanner"/>
			<dependency name="GetAmxJITBaseAddress"/>
			<dependency name="O@A_"/>
			<dependency name="O@V_"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CONST_PRI"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_JUMP"/>
			<dependency name="OP_JZER"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="false"/>
			<dependency name="gCodeScanCallback_match"/>
			<dependency name="ref"/>
			<dependency name="true"/>
		</member>
		<member name="M:AddressofResolveFoundEnd" syntax="AddressofResolveFoundEnd(scanner[])">
			<stacksize value="27"/>
			<referrer name="AddressofResolve"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitConstPri"/>
			<dependency name="CodeScanGetMatchAsm"/>
			<dependency name="CodeScanGetMatchHole"/>
			<dependency name="CodeScanGetMatchLength"/>
			<dependency name="cellbits"/>
			<param name="scanner">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:AddressofResolveFoundStart" syntax="AddressofResolveFoundStart(scanner[])">
			<stacksize value="44"/>
			<referrer name="AddressofResolve"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitJump"/>
			<dependency name="CodeScanGetMatchAsm"/>
			<dependency name="CodeScanGetMatchHole"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<param name="scanner">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:AdvancedKick" syntax="AdvancedKick(playerid, kickerid, reason[], time)">
			<stacksize value="13"/>
			<dependency name="CallLocalFunction"/>
			<dependency name="IsPlayerConnected"/>
			<dependency name="KICK_KICKEROFFLINE"/>
			<dependency name="KICK_SUCCESS"/>
			<dependency name="KICK_TARGETOFFLINE"/>
			<dependency name="Kick"/>
			<dependency name="KickEx"/>
			<dependency name="true"/>
			<dependency name="wait_ms"/>
			<param name="playerid">
			</param>
			<param name="kickerid">
			</param>
			<param name="reason">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
		</member>
		<member name="M:AsmClearError" syntax="AsmClearError(ctx[])">
			<stacksize value="5"/>
			<referrer name="CGen_OOM"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmSetError"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitAdd" syntax="AsmEmitAdd(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADD"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitAddC" syntax="AsmEmitAddC(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADD_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitAddrAlt" syntax="AsmEmitAddrAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADDR_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitAddrPri" syntax="AsmEmitAddrPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ADDR_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitAlignAlt" syntax="AsmEmitAlignAlt(ctx[], number)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ALIGN_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="number">
			</param>
		</member>
		<member name="M:AsmEmitAlignPri" syntax="AsmEmitAlignPri(ctx[], number)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ALIGN_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="number">
			</param>
		</member>
		<member name="M:AsmEmitAnd" syntax="AsmEmitAnd(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_AND"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitBounds" syntax="AsmEmitBounds(ctx[], bound)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_BOUNDS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="bound">
			</param>
		</member>
		<member name="M:AsmEmitBreak" syntax="AsmEmitBreak(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_BREAK"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitCall" syntax="AsmEmitCall(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CALL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitCallAbs" syntax="AsmEmitCallAbs(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="24"/>
			<referrer name="_yH@"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="OP_CALL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitCallLabelStringize" syntax="AsmEmitCallLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_CALL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitCell" syntax="AsmEmitCell(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AsmEmitJumpStringize"/>
			<referrer name="AsmEmitOpcode"/>
			<referrer name="AsmEmitOperand"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="ASM_ERROR_SPACE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<dependency name="AsmRaiseError"/>
			<dependency name="WriteAmxMemory"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitCmps" syntax="AsmEmitCmps(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CMPS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitConstAlt" syntax="AsmEmitConstAlt(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CONST_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitConstPri" syntax="AsmEmitConstPri(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AddressofResolveFoundEnd"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_CONST_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitDec" syntax="AsmEmitDec(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitDecAlt" syntax="AsmEmitDecAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitDecI" syntax="AsmEmitDecI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitDecPri" syntax="AsmEmitDecPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitDecS" syntax="AsmEmitDecS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_DEC_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitEq" syntax="AsmEmitEq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_EQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitEqCAlt" syntax="AsmEmitEqCAlt(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_EQ_C_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitEqCPri" syntax="AsmEmitEqCPri(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_EQ_C_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitFill" syntax="AsmEmitFill(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_FILL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitGeq" syntax="AsmEmitGeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_GEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitGrtr" syntax="AsmEmitGrtr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_GRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitHalt" syntax="AsmEmitHalt(ctx[], code)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_HALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="code">
			</param>
		</member>
		<member name="M:AsmEmitHeap" syntax="AsmEmitHeap(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="_yH@"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_HEAP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitIdxaddr" syntax="AsmEmitIdxaddr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_IDXADDR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIdxaddrB" syntax="AsmEmitIdxaddrB(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_IDXADDR_B"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitInc" syntax="AsmEmitInc(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitIncAlt" syntax="AsmEmitIncAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIncI" syntax="AsmEmitIncI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIncPri" syntax="AsmEmitIncPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitIncS" syntax="AsmEmitIncS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INC_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitInstruction" syntax="AsmEmitInstruction(ctx[], opcode, ...)">
			<tagname value="AsmError"/>
			<stacksize value="8"/>
			<referrer name="AsmEmitJumpInstruction"/>
			<referrer name="AsmEmitAdd"/>
			<referrer name="AsmEmitAddC"/>
			<referrer name="AsmEmitAddrAlt"/>
			<referrer name="AsmEmitAddrPri"/>
			<referrer name="AsmEmitAlignAlt"/>
			<referrer name="AsmEmitAlignPri"/>
			<referrer name="AsmEmitAnd"/>
			<referrer name="AsmEmitBounds"/>
			<referrer name="AsmEmitBreak"/>
			<referrer name="AsmEmitCall"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="AsmEmitCmps"/>
			<referrer name="AsmEmitConstAlt"/>
			<referrer name="AsmEmitConstPri"/>
			<referrer name="AsmEmitDec"/>
			<referrer name="AsmEmitDecAlt"/>
			<referrer name="AsmEmitDecI"/>
			<referrer name="AsmEmitDecPri"/>
			<referrer name="AsmEmitDecS"/>
			<referrer name="AsmEmitEq"/>
			<referrer name="AsmEmitEqCAlt"/>
			<referrer name="AsmEmitEqCPri"/>
			<referrer name="AsmEmitFill"/>
			<referrer name="AsmEmitGeq"/>
			<referrer name="AsmEmitGrtr"/>
			<referrer name="AsmEmitHalt"/>
			<referrer name="AsmEmitHeap"/>
			<referrer name="AsmEmitIdxaddr"/>
			<referrer name="AsmEmitIdxaddrB"/>
			<referrer name="AsmEmitInc"/>
			<referrer name="AsmEmitIncAlt"/>
			<referrer name="AsmEmitIncI"/>
			<referrer name="AsmEmitIncPri"/>
			<referrer name="AsmEmitIncS"/>
			<referrer name="AsmEmitInvert"/>
			<referrer name="AsmEmitJeq"/>
			<referrer name="AsmEmitJgeq"/>
			<referrer name="AsmEmitJgrtr"/>
			<referrer name="AsmEmitJleq"/>
			<referrer name="AsmEmitJless"/>
			<referrer name="AsmEmitJneq"/>
			<referrer name="AsmEmitJnz"/>
			<referrer name="AsmEmitJsgeq"/>
			<referrer name="AsmEmitJsgrtr"/>
			<referrer name="AsmEmitJsleq"/>
			<referrer name="AsmEmitJsless"/>
			<referrer name="AsmEmitJump"/>
			<referrer name="AsmEmitJzer"/>
			<referrer name="AsmEmitLctrl"/>
			<referrer name="AsmEmitLeq"/>
			<referrer name="AsmEmitLess"/>
			<referrer name="AsmEmitLidx"/>
			<referrer name="AsmEmitLidxB"/>
			<referrer name="AsmEmitLoadAlt"/>
			<referrer name="AsmEmitLoadPri"/>
			<referrer name="AsmEmitLoad"/>
			<referrer name="AsmEmitLoadI"/>
			<referrer name="AsmEmitLoadSAlt"/>
			<referrer name="AsmEmitLoadSPri"/>
			<referrer name="AsmEmitLodbI"/>
			<referrer name="AsmEmitLrefAlt"/>
			<referrer name="AsmEmitLrefPri"/>
			<referrer name="AsmEmitLrefSAlt"/>
			<referrer name="AsmEmitLrefSPri"/>
			<referrer name="AsmEmitMoveAlt"/>
			<referrer name="AsmEmitMovePri"/>
			<referrer name="AsmEmitMovs"/>
			<referrer name="AsmEmitNeg"/>
			<referrer name="AsmEmitNeq"/>
			<referrer name="AsmEmitNop"/>
			<referrer name="AsmEmitNot"/>
			<referrer name="AsmEmitOr"/>
			<referrer name="AsmEmitPopAlt"/>
			<referrer name="AsmEmitPopPri"/>
			<referrer name="AsmEmitProc"/>
			<referrer name="AsmEmitPushAdr"/>
			<referrer name="AsmEmitPushAlt"/>
			<referrer name="AsmEmitPushC"/>
			<referrer name="AsmEmitPushPri"/>
			<referrer name="AsmEmitPush"/>
			<referrer name="AsmEmitPushS"/>
			<referrer name="AsmEmitRet"/>
			<referrer name="AsmEmitRetn"/>
			<referrer name="AsmEmitSctrl"/>
			<referrer name="AsmEmitSdiv"/>
			<referrer name="AsmEmitSdivAlt"/>
			<referrer name="AsmEmitSgeq"/>
			<referrer name="AsmEmitSgrtr"/>
			<referrer name="AsmEmitShl"/>
			<referrer name="AsmEmitShlCAlt"/>
			<referrer name="AsmEmitShlCPri"/>
			<referrer name="AsmEmitShrCAlt"/>
			<referrer name="AsmEmitShrCPri"/>
			<referrer name="AsmEmitShr"/>
			<referrer name="AsmEmitSignAlt"/>
			<referrer name="AsmEmitSignPri"/>
			<referrer name="AsmEmitSleq"/>
			<referrer name="AsmEmitSless"/>
			<referrer name="AsmEmitSmul"/>
			<referrer name="AsmEmitSmulC"/>
			<referrer name="AsmEmitSshr"/>
			<referrer name="AsmEmitSrefAlt"/>
			<referrer name="AsmEmitSrefPri"/>
			<referrer name="AsmEmitSrefSAlt"/>
			<referrer name="AsmEmitSrefSPri"/>
			<referrer name="AsmEmitStack"/>
			<referrer name="AsmEmitStorAlt"/>
			<referrer name="AsmEmitStorPri"/>
			<referrer name="AsmEmitStorI"/>
			<referrer name="AsmEmitStorSAlt"/>
			<referrer name="AsmEmitStorSPri"/>
			<referrer name="AsmEmitStrbI"/>
			<referrer name="AsmEmitSub"/>
			<referrer name="AsmEmitSubAlt"/>
			<referrer name="AsmEmitSwapAlt"/>
			<referrer name="AsmEmitSwapPri"/>
			<referrer name="AsmEmitSysreqC"/>
			<referrer name="AsmEmitSysreqD"/>
			<referrer name="AsmEmitSysreqPri"/>
			<referrer name="AsmEmitUdiv"/>
			<referrer name="AsmEmitUdivAlt"/>
			<referrer name="AsmEmitUmul"/>
			<referrer name="AsmEmitXchg"/>
			<referrer name="AsmEmitXor"/>
			<referrer name="AsmEmitZero"/>
			<referrer name="AsmEmitZeroAlt"/>
			<referrer name="AsmEmitZeroPri"/>
			<referrer name="AsmEmitZeroS"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitOpcode"/>
			<dependency name="AsmEmitOperand"/>
			<dependency name="gPreviousWriteOffset"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="...">
			</param>
		</member>
		<member name="M:AsmEmitInvert" syntax="AsmEmitInvert(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_INVERT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJeq" syntax="AsmEmitJeq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJeqLabelStringize" syntax="AsmEmitJeqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJeqRel" syntax="AsmEmitJeqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJgeq" syntax="AsmEmitJgeq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJgeqLabelStringize" syntax="AsmEmitJgeqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJgeqRel" syntax="AsmEmitJgeqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJgrtr" syntax="AsmEmitJgrtr(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJgrtrLabelStringize" syntax="AsmEmitJgrtrLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJgrtrRel" syntax="AsmEmitJgrtrRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJleq" syntax="AsmEmitJleq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJleqLabelStringize" syntax="AsmEmitJleqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJleqRel" syntax="AsmEmitJleqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJless" syntax="AsmEmitJless(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJlessLabelStringize" syntax="AsmEmitJlessLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJlessRel" syntax="AsmEmitJlessRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJneq" syntax="AsmEmitJneq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JNEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJneqLabelStringize" syntax="AsmEmitJneqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JNEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJneqRel" syntax="AsmEmitJneqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JNEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJnz" syntax="AsmEmitJnz(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JNZ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJnzLabelStringize" syntax="AsmEmitJnzLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JNZ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJnzRel" syntax="AsmEmitJnzRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JNZ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJrel" syntax="AsmEmitJrel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JREL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJrelLabelStringize" syntax="AsmEmitJrelLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JREL"/>
			<dependency name="true"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsgeq" syntax="AsmEmitJsgeq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJsgeqLabelStringize" syntax="AsmEmitJsgeqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsgeqRel" syntax="AsmEmitJsgeqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJsgrtr" syntax="AsmEmitJsgrtr(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJsgrtrLabelStringize" syntax="AsmEmitJsgrtrLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsgrtrRel" syntax="AsmEmitJsgrtrRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJsleq" syntax="AsmEmitJsleq(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJsleqLabelStringize" syntax="AsmEmitJsleqLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJsleqRel" syntax="AsmEmitJsleqRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJsless" syntax="AsmEmitJsless(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JSLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJslessLabelStringize" syntax="AsmEmitJslessLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JSLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJslessRel" syntax="AsmEmitJslessRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JSLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJump" syntax="AsmEmitJump(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AddressofResolveFoundStart"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JUMP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJumpInstruction" syntax="AsmEmitJumpInstruction(ctx[], opcode, offset)">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="AsmEmitJeqRel"/>
			<referrer name="AsmEmitJgeqRel"/>
			<referrer name="AsmEmitJgrtrRel"/>
			<referrer name="AsmEmitJleqRel"/>
			<referrer name="AsmEmitJlessRel"/>
			<referrer name="AsmEmitJneqRel"/>
			<referrer name="AsmEmitJnzRel"/>
			<referrer name="AsmEmitJsgeqRel"/>
			<referrer name="AsmEmitJsgrtrRel"/>
			<referrer name="AsmEmitJsleqRel"/>
			<referrer name="AsmEmitJslessRel"/>
			<referrer name="AsmEmitJumpRel"/>
			<referrer name="AsmEmitJzerRel"/>
			<referrer name="AsmEmitJrel"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="AsmGetJumpAddressFromOffset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJumpLabelInstruction" syntax="AsmEmitJumpLabelInstruction(ctx[], opcode, label[], relative)">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="AsmEmitCallLabelStringize"/>
			<referrer name="AsmEmitJeqLabelStringize"/>
			<referrer name="AsmEmitJgeqLabelStringize"/>
			<referrer name="AsmEmitJgrtrLabelStringize"/>
			<referrer name="AsmEmitJleqLabelStringize"/>
			<referrer name="AsmEmitJlessLabelStringize"/>
			<referrer name="AsmEmitJneqLabelStringize"/>
			<referrer name="AsmEmitJnzLabelStringize"/>
			<referrer name="AsmEmitJsgeqLabelStringize"/>
			<referrer name="AsmEmitJsgrtrLabelStringize"/>
			<referrer name="AsmEmitJsleqLabelStringize"/>
			<referrer name="AsmEmitJslessLabelStringize"/>
			<referrer name="AsmEmitJumpLabelStringize"/>
			<referrer name="AsmEmitJzerLabelStringize"/>
			<referrer name="AsmEmitJrelLabelStringize"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitJumpStringize"/>
			<dependency name="AsmEmitOpcode"/>
			<dependency name="gPreviousWriteOffset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="relative">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJumpLabelStringize" syntax="AsmEmitJumpLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JUMP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJumpRel" syntax="AsmEmitJumpRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JUMP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitJumpStringize" syntax="AsmEmitJumpStringize(ctx[], label[], relative)">
			<tagname value="AsmError"/>
			<stacksize value="10"/>
			<referrer name="AsmEmitJumpLabelInstruction"/>
			<dependency name="ASM_ERROR_LABEL_OVERFLOW"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_label_names"/>
			<dependency name="AsmContext_labels"/>
			<dependency name="AsmEmitCell"/>
			<dependency name="AsmFindLabelIndex"/>
			<dependency name="AsmHashLabel"/>
			<dependency name="AsmRaiseError"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="relative">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJzer" syntax="AsmEmitJzer(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_JZER"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitJzerLabelStringize" syntax="AsmEmitJzerLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="7"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitJumpLabelInstruction"/>
			<dependency name="OP_JZER"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitJzerRel" syntax="AsmEmitJzerRel(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitJumpInstruction"/>
			<dependency name="OP_JZER"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLabelStringize" syntax="AsmEmitLabelStringize(ctx[], label[])">
			<tagname value="AsmError"/>
			<stacksize value="11"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="ASM_ERROR_LABEL_DUPLICATE"/>
			<dependency name="ASM_ERROR_LABEL_OVERFLOW"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_label_names"/>
			<dependency name="AsmContext_labels"/>
			<dependency name="AsmFindLabelIndex"/>
			<dependency name="AsmGetJumpAddressFromOffset"/>
			<dependency name="AsmHashLabel"/>
			<dependency name="AsmRaiseError"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="WriteAmxMemory"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLctrl" syntax="AsmEmitLctrl(ctx[], index)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LCTRL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:AsmEmitLeq" syntax="AsmEmitLeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLess" syntax="AsmEmitLess(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLidx" syntax="AsmEmitLidx(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LIDX"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLidxB" syntax="AsmEmitLidxB(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LIDX_B"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitLoad" syntax="AsmEmitLoad(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLoadAlt" syntax="AsmEmitLoadAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLoadI" syntax="AsmEmitLoadI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitLoadPri" syntax="AsmEmitLoadPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLoadSAlt" syntax="AsmEmitLoadSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLoadSPri" syntax="AsmEmitLoadSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LOAD_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLodbI" syntax="AsmEmitLodbI(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LODB_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitLrefAlt" syntax="AsmEmitLrefAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLrefPri" syntax="AsmEmitLrefPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitLrefSAlt" syntax="AsmEmitLrefSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitLrefSPri" syntax="AsmEmitLrefSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_LREF_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitMoveAlt" syntax="AsmEmitMoveAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_MOVE_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitMovePri" syntax="AsmEmitMovePri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_MOVE_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitMovs" syntax="AsmEmitMovs(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_MOVS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitNeg" syntax="AsmEmitNeg(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NEG"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitNeq" syntax="AsmEmitNeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitNop" syntax="AsmEmitNop(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NOP"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitNot" syntax="AsmEmitNot(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_NOT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitOpcode" syntax="AsmEmitOpcode(ctx[], opcode)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AsmEmitInstruction"/>
			<referrer name="AsmEmitJumpLabelInstruction"/>
			<dependency name="ASM_ERROR_OPCODE"/>
			<dependency name="AsmEmitCell"/>
			<dependency name="AsmRaiseError"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="RelocateOpcode"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitOperand" syntax="AsmEmitOperand(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="AsmEmitInstruction"/>
			<dependency name="AsmEmitCell"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitOr" syntax="AsmEmitOr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_OR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPadding" syntax="AsmEmitPadding(ctx[], op)">
			<stacksize value="7"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<dependency name="GetOpcodeInstructionParameters"/>
			<dependency name="IsOpcodeValid"/>
			<dependency name="OP_NOP"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="WriteAmxMemory"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="op">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPopAlt" syntax="AsmEmitPopAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_POP_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPopArgs" syntax="AsmEmitPopArgs(ctx[], n)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitStack"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmEmitPopPri" syntax="AsmEmitPopPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_POP_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitProc" syntax="AsmEmitProc(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PROC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPush" syntax="AsmEmitPush(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitPushAdr" syntax="AsmEmitPushAdr(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_ADR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitPushAlt" syntax="AsmEmitPushAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPushArg" syntax="AsmEmitPushArg(ctx[], n)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitPushS"/>
			<dependency name="AsmGetArgOffset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmEmitPushC" syntax="AsmEmitPushC(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitPushNumArgs"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitPushNumArgs" syntax="AsmEmitPushNumArgs(ctx[], n)">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitPushC"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmEmitPushPri" syntax="AsmEmitPushPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitPushS" syntax="AsmEmitPushS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitPushArg"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_PUSH_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitRet" syntax="AsmEmitRet(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_RET"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitRetn" syntax="AsmEmitRetn(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_RETN"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSctrl" syntax="AsmEmitSctrl(ctx[], index)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SCTRL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:AsmEmitSdiv" syntax="AsmEmitSdiv(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SDIV"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSdivAlt" syntax="AsmEmitSdivAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SDIV_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSgeq" syntax="AsmEmitSgeq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SGEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSgrtr" syntax="AsmEmitSgrtr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SGRTR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitShl" syntax="AsmEmitShl(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitShlCAlt" syntax="AsmEmitShlCAlt(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHL_C_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitShlCPri" syntax="AsmEmitShlCPri(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHL_C_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitShr" syntax="AsmEmitShr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitShrCAlt" syntax="AsmEmitShrCAlt(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHR_C_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitShrCPri" syntax="AsmEmitShrCPri(ctx[], shift)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SHR_C_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="shift">
			</param>
		</member>
		<member name="M:AsmEmitSignAlt" syntax="AsmEmitSignAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SIGN_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSignPri" syntax="AsmEmitSignPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SIGN_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSleq" syntax="AsmEmitSleq(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SLEQ"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSless" syntax="AsmEmitSless(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SLESS"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSmul" syntax="AsmEmitSmul(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SMUL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSmulC" syntax="AsmEmitSmulC(ctx[], value)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SMUL_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:AsmEmitSrefAlt" syntax="AsmEmitSrefAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitSrefPri" syntax="AsmEmitSrefPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitSrefSAlt" syntax="AsmEmitSrefSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitSrefSPri" syntax="AsmEmitSrefSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SREF_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitSshr" syntax="AsmEmitSshr(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SSHR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitStack" syntax="AsmEmitStack(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitPopArgs"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STACK"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitStorAlt" syntax="AsmEmitStorAlt(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitStorI" syntax="AsmEmitStorI(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitStorPri" syntax="AsmEmitStorPri(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitStorSAlt" syntax="AsmEmitStorSAlt(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_S_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitStorSPri" syntax="AsmEmitStorSPri(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STOR_S_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmEmitStrbI" syntax="AsmEmitStrbI(ctx[], nbytes)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_STRB_I"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:AsmEmitSub" syntax="AsmEmitSub(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SUB"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSubAlt" syntax="AsmEmitSubAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SUB_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSwapAlt" syntax="AsmEmitSwapAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SWAP_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSwapPri" syntax="AsmEmitSwapPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SWAP_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSysreq" syntax="AsmEmitSysreq(ctx[], name[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitSysreqC"/>
			<dependency name="GetNativeIndexFromName"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitSysreqC" syntax="AsmEmitSysreqC(ctx[], index)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitSysreq"/>
			<referrer name="_yH@"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SYSREQ_C"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:AsmEmitSysreqD" syntax="AsmEmitSysreqD(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SYSREQ_D"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitSysreqPri" syntax="AsmEmitSysreqPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_SYSREQ_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitUdiv" syntax="AsmEmitUdiv(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_UDIV"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitUdivAlt" syntax="AsmEmitUdivAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_UDIV_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitUmul" syntax="AsmEmitUmul(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_UMUL"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitXchg" syntax="AsmEmitXchg(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_XCHG"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitXor" syntax="AsmEmitXor(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_XOR"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitZero" syntax="AsmEmitZero(ctx[], address)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:AsmEmitZeroAlt" syntax="AsmEmitZeroAlt(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO_ALT"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitZeroPri" syntax="AsmEmitZeroPri(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="5"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO_PRI"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmEmitZeroS" syntax="AsmEmitZeroS(ctx[], offset)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmEmitInstruction"/>
			<dependency name="OP_ZERO_S"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmFindLabelIndex" syntax="AsmFindLabelIndex(ctx[], hash)">
			<stacksize value="2"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpStringize"/>
			<dependency name="AsmContext_label_names"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="hash">
			</param>
		</member>
		<member name="M:AsmGetArgOffset" syntax="AsmGetArgOffset(n)">
			<stacksize value="1"/>
			<referrer name="AsmEmitPushArg"/>
			<dependency name="ASM_ARGUMENTS_OFFSET"/>
			<param name="n">
			</param>
		</member>
		<member name="M:AsmGetBufferSize" syntax="AsmGetBufferSize(ctx[])">
			<stacksize value="1"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetCode" syntax="AsmGetCode(ctx[])">
			<stacksize value="21"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="GetAmxHeader"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetCodeSize" syntax="AsmGetCodeSize(ctx[])">
			<stacksize value="1"/>
			<dependency name="AsmContext_buffer_offset"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetError" syntax="AsmGetError(ctx[])">
			<tagname value="AsmError"/>
			<stacksize value="1"/>
			<referrer name="CGen_OOM"/>
			<dependency name="AsmContext_error"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetErrorHandler" syntax="AsmGetErrorHandler(ctx[])">
			<stacksize value="1"/>
			<dependency name="AsmContext_error_handler"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:AsmGetJumpAddressFromOffset" syntax="AsmGetJumpAddressFromOffset(ctx[], offset)">
			<stacksize value="22"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpInstruction"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:AsmGetPreviousWriteOffset" syntax="AsmGetPreviousWriteOffset()">
			<stacksize value="1"/>
			<dependency name="gPreviousWriteOffset"/>
		</member>
		<member name="M:AsmHashLabel" syntax="AsmHashLabel(label[])">
			<stacksize value="4"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpStringize"/>
			<param name="label">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsmInit" syntax="AsmInit(ctx[], buffer[], size)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="ref"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="buffer">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AsmInitPtr" syntax="AsmInitPtr(ctx[], buffer, size)">
			<tagname value="AsmError"/>
			<stacksize value="2"/>
			<referrer name="AsmInit"/>
			<referrer name="CodeScanGetFunctionAsm"/>
			<referrer name="CodeScanGetMatchAsm"/>
			<referrer name="CGen_UseCodeSpace"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_buffer"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmContext_buffer_size"/>
			<dependency name="AsmContext_error_handler"/>
			<dependency name="AsmContext_label_names"/>
			<dependency name="AsmContext_labels"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="buffer">
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:AsmRaiseError" syntax="AsmRaiseError(ctx[], error)">
			<tagname value="AsmError"/>
			<stacksize value="6"/>
			<referrer name="AsmEmitCell"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitJumpStringize"/>
			<referrer name="AsmEmitOpcode"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_error_handler"/>
			<dependency name="AsmSetError"/>
			<dependency name="CallFunction"/>
			<dependency name="ref"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error">
				<paraminfo>AsmError </paraminfo>
			</param>
		</member>
		<member name="M:AsmSetError" syntax="AsmSetError(ctx[], error)">
			<stacksize value="1"/>
			<referrer name="AsmRaiseError"/>
			<referrer name="AsmClearError"/>
			<dependency name="AsmContext_error"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error">
				<paraminfo>AsmError </paraminfo>
			</param>
		</member>
		<member name="M:AsmSetErrorHandler" syntax="AsmSetErrorHandler(ctx[], error_handler)">
			<tagname value="AsmError"/>
			<stacksize value="1"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_error_handler"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error_handler">
			</param>
		</member>
		<member name="M:AsmSetErrorHandlerName" syntax="AsmSetErrorHandlerName(ctx[], error_handler[])">
			<tagname value="AsmError"/>
			<stacksize value="4"/>
			<referrer name="CGen_UseCodeSpace"/>
			<dependency name="ASM_ERROR_NONE"/>
			<dependency name="AsmContext_error_handler"/>
			<dependency name="GetPublicAddressFromName"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="error_handler">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AsyncDialogsHandler" syntax="AsyncDialogsHandler(playerid, dialogid, response, listitem, inputtext[])">
			<attribute name="public"/>
			<stacksize value="138"/>
			<dependency name="E_DIALOG_RESPONSE_InputText"/>
			<dependency name="E_DIALOG_RESPONSE_Listitem"/>
			<dependency name="E_DIALOG_RESPONSE_Response"/>
			<dependency name="PAWN_PLUS_DIALOG_ID"/>
			<dependency name="PlayerDialogTasks"/>
			<dependency name="e_DIALOG_RESPONSE_INFO"/>
			<dependency name="strcat"/>
			<dependency name="task_set_result_arr"/>
			<param name="playerid">
			</param>
			<param name="dialogid">
			</param>
			<param name="response">
			</param>
			<param name="listitem">
			</param>
			<param name="inputtext">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AwaitAsyncDialog" syntax="AwaitAsyncDialog(playerid, dialog_response[], style, caption[], info[], button1[], button2[])">
			<stacksize value="12"/>
			<dependency name="PAWN_PLUS_DIALOG_ID"/>
			<dependency name="PlayerDialogTasks"/>
			<dependency name="pawn_call_native"/>
			<dependency name="task_await"/>
			<dependency name="task_delete"/>
			<dependency name="task_get_result_arr"/>
			<dependency name="task_new"/>
			<param name="playerid">
			</param>
			<param name="dialog_response">
				<paraminfo> [131] </paraminfo>
			</param>
			<param name="style">
			</param>
			<param name="caption">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="info">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="button1">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="button2">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:AwaitAsyncDialogStr" syntax="AwaitAsyncDialogStr(playerid, dialog_response[], style, caption, info, button1, button2)">
			<stacksize value="12"/>
			<dependency name="PAWN_PLUS_DIALOG_ID"/>
			<dependency name="PlayerDialogTasks"/>
			<dependency name="pawn_call_native"/>
			<dependency name="task_await"/>
			<dependency name="task_delete"/>
			<dependency name="task_get_result_arr"/>
			<dependency name="task_new"/>
			<param name="playerid">
			</param>
			<param name="dialog_response">
				<paraminfo> [131] </paraminfo>
			</param>
			<param name="style">
			</param>
			<param name="caption">
				<paraminfo> {String@Const,String} </paraminfo>
			</param>
			<param name="info">
				<paraminfo> {String@Const,String} </paraminfo>
			</param>
			<param name="button1">
				<paraminfo> {String@Const,String} </paraminfo>
			</param>
			<param name="button2">
				<paraminfo> {String@Const,String} </paraminfo>
			</param>
		</member>
		<member name="M:Base64Decode" syntax="Base64Decode(dest[], src[], len, offset)">
			<stacksize value="4"/>
			<dependency name="cellbits"/>
			<dependency name="min"/>
			<dependency name="strlen"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="len">
			</param>
			<param name="offset">
			</param>
			<summary>  Base64Decode  </summary>  <remarks>  Decodes data using proper base64.  </remarks> 
		</member>
		<member name="M:Base64Encode" syntax="Base64Encode(dest[], src[], num, len, offset)">
			<stacksize value="5"/>
			<dependency name="__COMPILER_DEFAULT"/>
			<dependency name="__MACRO__ceildiv"/>
			<dependency name="cellbits"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="num">
			</param>
			<param name="len">
			</param>
			<param name="offset">
			</param>
			<summary>  Base64Encode  </summary>  <remarks>  Encodes data using proper base64.  This code is complicated by the fact that  PAWN packed strings are backwards by cells in memory, so we need to do the  writes in what seems like a strange order.  </remarks> 
		</member>
		<member name="M:CGEN" syntax="CGEN(&amp;a, &amp;b, &amp;c, &amp;d, &amp;e, &amp;f, &amp;g, &amp;h, &amp;i, &amp;j, &amp;k, &amp;l, &amp;m, &amp;n, &amp;o, &amp;p, &amp;q, &amp;r, &amp;s, &amp;t, &amp;u, &amp;v, &amp;w, &amp;x, &amp;y, &amp;z)">
			<stacksize value="1"/>
			<referrer name="_@_y_cgen_@_0"/>
			<param name="a">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="b">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="c">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="d">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="e">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="f">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="g">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="h">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="i">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="j">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="k">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="l">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="m">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="n">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="o">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="p">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="q">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="r">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="s">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="t">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="u">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="v">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="w">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="x">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="y">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="z">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CGen_AddCodeSpace" syntax="CGen_AddCodeSpace(num)">
			<stacksize value="4"/>
			<referrer name="Hooks_GenerateCode"/>
			<dependency name="Debug_Print0"/>
			<dependency name="YSI_g_sCodeSpace"/>
			<param name="num">
			</param>
		</member>
		<member name="M:CGen_GetAddr" syntax="CGen_GetAddr(func[])">
			<stacksize value="4"/>
			<referrer name="CGen_SetupCodeSpace"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="funcidx"/>
			<param name="func">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CGen_GetCodeSpace" syntax="CGen_GetCodeSpace()">
			<stacksize value="1"/>
			<referrer name="Hooks_GenerateCode"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="YSI_g_sCodeSpace"/>
		</member>
		<member name="M:CGen_OOM" syntax="CGen_OOM(ctx[])">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="ASM_ERROR_LABEL_DUPLICATE"/>
			<dependency name="ASM_ERROR_LABEL_OVERFLOW"/>
			<dependency name="ASM_ERROR_OPCODE"/>
			<dependency name="ASM_ERROR_OPERAND"/>
			<dependency name="ASM_ERROR_SPACE"/>
			<dependency name="AsmClearError"/>
			<dependency name="AsmGetError"/>
			<dependency name="Debug_Print0"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:CGen_OnCodeInit" syntax="CGen_OnCodeInit()">
			<attribute name="public"/>
			<stacksize value="9"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="CallFunction"/>
			<dependency name="Hooks_DoAllHooks"/>
			<dependency name="Hooks_InvalidateName"/>
			<dependency name="Hooks_RepairJITInit"/>
			<dependency name="Hooks_SortPublics"/>
			<dependency name="Hooks_SortReplacements"/>
			<dependency name="Server_JITExists"/>
			<dependency name="YSI_g_sInitFSIdx"/>
			<dependency name="YSI_g_sInitGMIdx"/>
			<dependency name="funcidx"/>
			<remarks>  Call the main hook run code, then advance the ALS chain.  </remarks>  <transition keep="true" target="_ALS : _ALS_go"/>  <transition target="_ALS_go"/>

		</member>
		<member name="M:CGen_SetupCodeSpace" syntax="CGen_SetupCodeSpace()">
			<stacksize value="5"/>
			<referrer name="ThirdParty_OnCodeInit"/>
			<dependency name="AMX_Write"/>
			<dependency name="CGen_GetAddr"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_RETN"/>
			<dependency name="OP_ZERO_PRI"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="YSI_g_sCodeEnd"/>
			<dependency name="YSI_g_sCodeSpace"/>
		</member>
		<member name="M:CGen_UseCodeSpace" syntax="CGen_UseCodeSpace(ctx[])">
			<stacksize value="6"/>
			<referrer name="Hooks_WriteFunction"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="AsmSetErrorHandlerName"/>
			<dependency name="YSI_g_sCodeEnd"/>
			<dependency name="YSI_g_sCodeSpace"/>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
		</member>
		<member name="M:Call" syntax="Call(address, auto_pop)">
			<stacksize value="5"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:CallFunction" syntax="CallFunction(address, ...)">
			<stacksize value="5"/>
			<referrer name="AsmRaiseError"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="CGen_OnCodeInit"/>
			<param name="address">
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallLocalFunction" syntax="CallLocalFunction(function[], format[], ...)">
			<attribute name="native"/>
			<referrer name="KickEx"/>
			<referrer name="AdvancedKick"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
				Public function's name
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
				Tag/format of each variable
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
				'Indefinite' number of arguments of any tag
			</param>
			<summary>Calls a public function from the script in which it is used.</summary>    <seealso name="CallRemoteFunction"/> <returns>The value that the <b>only</b> public function returned.</returns> <remarks>CallLocalFunction crashes the server if it's passing an empty string.</remarks> <remarks> Format string placeholders:<p/> <ul> <li><b><c>c</c></b> - a single character</li> <li><b><c>d</c></b> - an integer (whole) number</li> <li><b><c>i</c></b> - an integer (whole) number</li> <li><b><c>x</c></b> - a number in hexadecimal notation</li> <li><b><c>f</c></b> - a floating point number</li> <li><b><c>s</c></b> - a string</li> </ul> </remarks>
		</member>
		<member name="M:CallN" syntax="CallN(address, args_to_push, auto_pop)">
			<stacksize value="6"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="args_to_push">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:CallNative" syntax="CallNative(index, ...)">
			<stacksize value="8"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<param name="index">
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CallNativeByAddress" syntax="CallNativeByAddress(address, ...)">
			<stacksize value="8"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<param name="address">
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:Cell_CompressRight" syntax="Cell_CompressRight(x, m)">
			<stacksize value="12"/>
			<dependency name="Cell_CompressRightPrecomputed"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<param name="x">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
				The number to compress.
			</param>
			<param name="m">
				The mask for which bits to compress.
			</param>
			<summary>  Cell_CompressRight(GLOBAL_TAG_TYPES:x, m);  </summary>      <returns>  Selected bits from "x", shifted to be LSBs.  </returns>  <remarks>  Doesn't require precomputation.  </remarks> 
		</member>
		<member name="M:Cell_CompressRightPrecomputed" syntax="Cell_CompressRightPrecomputed(x, m, masks[])">
			<stacksize value="2"/>
			<referrer name="Cell_CompressRight"/>
			<param name="x">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
				The number to compress.
			</param>
			<param name="m">
				The mask for which bits to compress.
			</param>
			<param name="masks">
				<paraminfo> [5] </paraminfo>
				Precomputed constants for the compression.
			</param>
			<summary>  Cell_CompressRightPrecomputed(GLOBAL_TAG_TYPES:x, m, masks[5]);  </summary>        <returns>  Selected bits from "x", shifted to be LSBs.  </returns>  <remarks>  Very briefly, do "x &amp; m", to select certain bits, then shift those bits  by various amounts so that they are consecutive:  x = 0b110011  m = 0b011010  x &amp; m = 0b010010  From here, because the mask was three bits we know we want just those three  bits in the LSBs, so the answer becomes:  0b000101  Just read this question, it has a diagram:  <a href="http://stackoverflow.com/questions/28282869/shift-masked-bits-to-the-lsb" />  </remarks> 
		</member>
		<member name="M:Cell_CountBits" syntax="Cell_CountBits(data)">
			<stacksize value="1"/>
			<dependency name="__COMPILER_DEFAULT"/>
			<param name="data">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_CountBits(number);  </summary>  <param name="number">The number to get the number of 1s in.</param>  <returns>  The number of 1s (set bits) in the input.  </returns>  <remarks>  1)  Example: 0  Returns: 0  2)  Example: 1  Returns: 1  3)  Example: 0x01010101  Returns: 4  I rewrote this in assembly just to see if I could pretty much.  I also  rewrote the lookup version in assembly.  In theory it should be faster, but  the marshalling of data was a little awkward.  </remarks> 
		</member>
		<member name="M:Cell_CountBlanks" syntax="Cell_CountBlanks(data)">
			<stacksize value="1"/>
			<dependency name="__COMPILER_DEFAULT"/>
			<param name="data">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_CountBlanks(number);  </summary>  <param name="number">The number to get the number of 0s in.</param>  <returns>  The number of 0s (unset bits) in the input.  </returns>  <remarks>  Like Cell_CountBits, but for 0s not 1s.  </remarks> 
		</member>
		<member name="M:Cell_ExpandLeft" syntax="Cell_ExpandLeft(x, m)">
			<stacksize value="12"/>
			<dependency name="Cell_ExpandLeftPrecomputed"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<param name="x">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
				The number to expand.
			</param>
			<param name="m">
				The mask for which bits to expand to.
			</param>
			<summary>  Cell_ExpandLeft(GLOBAL_TAG_TYPES:x, m)  </summary>      <returns>  LSBs from "x", shifted to selected bit positions.  </returns>  <remarks>  Doesn't require precomputation.  </remarks> 
		</member>
		<member name="M:Cell_ExpandLeftPrecomputed" syntax="Cell_ExpandLeftPrecomputed(x, m, masks[])">
			<stacksize value="2"/>
			<referrer name="Cell_ExpandLeft"/>
			<param name="x">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
				The number to expand.
			</param>
			<param name="m">
				The mask for which bits to expand to.
			</param>
			<param name="masks">
				<paraminfo> [5] </paraminfo>
				Precomputed constants for the expansion.
			</param>
			<summary>  Cell_ExpandLeftPrecomputed(GLOBAL_TAG_TYPES:x, m, masks[5])  </summary>        <returns>  LSBs from "x", shifted to selected bit positions.  </returns>  <remarks>  The reverse of "Cell_CompressRightPrecomputed".  Doesn't return exactly the  original number before a compression, just the original number ANDed with  the mask "m".  </remarks> 
		</member>
		<member name="M:Cell_GetLowestBit" syntax="Cell_GetLowestBit(data)">
			<stacksize value="1"/>
			<dependency name="__COMPILER_DEFAULT"/>
			<param name="data">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestBit(number);  </summary>  <param name="number">The number to get the lowest set bit of.</param>  <returns>  The integer position of the lowest set bit.  </returns>  <remarks>  1)  Example: 0b00000000000000000000000000000001  Returns: 0  2)  Example: 0b00000000000000000000000000001000  Returns: 3  3)  Example: 0b00010001100011000011100010001000  Returns: 3  NOTE: This function returns "0" for both numbers with the "1" bit set AND  the number "0", which has NO bits set.  Check that the number is valid  before passing it to this function.  See: <a href="http://supertech.csail.mit.edu/papers/debruijn.pdf" />  </remarks> 
		</member>
		<member name="M:Cell_GetLowestBitEx" syntax="Cell_GetLowestBitEx(data)">
			<stacksize value="1"/>
			<dependency name="__COMPILER_DEFAULT"/>
			<param name="data">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestBitEx(number);  </summary>  <param name="number">The number to get the lowest set bit of PLUS ONE.</param>  <returns>  The integer position of the lowest set bit PLUS ONE.  </returns>  <remarks>  This function is identical to "Cell_GetLowestBit", but gives different  results for 0 and non-zero numbers.  The examples below all have a result  one higher than the "Cell_GetLowestBit" function.  1)  Example: 0b00000000000000000000000000000001  Returns: 1  2)  Example: 0b00000000000000000000000000001000  Returns: 4  3)  Example: 0b00010001100011000011100010001000  Returns: 4  4)  Example: 0  Returns: 0  See: <a href="http://supertech.csail.mit.edu/papers/debruijn.pdf" />  </remarks> 
		</member>
		<member name="M:Cell_GetLowestBlank" syntax="Cell_GetLowestBlank(data)">
			<stacksize value="1"/>
			<dependency name="__COMPILER_DEFAULT"/>
			<param name="data">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestBlank(number);  </summary>  <param name="number">The number to get the lowest unset bit of.</param>  <returns>  The integer position of the lowest unset bit.  </returns>  <remarks>  Like Cell_GetLowestBit, but for 0s not 1s.  </remarks> 
		</member>
		<member name="M:Cell_GetLowestBlankEx" syntax="Cell_GetLowestBlankEx(data)">
			<stacksize value="1"/>
			<dependency name="__COMPILER_DEFAULT"/>
			<param name="data">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestBlankEx(number);  </summary>  <param name="number">The number to get the lowest unset bit of PLUS ONE.</param>  <returns>  The integer position of the lowest unset bit PLUS ONE.  </returns>  <remarks>  Like Cell_GetLowestBitEx, but for 0s not 1s.  </remarks> 
		</member>
		<member name="M:Cell_GetLowestComponent" syntax="Cell_GetLowestComponent(data)">
			<stacksize value="1"/>
			<dependency name="__COMPILER_DEFAULT"/>
			<param name="data">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestComponent(number);  </summary>  <param name="number">The number to get the lowest 1 in.</param>  <returns>  The lowest set bit.  </returns>  <remarks>  Similar to Cell_GetLowestBit, but returns the bit, not the position of the  bit.  1)  Example: 0b00000000000000000000000000000001  Returns: 0b00000000000000000000000000000001  2)  Example: 0b00000000000000000000000000001000  Returns: 0b00000000000000000000000000001000  3)  Example: 0b00010001100011000011100010001000  Returns: 0b00000000000000000000000000001000  4)  Example: 0b00000000000000000000000000000000  Returns: 0b00000000000000000000000000000000  </remarks> 
		</member>
		<member name="M:Cell_GetLowestEmpty" syntax="Cell_GetLowestEmpty(data)">
			<stacksize value="1"/>
			<dependency name="__COMPILER_DEFAULT"/>
			<param name="data">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_GetLowestEmpty(number);  </summary>  <param name="number">The number to get the lowest 0 in.</param>  <returns>  The lowest unset bit.  </returns>  <remarks>  Like Cell_GetLowestComponent, but for 0s not 1s.  </remarks> 
		</member>
		<member name="M:Cell_PrecomputeMaskPermutation" syntax="Cell_PrecomputeMaskPermutation(m)">
			<stacksize value="10"/>
			<referrer name="Cell_CompressRight"/>
			<referrer name="Cell_ExpandLeft"/>
			<dependency name="Cell_PrecomputeMaskPermutation"/>
			<param name="m">
				The mask.
			</param>
			<summary>  Cell_PrecomputeMaskPermutation(m)  </summary>    <returns>  Five precomputed constants to help expand or contract this mask.  </returns>  <remarks>  The full maths for generalised expansion and contraction is quite complex;  however, much of the inner loop relies only on the mask and not on the value  being manipulated.  Given this we can do a lot of work in advance, say  outside a loop, to avoid repeated calculations.  </remarks> 
		</member>
		<member name="M:Cell_ReverseBits" syntax="Cell_ReverseBits(data)">
			<stacksize value="1"/>
			<dependency name="__COMPILER_DEFAULT"/>
			<dependency name="swapchars"/>
			<param name="data">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_ReverseBits(number);  </summary>  <param name="number">The number to manipulate.</param>  <returns>  All the bits in the input reversed.  </returns>  <remarks>  1)  Example: 0b11110000000000000000000000000000  Becomes: 0b00000000000000000000000000001111  2)  Example: 0b10110011100011110000111110000010  Becomes: 0b01000001111100001111000111001101  3)  Example: 0b01010101010101010101010101010101  Becomes: 0b10101010101010101010101010101010  </remarks> 
		</member>
		<member name="M:Cell_ReverseBytes" syntax="Cell_ReverseBytes(data)">
			<stacksize value="3"/>
			<referrer name="Hooks_CompareNextCell"/>
			<dependency name="swapchars"/>
			<param name="data">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_ReverseBytes(number);  </summary>  <param name="number">The number to manipulate.</param>  <returns>  All the bytes in the input reversed.  </returns>  <remarks>  1)  Example: 0x12345678  Becomes: 0x78563412  2)  Example: 0x01020304  Becomes: 0x04030201  3)  Example: 0xFF00FF00  Becomes: 0x00FF00FF  </remarks> 
		</member>
		<member name="M:Cell_ReverseNibbles" syntax="Cell_ReverseNibbles(data)">
			<stacksize value="1"/>
			<dependency name="__COMPILER_DEFAULT"/>
			<dependency name="swapchars"/>
			<param name="data">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
			<summary>  Cell_ReverseNibbles(number);  </summary>  <param name="number">The number to manipulate.</param>  <returns>  All the nibbles (4-bit chunks) in the input reversed.  </returns>  <remarks>  1)  Example: 0x12345678  Becomes: 0x87654321  2)  Example: 0x010F0703  Becomes: 0x3070F010  3)  Example: 0xF0F0F0F0  Becomes: 0x0F0F0F0F  </remarks> 
		</member>
		<member name="M:CodeScanAddJumpTarget" syntax="CodeScanAddJumpTarget(cip, stk, hea, jumpTargets[], num)">
			<stacksize value="4"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_jump_heap"/>
			<dependency name="CodeScanner_jump_stack"/>
			<dependency name="CodeScanner_jump_switch"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<dependency name="min"/>
			<param name="cip">
			</param>
			<param name="stk">
			</param>
			<param name="hea">
			</param>
			<param name="jumpTargets">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanAddMatcher" syntax="CodeScanAddMatcher(scanner[], searcher[])">
			<stacksize value="4"/>
			<referrer name="AddressofResolve"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="ref"/>
			<param name="scanner">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanAddSwitchTarget" syntax="CodeScanAddSwitchTarget(dctx[], stk, hea, jumpTargets[], num)">
			<stacksize value="6"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="CodeScanner_jump_heap"/>
			<dependency name="CodeScanner_jump_stack"/>
			<dependency name="CodeScanner_jump_switch"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="cellbits"/>
			<dependency name="gBase"/>
			<dependency name="gHdr"/>
			<dependency name="gOP_CASETBL"/>
			<dependency name="min"/>
			<param name="dctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="stk">
			</param>
			<param name="hea">
			</param>
			<param name="jumpTargets">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanCall" syntax="CodeScanCall(cs[], csState[])">
			<stacksize value="3"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_func"/>
			<dependency name="CodeScanMatcher_user_data"/>
			<param name="cs">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="csState">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanCheck" syntax="CodeScanCheck(op, dctx[], cs[], fctx[], &amp;next)">
			<tagname value="bool"/>
			<stacksize value="12"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanMatch_hole_count"/>
			<dependency name="CodeScanMatch_holes"/>
			<dependency name="CodeScanMatch_size"/>
			<dependency name="CodeScanMatcher_code"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_holeidx"/>
			<dependency name="CodeScanMatcher_holes"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanMatcher_offset"/>
			<dependency name="CodeScanMatcher_start"/>
			<dependency name="DisasmGetCurIp"/>
			<dependency name="DisasmGetNextIp"/>
			<dependency name="DisasmGetNumOperands"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="OP_BOUNDS"/>
			<dependency name="OP_BREAK"/>
			<dependency name="OP_HALT"/>
			<dependency name="OP_NOP"/>
			<dependency name="cellbits"/>
			<dependency name="false"/>
			<dependency name="memcpy"/>
			<dependency name="true"/>
			<param name="op">
				<paraminfo>Opcode </paraminfo>
			</param>
			<param name="dctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="cs">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="fctx">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanCheckJumpTarget" syntax="CodeScanCheckJumpTarget(cip, deloc, &amp;stk, &amp;hea, jumpTargets[], num)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<referrer name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_jump_heap"/>
			<dependency name="CodeScanner_jump_stack"/>
			<dependency name="CodeScanner_jump_switch"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="cellbits"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="cip">
			</param>
			<param name="deloc">
			</param>
			<param name="stk">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="hea">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="jumpTargets">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanClone" syntax="CodeScanClone(dest[], src[])">
			<stacksize value="1"/>
			<dependency name="CodeScanner_first"/>
			<param name="dest">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="src">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanDeref" syntax="CodeScanDeref(v)">
			<stacksize value="1"/>
			<referrer name="CodeScanFindOneFastPattern2"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanMatcher"/>
			<param name="v">
			</param>
		</member>
		<member name="M:CodeScanFindOneFastPattern2" syntax="CodeScanFindOneFastPattern2(matcher[], &amp;addr)">
			<tagname value="bool"/>
			<stacksize value="180"/>
			<referrer name="CodeScanRunFast"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanFindOneFastPattern3"/>
			<dependency name="CodeScanMatcher_code"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="OP_CALL"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="matcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="addr">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanFindOneFastPattern3" syntax="CodeScanFindOneFastPattern3(matcher[], addr, &amp;cur)">
			<tagname value="bool"/>
			<stacksize value="3"/>
			<referrer name="CodeScanFindOneFastPattern2"/>
			<dependency name="CodeScanMatcher_code"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="OP_CALL"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="matcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="addr">
			</param>
			<param name="cur">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetFuncName" syntax="CodeScanGetFuncName(addr, name[])">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<referrer name="CodeScanGetMatchType"/>
			<dependency name="GetPublicIndexFromAddress"/>
			<dependency name="GetPublicNameFromIndex"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="addr">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetFunctionAsm" syntax="CodeScanGetFunctionAsm(csm[], ctx[], offset)">
			<stacksize value="6"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="cellmax"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetFunctionDisasm" syntax="CodeScanGetFunctionDisasm(csm[], ctx[], offset)">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetFunctionScanner" syntax="CodeScanGetFunctionScanner(csm[], ret[], ctx[])">
			<stacksize value="4"/>
			<referrer name="CodeScanGetMatchScanner"/>
			<dependency name="CodeScanInit"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="CodeScanner_state"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ret">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetHoleCount" syntax="CodeScanGetHoleCount(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_hole_count"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchAddress" syntax="CodeScanGetMatchAddress(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="gDat"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchAddressData" syntax="CodeScanGetMatchAddressData(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_cip"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchAsm" syntax="CodeScanGetMatchAsm(csm[], ctx[], offset)">
			<stacksize value="6"/>
			<referrer name="AddressofResolveFoundStart"/>
			<referrer name="AddressofResolveFoundEnd"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="cellmax"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [21] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetMatchDisasm" syntax="CodeScanGetMatchDisasm(csm[], ctx[], offset)">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:CodeScanGetMatchFunc" syntax="CodeScanGetMatchFunc(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="gDat"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchFuncData" syntax="CodeScanGetMatchFuncData(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_func"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchHeap" syntax="CodeScanGetMatchHeap(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_heap"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchHole" syntax="CodeScanGetMatchHole(csm[], idx)">
			<stacksize value="1"/>
			<referrer name="AddressofResolveFoundStart"/>
			<referrer name="AddressofResolveFoundEnd"/>
			<dependency name="CodeScanMatch_holes"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:CodeScanGetMatchLength" syntax="CodeScanGetMatchLength(csm[])">
			<stacksize value="1"/>
			<referrer name="AddressofResolveFoundEnd"/>
			<dependency name="CodeScanMatch_size"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchName" syntax="CodeScanGetMatchName(csm[], name[])">
			<stacksize value="5"/>
			<dependency name="CodeScanGetMatchType"/>
			<dependency name="CodeScanMatch_name"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="strcat"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchScanner" syntax="CodeScanGetMatchScanner(csm[], ret[], ctx[], accurate)">
			<stacksize value="7"/>
			<dependency name="CodeScanGetFunctionScanner"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_param"/>
			<dependency name="CodeScanner_state"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ret">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="accurate">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchStack" syntax="CodeScanGetMatchStack(csm[])">
			<stacksize value="1"/>
			<dependency name="CodeScanMatch_stack"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanGetMatchType" syntax="CodeScanGetMatchType(csm[])">
			<stacksize value="5"/>
			<referrer name="CodeScanGetMatchName"/>
			<dependency name="CodeScanGetFuncName"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanMatch_name"/>
			<dependency name="CodeScanMatch_type"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanInit" syntax="CodeScanInit(scanner[])">
			<stacksize value="5"/>
			<referrer name="CodeScanGetFunctionScanner"/>
			<referrer name="AddressofResolve"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanMatch_heap"/>
			<dependency name="CodeScanMatch_name"/>
			<dependency name="CodeScanMatch_params"/>
			<dependency name="CodeScanMatch_stack"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="CodeScanResetJumpTargets"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="CodeScanner_param"/>
			<dependency name="CodeScanner_state"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_NOP"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="gBase"/>
			<dependency name="gCodBase"/>
			<dependency name="gDat"/>
			<dependency name="gHdr"/>
			<dependency name="gOP_CASETBL"/>
			<dependency name="gOP_NOP"/>
			<param name="scanner">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanMatcherData" syntax="CodeScanMatcherData(searcher[], val)">
			<stacksize value="1"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_user_data"/>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="val">
			</param>
		</member>
		<member name="M:CodeScanMatcherInit_" syntax="CodeScanMatcherInit_(searcher[], address, flags)">
			<stacksize value="5"/>
			<referrer name="AddressofResolve"/>
			<dependency name="CodeScanMatcher_flags"/>
			<dependency name="CodeScanMatcher_func"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanMatcher_user_data"/>
			<dependency name="CodeScanReset"/>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="address">
			</param>
			<param name="flags">
			</param>
		</member>
		<member name="M:CodeScanMatcherPattern_" syntax="CodeScanMatcherPattern_(searcher[], ...)">
			<stacksize value="10"/>
			<referrer name="AddressofResolve"/>
			<dependency name="CodeScanMatcher_code"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="GetOpcodeInstructionParameters"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<param name="searcher">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Opcode,Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanNOPMatch" syntax="CodeScanNOPMatch(csm[])">
			<stacksize value="3"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanMatch_size"/>
			<dependency name="cellbits"/>
			<dependency name="gOP_NOP"/>
			<param name="csm">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanReset" syntax="CodeScanReset(cs[], &amp;next)">
			<stacksize value="1"/>
			<referrer name="CodeScanMatcherInit_"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<dependency name="CodeScanMatcher_func"/>
			<dependency name="CodeScanMatcher_holeidx"/>
			<dependency name="CodeScanMatcher_len"/>
			<dependency name="CodeScanMatcher_next"/>
			<dependency name="CodeScanMatcher_offset"/>
			<param name="cs">
				<paraminfo> [171] </paraminfo>
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanResetJumpTargets" syntax="CodeScanResetJumpTargets(jumpTargets[], num)">
			<stacksize value="1"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanInit"/>
			<dependency name="CodeScanner_jump_target"/>
			<dependency name="CodeScanner_minn"/>
			<param name="jumpTargets">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:CodeScanRun" syntax="CodeScanRun(csState[])">
			<tagname value="bool"/>
			<stacksize value="188"/>
			<referrer name="CodeScanRunFast"/>
			<dependency name="CodeScanCall"/>
			<dependency name="CodeScanCheck"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanReset"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmInit"/>
			<dependency name="OP_NONE"/>
			<dependency name="cellmin"/>
			<dependency name="gDat"/>
			<dependency name="true"/>
			<param name="csState">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanRunFast" syntax="CodeScanRunFast(csState[], searchFuncAddr)">
			<tagname value="bool"/>
			<stacksize value="191"/>
			<referrer name="AddressofResolve"/>
			<dependency name="CodeScanCall"/>
			<dependency name="CodeScanCheck"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanDeref"/>
			<dependency name="CodeScanFindOneFastPattern2"/>
			<dependency name="CodeScanMatch_cip"/>
			<dependency name="CodeScanReset"/>
			<dependency name="CodeScanRun"/>
			<dependency name="CodeScanRunFastPrescan"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_first"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmInit"/>
			<dependency name="OP_NONE"/>
			<dependency name="OP_PROC"/>
			<dependency name="cellmin"/>
			<dependency name="false"/>
			<dependency name="printf"/>
			<dependency name="true"/>
			<param name="csState">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="searchFuncAddr">
			</param>
		</member>
		<member name="M:CodeScanRunFastPrescan" syntax="CodeScanRunFastPrescan(&amp;proc, &amp;nextaddr, searchFuncAddr)">
			<stacksize value="6"/>
			<referrer name="CodeScanRunFast"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_NONE"/>
			<dependency name="OP_PROC"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="UnrelocateOpcode"/>
			<dependency name="false"/>
			<dependency name="gCodBase"/>
			<dependency name="gOpArgCount"/>
			<dependency name="true"/>
			<param name="proc">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="nextaddr">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="searchFuncAddr">
			</param>
		</member>
		<member name="M:CodeScanStep" syntax="CodeScanStep(dctx[], csState[])">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<dependency name="CodeScanStepInternal"/>
			<dependency name="CodeScanner_param"/>
			<dependency name="CodeScanner_state"/>
			<param name="dctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="csState">
				<paraminfo> [164] </paraminfo>
			</param>
		</member>
		<member name="M:CodeScanStepInternal" syntax="CodeScanStepInternal(dctx[], csState[], &amp;parseState, &amp;parseParam)">
			<tagname value="bool"/>
			<stacksize value="13"/>
			<referrer name="CodeScanStep"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="CodeScanGetMatchScanner"/>
			<dependency name="CodeScanAddJumpTarget"/>
			<dependency name="CodeScanAddSwitchTarget"/>
			<dependency name="CodeScanCheckJumpTarget"/>
			<dependency name="CodeScanMatch_func"/>
			<dependency name="CodeScanMatch_heap"/>
			<dependency name="CodeScanMatch_stack"/>
			<dependency name="CodeScanMatch_type"/>
			<dependency name="CodeScanResetJumpTargets"/>
			<dependency name="DISASM_DONE"/>
			<dependency name="DISASM_NOP"/>
			<dependency name="DISASM_OK"/>
			<dependency name="DisasmGetCurIp"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmNext"/>
			<dependency name="OP_ADD_C"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CALL_PRI"/>
			<dependency name="OP_HALT"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_JEQ"/>
			<dependency name="OP_JGEQ"/>
			<dependency name="OP_JGRTR"/>
			<dependency name="OP_JLEQ"/>
			<dependency name="OP_JLESS"/>
			<dependency name="OP_JNEQ"/>
			<dependency name="OP_JNZ"/>
			<dependency name="OP_JREL"/>
			<dependency name="OP_JSGEQ"/>
			<dependency name="OP_JSGRTR"/>
			<dependency name="OP_JSLEQ"/>
			<dependency name="OP_JSLESS"/>
			<dependency name="OP_JUMP"/>
			<dependency name="OP_JZER"/>
			<dependency name="OP_LCTRL"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_POP_ALT"/>
			<dependency name="OP_POP_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_PUSH"/>
			<dependency name="OP_PUSH_ADR"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="OP_PUSH_PRI"/>
			<dependency name="OP_PUSH_R"/>
			<dependency name="OP_PUSH_S"/>
			<dependency name="OP_SCTRL"/>
			<dependency name="OP_STACK"/>
			<dependency name="OP_SWITCH"/>
			<dependency name="cellbits"/>
			<dependency name="cellmin"/>
			<dependency name="false"/>
			<dependency name="gBase"/>
			<dependency name="true"/>
			<param name="dctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="csState">
				<paraminfo> [164] </paraminfo>
			</param>
			<param name="parseState">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="parseParam">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:Colours_DoHashParse" syntax="Colours_DoHashParse(str[], &amp;idx, checkSpace)">
			<stacksize value="6"/>
			<referrer name="GetColourStream"/>
			<dependency name="strcmp"/>
			<dependency name="true"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="idx">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="checkSpace">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:Colours_EncodeGameText" syntax="Colours_EncodeGameText(str[])">
			<stacksize value="3"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:Colours_SAMPToGT" syntax="Colours_SAMPToGT(colour, start)">
			<stacksize value="10"/>
			<dependency name="cellmax"/>
			<param name="colour">
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:D@" syntax="D@(function[], fmat[], ...)">
			<stacksize value="9"/>
			<referrer name="_@_SetColoursCanHaveSpaces"/>
			<referrer name="_@_SetColourHash"/>
			<dependency name="@_"/>
			<dependency name="R@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCallData"/>
			<dependency name="YSI_g_sPropCaller"/>
			<dependency name="YSI_g_sPropEmpty"/>
			<dependency name="YSI_g_sPropReturn"/>
			<dependency name="YSI_g_sPropVarArg"/>
			<dependency name="getproperty"/>
			<dependency name="setarg"/>
			<dependency name="setproperty"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Database_Connect" syntax="Database_Connect()">
			<stacksize value="107"/>
			<referrer name="@yH_OnGameModeInit@000"/>
			<dependency name="AUTO_RECONNECT"/>
			<dependency name="Env_Get"/>
			<dependency name="Env_Has"/>
			<dependency name="MULTI_STATEMENTS"/>
			<dependency name="handle_Sql"/>
			<dependency name="mysql_connect"/>
			<dependency name="mysql_errno"/>
			<dependency name="mysql_init_options"/>
			<dependency name="mysql_set_option"/>
			<dependency name="print"/>
			<dependency name="printf"/>
			<dependency name="true"/>
		</member>
		<member name="M:Database_ReturnHandle" syntax="Database_ReturnHandle()">
			<tagname value="MySQL"/>
			<stacksize value="1"/>
			<referrer name="closeSql"/>
			<referrer name="account_CheckIfExists"/>
			<referrer name="registerPlayer"/>
			<dependency name="handle_Sql"/>
		</member>
		<member name="M:Debug_Disable" syntax="Debug_Disable()">
			<stacksize value="1"/>
			<remarks>  Turn off level 0 prints.  </remarks>  <transition target="off"/>

		</member>
		<member name="M:Debug_Enable" syntax="Debug_Enable()">
			<stacksize value="1"/>
			<remarks>  Turn on level 0 prints.  </remarks>  <transition target="on"/>

		</member>
		<member name="M:Debug_Level" syntax="Debug_Level(level)">
			<stacksize value="1"/>
			<dependency name="YSI_gDebugLevel"/>
			<param name="level">
			</param>
			<remarks>  Set the debug level when the code is compiled with <c>_DEBUG=-1</c>, which  means full run-time selection.  </remarks> 
		</member>
		<member name="M:Debug_OnCodeInit" syntax="Debug_OnCodeInit()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetGlobal"/>
			<dependency name="AMX_HEADER_AMX_VERSION"/>
			<dependency name="AMX_HEADER_CIP"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_HEADER_DAT"/>
			<dependency name="AMX_HEADER_DEFSIZE"/>
			<dependency name="AMX_HEADER_FILE_VERSION"/>
			<dependency name="AMX_HEADER_FLAGS"/>
			<dependency name="AMX_HEADER_HEA"/>
			<dependency name="AMX_HEADER_LIBRARIES"/>
			<dependency name="AMX_HEADER_MAGIC"/>
			<dependency name="AMX_HEADER_NAMETABLE"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_HEADER_PUBVARS"/>
			<dependency name="AMX_HEADER_SIZE"/>
			<dependency name="AMX_HEADER_STP"/>
			<dependency name="AMX_HEADER_TAGS"/>
			<dependency name="AMX_REAL_ADDRESS"/>
			<dependency name="AMX_REAL_DATA"/>
		</member>
		<member name="M:Debug_Print0" syntax="Debug_Print0(str[], ...)">
			<stacksize value="1"/>
			<automaton name="ysi_debug"/>
			<referrer name="ScriptInit_CallOnCodeInit"/>
			<referrer name="OnJITCompile"/>
			<referrer name="ScriptInit_OnCodeInit"/>
			<referrer name="y_profile_WTF"/>
			<referrer name="LevenshteinDistance"/>
			<referrer name="CGen_OOM"/>
			<referrer name="CGen_AddCodeSpace"/>
			<referrer name="Hooks_IsolateName"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GetStubEntry"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_Hooks_AddReplacement"/>
			<dependency name="YSI_PrintF"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
				
			</param>
			<param name="format">str.</param>    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print0("variables: %d, %d", i, j);  </code>  Or:  <code>  P:0("variables: %d, %d", i, j);  </code>  <c>_DEBUG</c> level 0 prints are ALWAYS compiled, but are runtime switched  using the automata <c>ysi_debug</c>.  When then state is <c>ysi_debug :  on</c>, the prints are executed.  When then state is <c>ysi_debug : off</c>,  they aren't.  </remarks> 
		</member>
		<member name="M:Debug_PrintArray" syntax="Debug_PrintArray(arr[], size)">
			<stacksize value="108"/>
			<dependency name="Debug_PrintArray"/>
			<dependency name="format"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Debug_SetState" syntax="Debug_SetState()">
			<stacksize value="1"/>
			<automaton name="ysi_debug"/>
			<referrer name="ScriptInit_OnCodeInit"/>
			<transition keep="true" target="ysi_debug : on" source="ysi_debug : "/>  <remarks>  Mostly exists to define the full range of <c>ysi_debug</c> states.  </remarks> <p/> <transition target="on"/>

		</member>
		<member name="M:DisasmDecodeInsn" syntax="DisasmDecodeInsn(ctx[])">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<referrer name="DisasmNext"/>
			<referrer name="DisasmNextInsn"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DumpAMX_WriteAMXCode"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="GetOpcodeInstructionParameters"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_NONE"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="UnrelocateOpcode"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmDump" syntax="DisasmDump(filename[])">
			<stacksize value="4"/>
			<dependency name="DisasmWrite"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetCurIp" syntax="DisasmGetCurIp(ctx[])">
			<stacksize value="1"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="DisasmContext_cip"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetInsnName" syntax="DisasmGetInsnName(ctx[], name[], size)">
			<stacksize value="21"/>
			<referrer name="DisasmWriteCode"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="GetOpcodeInstructionName"/>
			<dependency name="GetOpcodeInstructionName"/>
			<dependency name="strcat"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:DisasmGetNextIp" syntax="DisasmGetNextIp(ctx[])">
			<stacksize value="1"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="DumpAMX_WriteAMXCode"/>
			<dependency name="DisasmContext_nip"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetNumOperands" syntax="DisasmGetNumOperands(ctx[])">
			<stacksize value="5"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="DumpAMX_WriteAMXCode"/>
			<referrer name="Hooks_GetStubEntry"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="GetOpcodeInstructionParameters"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="ReadAmxMemory"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetOpcode" syntax="DisasmGetOpcode(ctx[])">
			<tagname value="Opcode"/>
			<stacksize value="1"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="DumpAMX_WriteAMXCode"/>
			<referrer name="_yH@"/>
			<dependency name="DisasmContext_opcode"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmGetOperand" syntax="DisasmGetOperand(ctx[], index)">
			<stacksize value="4"/>
			<referrer name="DisasmGetOperandReloc"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="DumpAMX_WriteAMXCode"/>
			<referrer name="Hooks_GetStubEntry"/>
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="ReadAmxMemory"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:DisasmGetOperandReloc" syntax="DisasmGetOperandReloc(ctx[], index)">
			<stacksize value="6"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="DumpAMX_WriteAMXCode"/>
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmNeedReloc"/>
			<dependency name="DisasmReloc"/>
			<dependency name="OP_CASETBL"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="index">
			</param>
		</member>
		<member name="M:DisasmGetRemaining" syntax="DisasmGetRemaining(ctx[])">
			<stacksize value="1"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmInit" syntax="DisasmInit(ctx[], start, end)">
			<stacksize value="21"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="CodeScanRun"/>
			<referrer name="DumpAMX_WriteAMXCode"/>
			<referrer name="ThirdParty_OnCodeInit"/>
			<referrer name="Hooks_GetStubEntry"/>
			<referrer name="Hooks_OnCodeInit"/>
			<referrer name="_yH@"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_start_ip"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="gCodBase"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="end">
			</param>
		</member>
		<member name="M:DisasmNeedReloc" syntax="DisasmNeedReloc(ctx[])">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="DisasmGetOperandReloc"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="GetOpcodeInstructionRelocatable"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmNext" syntax="DisasmNext(ctx[])">
			<tagname value="DisasmResult"/>
			<stacksize value="4"/>
			<referrer name="O@A_"/>
			<referrer name="CodeScanStepInternal"/>
			<referrer name="_yH@"/>
			<dependency name="DISASM_DONE"/>
			<dependency name="DISASM_NOP"/>
			<dependency name="DISASM_OK"/>
			<dependency name="DisasmContext_cip"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="NUM_OPCODES"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmNextInsn" syntax="DisasmNextInsn(ctx[])">
			<tagname value="Opcode"/>
			<stacksize value="4"/>
			<referrer name="ThirdParty_OnCodeInit"/>
			<referrer name="Hooks_GetStubEntry"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="DisasmContext_opcode"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="OP_NONE"/>
			<param name="ctx">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmReloc" syntax="DisasmReloc(addr)">
			<stacksize value="1"/>
			<referrer name="DisasmGetOperandReloc"/>
			<dependency name="gCodBase"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:DisasmWrite" syntax="DisasmWrite(filename[])">
			<tagname value="bool"/>
			<stacksize value="5"/>
			<referrer name="DisasmDump"/>
			<dependency name="DisasmWriteFile"/>
			<dependency name="false"/>
			<dependency name="fclose"/>
			<dependency name="fopen"/>
			<dependency name="io_write"/>
			<dependency name="true"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:DisasmWriteCode" syntax="DisasmWriteCode(file)">
			<stacksize value="159"/>
			<referrer name="DisasmWriteFile"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmContext_nip"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="DisasmGetCurIp"/>
			<dependency name="DisasmGetInsnName"/>
			<dependency name="DisasmGetNextIp"/>
			<dependency name="DisasmGetNumOperands"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="DisasmInit"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="GetNativeIndexFromAddress"/>
			<dependency name="GetNativeNameFromIndex"/>
			<dependency name="GetPublicIndexFromAddress"/>
			<dependency name="GetPublicNameFromIndex"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ToHexStr"/>
			<dependency name="ToHexStr"/>
			<dependency name="fwrite"/>
			<dependency name="gCodBase"/>
			<dependency name="strcat"/>
			<dependency name="strlen"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:DisasmWriteData" syntax="DisasmWriteData(file)">
			<stacksize value="38"/>
			<referrer name="DisasmWriteFile"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_HEA"/>
			<dependency name="DisasmWriteDataRowChar"/>
			<dependency name="DisasmWriteDataRowHex"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="ToHexStr"/>
			<dependency name="ToHexStr"/>
			<dependency name="fwrite"/>
			<dependency name="min"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:DisasmWriteDataRowChar" syntax="DisasmWriteDataRowChar(file, start, num, max)">
			<stacksize value="13"/>
			<referrer name="DisasmWriteData"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ToPrintableAscii"/>
			<dependency name="fwrite"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="num">
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:DisasmWriteDataRowHex" syntax="DisasmWriteDataRowHex(file, start, num, max)">
			<stacksize value="19"/>
			<referrer name="DisasmWriteData"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ToHexStr"/>
			<dependency name="ToHexStr"/>
			<dependency name="fwrite"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
			<param name="start">
			</param>
			<param name="num">
			</param>
			<param name="max">
			</param>
		</member>
		<member name="M:DisasmWriteFile" syntax="DisasmWriteFile(file)">
			<stacksize value="4"/>
			<referrer name="DisasmWrite"/>
			<dependency name="DisasmWriteCode"/>
			<dependency name="DisasmWriteData"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
		</member>
		<member name="M:DoLevenshteinDistance" syntax="DoLevenshteinDistance(a[], lenA, b[], lenB)">
			<stacksize value="42"/>
			<referrer name="LevenshteinDistance"/>
			<dependency name="min"/>
			<param name="a">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="lenA">
			</param>
			<param name="b">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="lenB">
			</param>
		</member>
		<member name="M:DumpAMX_EncodeBytes" syntax="DumpAMX_EncodeBytes(c, buffer[])">
			<stacksize value="2"/>
			<referrer name="DumpAMX_WriteEncoded"/>
			<param name="c">
			</param>
			<param name="buffer">
				<paraminfo> [5] </paraminfo>
			</param>
		</member>
		<member name="M:DumpAMX_Included_" syntax="DumpAMX_Included_()">
			<stacksize value="1"/>
		</member>
		<member name="M:DumpAMX_Write" syntax="DumpAMX_Write(filename[])">
			<tagname value="bool"/>
			<stacksize value="36"/>
			<referrer name="ScriptInit_CallOnCodeInit"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_FLAGS"/>
			<dependency name="DumpAMX_WriteAMXCode"/>
			<dependency name="DumpAMX_WriteAMXData"/>
			<dependency name="DumpAMX_WriteAMXHeader"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="false"/>
			<dependency name="fblockwrite"/>
			<dependency name="fclose"/>
			<dependency name="flength"/>
			<dependency name="fopen"/>
			<dependency name="fseek"/>
			<dependency name="io_write"/>
			<dependency name="seek_start"/>
			<dependency name="true"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:DumpAMX_WriteAMXCode" syntax="DumpAMX_WriteAMXCode(file, data[], &amp;offset, compact)">
			<tagname value="bool"/>
			<stacksize value="27"/>
			<referrer name="DumpAMX_Write"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmContext_end_ip"/>
			<dependency name="DisasmDecodeInsn"/>
			<dependency name="DisasmGetNextIp"/>
			<dependency name="DisasmGetNumOperands"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="DisasmInit"/>
			<dependency name="DumpAMX_WriteEncoded"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="GetNativeIndexFromAddress"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="true"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
			<param name="data">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="offset">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="compact">
			</param>
		</member>
		<member name="M:DumpAMX_WriteAMXData" syntax="DumpAMX_WriteAMXData(file, data[], &amp;offset, compact)">
			<tagname value="bool"/>
			<stacksize value="27"/>
			<referrer name="DumpAMX_Write"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_HEA"/>
			<dependency name="DumpAMX_WriteEncoded"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="true"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
			<param name="data">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="offset">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="compact">
			</param>
		</member>
		<member name="M:DumpAMX_WriteAMXHeader" syntax="DumpAMX_WriteAMXHeader(file, data[], &amp;offset, compact)">
			<tagname value="bool"/>
			<stacksize value="22"/>
			<referrer name="DumpAMX_Write"/>
			<dependency name="AMX_HDR_OFFSET_COD"/>
			<dependency name="AMX_HDR_OFFSET_DAT"/>
			<dependency name="AMX_HDR_OFFSET_LIBRARIES"/>
			<dependency name="AMX_HDR_OFFSET_NATIVES"/>
			<dependency name="GetRawAmxHeader"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="false"/>
			<dependency name="fblockwrite"/>
			<dependency name="true"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
			<param name="data">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="offset">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="compact">
			</param>
		</member>
		<member name="M:DumpAMX_WriteEncoded" syntax="DumpAMX_WriteEncoded(file, data[], &amp;offset, compact, c)">
			<stacksize value="11"/>
			<referrer name="DumpAMX_WriteAMXData"/>
			<referrer name="DumpAMX_WriteAMXCode"/>
			<dependency name="DumpAMX_EncodeBytes"/>
			<dependency name="fblockwrite"/>
			<param name="file">
				<paraminfo>File </paraminfo>
			</param>
			<param name="data">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="offset">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="compact">
			</param>
			<param name="c">
			</param>
		</member>
		<member name="M:Env_Get" syntax="Env_Get(env[], dest[], size)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="Database_Connect"/>
			<param name="env">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Env_Has" syntax="Env_Has(env[])">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="Database_Connect"/>
			<param name="env">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:F@" syntax="F@(calltype, master, heapptr)">
			<stacksize value="1"/>
			<referrer name="_@_SetColoursCanHaveSpaces"/>
			<referrer name="_@_SetColourHash"/>
			<dependency name="YSI_g_sCallData"/>
			<param name="calltype">
			</param>
			<param name="master">
			</param>
			<param name="heapptr">
			</param>
		</member>
		<member name="M:G@" syntax="G@(...)">
			<stacksize value="1"/>
			<dependency name="G@"/>
			<dependency name="Q@"/>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:GetAmxAddress" syntax="GetAmxAddress()">
			<stacksize value="5"/>
			<referrer name="ReadAmxCell"/>
			<referrer name="WriteAmxCell"/>
			<dependency name="RunShellcode"/>
			<dependency name="refabs"/>
		</member>
		<member name="M:GetAmxBaseAddress" syntax="GetAmxBaseAddress()">
			<stacksize value="3"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmInit"/>
			<referrer name="AsmGetJumpAddressFromOffset"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="CodeScanInit"/>
			<referrer name="AddressofResolveFoundStart"/>
			<referrer name="AbsToRel"/>
			<referrer name="RelToAbs"/>
			<referrer name="DumpAMX_WriteAMXCode"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="GetAmxBaseAddressNow"/>
		</member>
		<member name="M:GetAmxBaseAddressNow" syntax="GetAmxBaseAddressNow()">
			<stacksize value="9"/>
			<referrer name="GetAmxBaseAddress"/>
			<dependency name="GetAmxBaseAddress_helper"/>
		</member>
		<member name="M:GetAmxBaseAddress_helper" syntax="GetAmxBaseAddress_helper()">
			<stacksize value="1"/>
			<referrer name="GetAmxBaseAddressNow"/>
		</member>
		<member name="M:GetAmxFrame" syntax="GetAmxFrame()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxHeader" syntax="GetAmxHeader(amxhdr[])">
			<stacksize value="3"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmInit"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="AsmGetJumpAddressFromOffset"/>
			<referrer name="AsmGetCode"/>
			<referrer name="AsmEmitCallAbs"/>
			<referrer name="CodeScanInit"/>
			<referrer name="AddressofResolveFoundStart"/>
			<referrer name="Indirect_Init"/>
			<referrer name="DumpAMX_WriteAMXData"/>
			<referrer name="DumpAMX_WriteAMXCode"/>
			<referrer name="DumpAMX_Write"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetAmxHeaderComponent" syntax="GetAmxHeaderComponent(comp)">
			<stacksize value="3"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="comp">
				<paraminfo>AMX_HDR </paraminfo>
			</param>
		</member>
		<member name="M:GetAmxHeaderNow" syntax="GetAmxHeaderNow(amxhdr[])">
			<stacksize value="20"/>
			<referrer name="ResetStaticAmxHeader"/>
			<dependency name="AMX_HDR_AMX_VERSION"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_FILE_VERSION"/>
			<dependency name="AMX_HDR_FLAGS"/>
			<dependency name="AMX_HDR_HEA"/>
			<dependency name="AMX_HDR_LIBRARIES"/>
			<dependency name="AMX_HDR_MAGIC"/>
			<dependency name="AMX_HDR_NAMETABLE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_OFFSET_AMX_VERSION"/>
			<dependency name="AMX_HDR_OFFSET_CIP"/>
			<dependency name="AMX_HDR_OFFSET_COD"/>
			<dependency name="AMX_HDR_OFFSET_DAT"/>
			<dependency name="AMX_HDR_OFFSET_DEFSIZE"/>
			<dependency name="AMX_HDR_OFFSET_FILE_VERSION"/>
			<dependency name="AMX_HDR_OFFSET_FLAGS"/>
			<dependency name="AMX_HDR_OFFSET_HEA"/>
			<dependency name="AMX_HDR_OFFSET_LIBRARIES"/>
			<dependency name="AMX_HDR_OFFSET_MAGIC"/>
			<dependency name="AMX_HDR_OFFSET_NAMETABLE"/>
			<dependency name="AMX_HDR_OFFSET_NATIVES"/>
			<dependency name="AMX_HDR_OFFSET_PUBLICS"/>
			<dependency name="AMX_HDR_OFFSET_PUBVARS"/>
			<dependency name="AMX_HDR_OFFSET_SIZE"/>
			<dependency name="AMX_HDR_OFFSET_STP"/>
			<dependency name="AMX_HDR_OFFSET_TAGS"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="AMX_HDR_SIZE"/>
			<dependency name="AMX_HDR_STP"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetRawAmxHeader"/>
			<dependency name="copy_1"/>
			<dependency name="copy_2"/>
			<dependency name="copy_4"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetAmxHeapBase" syntax="GetAmxHeapBase()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxHeapTop" syntax="GetAmxHeapTop()">
			<stacksize value="1"/>
			<referrer name="Hooks_OnCodeInit"/>
		</member>
		<member name="M:GetAmxJITBaseAddress" syntax="GetAmxJITBaseAddress()">
			<stacksize value="1"/>
			<referrer name="AddressofResolve"/>
		</member>
		<member name="M:GetAmxNextInstructionPointer" syntax="GetAmxNextInstructionPointer()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxStackBase" syntax="GetAmxStackBase()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetAmxStackBottom" syntax="GetAmxStackBottom()">
			<stacksize value="1"/>
		</member>
		<member name="M:GetCallerFrame" syntax="GetCallerFrame()">
			<stacksize value="1"/>
			<referrer name="GetCurrentFramePreviousFrame"/>
			<referrer name="GetCurrentFrameReturn"/>
			<referrer name="GetCurrentFrameTotalSize"/>
			<referrer name="GetCurrentFrameTotalCount"/>
			<referrer name="GetCurrentFrameLocalSize"/>
			<referrer name="GetCurrentFrameLocalCount"/>
			<referrer name="GetCurrentFrameHeaderSize"/>
			<referrer name="GetCurrentFrameHeaderCount"/>
			<referrer name="GetCurrentFrameParameterSize"/>
			<referrer name="GetCurrentFrameParameter"/>
			<referrer name="GetCurrentFrameLocal"/>
			<referrer name="GetCurrentFrameParameterCount"/>
			<referrer name="SetCurrentFrameReturn"/>
			<referrer name="SetCurrentFramePreviousFrame"/>
			<referrer name="SetCurrentParameterSize"/>
			<referrer name="SetCurrentParameterCount"/>
			<referrer name="GetCurrentFrameFunction"/>
		</member>
		<member name="M:GetColour" syntax="GetColour(name[], alpha)">
			<stacksize value="9"/>
			<dependency name="GetColourHash"/>
			<dependency name="YHash"/>
			<dependency name="YSI_g_sCheckSpaces"/>
			<dependency name="false"/>
			<dependency name="hash_bernstein"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<dependency name="true"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="alpha">
			</param>
		</member>
		<member name="M:GetColourHash" syntax="GetColourHash(hash, alpha)">
			<stacksize value="3"/>
			<referrer name="_SetColourHash"/>
			<referrer name="GetColour"/>
			<dependency name="YSI_g_sColours"/>
			<dependency name="true"/>
			<param name="hash">
			</param>
			<param name="alpha">
			</param>
		</member>
		<member name="M:GetColourStream" syntax="GetColourStream(str[], &amp;idx, alpha)">
			<stacksize value="11"/>
			<dependency name="Colours_DoHashParse"/>
			<dependency name="YHash"/>
			<dependency name="YSI_g_sCheckSpaces"/>
			<dependency name="YSI_g_sColours"/>
			<dependency name="false"/>
			<dependency name="hash_bernstein"/>
			<dependency name="min"/>
			<dependency name="strcmp"/>
			<dependency name="strlen"/>
			<dependency name="true"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="idx">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="alpha">
			</param>
		</member>
		<member name="M:GetCurrentFrame" syntax="GetCurrentFrame()">
			<stacksize value="1"/>
			<referrer name="GetFrameNextFrame"/>
		</member>
		<member name="M:GetCurrentFrameFunction" syntax="GetCurrentFrameFunction()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameFunction"/>
		</member>
		<member name="M:GetCurrentFrameHeaderCount" syntax="GetCurrentFrameHeaderCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameHeaderCount"/>
		</member>
		<member name="M:GetCurrentFrameHeaderSize" syntax="GetCurrentFrameHeaderSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameHeaderSize"/>
		</member>
		<member name="M:GetCurrentFrameLocal" syntax="GetCurrentFrameLocal(param)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameLocal"/>
			<param name="param">
			</param>
		</member>
		<member name="M:GetCurrentFrameLocalCount" syntax="GetCurrentFrameLocalCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameLocalCount"/>
		</member>
		<member name="M:GetCurrentFrameLocalSize" syntax="GetCurrentFrameLocalSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameLocalSize"/>
		</member>
		<member name="M:GetCurrentFrameParameter" syntax="GetCurrentFrameParameter(param, idx)">
			<stacksize value="6"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameParameter"/>
			<param name="param">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:GetCurrentFrameParameterCount" syntax="GetCurrentFrameParameterCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameParameterCount"/>
		</member>
		<member name="M:GetCurrentFrameParameterSize" syntax="GetCurrentFrameParameterSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameParameterSize"/>
		</member>
		<member name="M:GetCurrentFramePreviousFrame" syntax="GetCurrentFramePreviousFrame()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFramePreviousFrame"/>
		</member>
		<member name="M:GetCurrentFrameReturn" syntax="GetCurrentFrameReturn()">
			<stacksize value="4"/>
			<referrer name="O@A_"/>
			<referrer name="_yH@"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameReturn"/>
		</member>
		<member name="M:GetCurrentFrameTotalCount" syntax="GetCurrentFrameTotalCount()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameTotalCount"/>
		</member>
		<member name="M:GetCurrentFrameTotalSize" syntax="GetCurrentFrameTotalSize()">
			<stacksize value="4"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="GetFrameTotalSize"/>
		</member>
		<member name="M:GetDat" syntax="GetDat()">
			<stacksize value="1"/>
			<referrer name="AbsToRel"/>
			<referrer name="RelToAbs"/>
		</member>
		<member name="M:GetFrameFunction" syntax="GetFrameFunction(frm_addr)">
			<stacksize value="29"/>
			<referrer name="GetCurrentFrameFunction"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="GetFrameNextFrame"/>
			<dependency name="GetFramePreviousFrame"/>
			<dependency name="GetFrameReturn"/>
			<dependency name="GetFrameVariable"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CONST_PRI"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_LOAD_S_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_RETN"/>
			<dependency name="OP_SCTRL"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="UnrelocateOpcode"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameHeaderCount" syntax="GetFrameHeaderCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameHeaderCount"/>
			<dependency name="GetFrameHeaderSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameHeaderSize" syntax="GetFrameHeaderSize(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetFrameTotalSize"/>
			<referrer name="GetFrameLocalSize"/>
			<referrer name="GetFrameHeaderCount"/>
			<referrer name="GetCurrentFrameHeaderSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameLocal" syntax="GetFrameLocal(frm_addr, param)">
			<stacksize value="1"/>
			<referrer name="GetCurrentFrameLocal"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
		</member>
		<member name="M:GetFrameLocalCount" syntax="GetFrameLocalCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameLocalCount"/>
			<dependency name="GetFrameLocalSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameLocalSize" syntax="GetFrameLocalSize(frm_addr)">
			<stacksize value="6"/>
			<referrer name="GetFrameTotalSize"/>
			<referrer name="GetFrameLocalCount"/>
			<referrer name="GetCurrentFrameLocalSize"/>
			<dependency name="GetFrameHeaderSize"/>
			<dependency name="GetFrameNextFrame"/>
			<dependency name="GetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameNextFrame" syntax="GetFrameNextFrame(frm_addr)">
			<stacksize value="6"/>
			<referrer name="GetFrameLocalSize"/>
			<referrer name="GetFrameFunction"/>
			<dependency name="GetCurrentFrame"/>
			<dependency name="GetFramePreviousFrame"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameParameter" syntax="GetFrameParameter(frm_addr, param, idx)">
			<stacksize value="1"/>
			<referrer name="GetCurrentFrameParameter"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:GetFrameParameterCount" syntax="GetFrameParameterCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameParameterCount"/>
			<dependency name="GetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameParameterSize" syntax="GetFrameParameterSize(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetFrameTotalSize"/>
			<referrer name="GetFrameLocalSize"/>
			<referrer name="GetFrameParameterCount"/>
			<referrer name="GetCurrentFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFramePreviousFrame" syntax="GetFramePreviousFrame(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetFrameNextFrame"/>
			<referrer name="GetCurrentFramePreviousFrame"/>
			<referrer name="GetFrameFunction"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameReturn" syntax="GetFrameReturn(frm_addr)">
			<stacksize value="1"/>
			<referrer name="GetCurrentFrameReturn"/>
			<referrer name="GetFrameFunction"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameTotalCount" syntax="GetFrameTotalCount(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetCurrentFrameTotalCount"/>
			<dependency name="GetFrameTotalSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameTotalSize" syntax="GetFrameTotalSize(frm_addr)">
			<stacksize value="4"/>
			<referrer name="GetFrameTotalCount"/>
			<referrer name="GetCurrentFrameTotalSize"/>
			<dependency name="GetFrameHeaderSize"/>
			<dependency name="GetFrameLocalSize"/>
			<dependency name="GetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
		</member>
		<member name="M:GetFrameVariable" syntax="GetFrameVariable(frm_addr, param, idx)">
			<stacksize value="1"/>
			<referrer name="GetFrameFunction"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:GetJITGeneratorVersion" syntax="GetJITGeneratorVersion()">
			<stacksize value="1"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
			<referrer name="CallNative"/>
			<referrer name="CallNativeByAddress"/>
		</member>
		<member name="M:GetNativeAddressFromIndex" syntax="GetNativeAddressFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetNativeAddressFromName"/>
			<referrer name="YHNPS_Push"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetNativeInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetNativeAddressFromName" syntax="GetNativeAddressFromName(name[])">
			<stacksize value="4"/>
			<dependency name="GetNativeAddressFromIndex"/>
			<dependency name="GetNativeIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetNativeIndexFromAddress" syntax="GetNativeIndexFromAddress(address)">
			<stacksize value="7"/>
			<referrer name="GetNativeNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DumpAMX_WriteAMXCode"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="address">
			</param>
		</member>
		<member name="M:GetNativeIndexFromName" syntax="GetNativeIndexFromName(name[])">
			<stacksize value="10"/>
			<referrer name="GetNativeAddressFromName"/>
			<referrer name="AsmEmitSysreq"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetNativeInfo" syntax="GetNativeInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetNativeAddressFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetNativeNameFromAddress" syntax="GetNativeNameFromAddress(address, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="GetNativeIndexFromAddress"/>
			<dependency name="GetNativeNameFromIndex"/>
			<param name="address">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetNativeNameFromIndex" syntax="GetNativeNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetNativeNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetNativeInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetNumNatives" syntax="GetNumNatives(amxhdr[])">
			<stacksize value="1"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_LIBRARIES"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetNumPubVars" syntax="GetNumPubVars(amxhdr[])">
			<stacksize value="1"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="AMX_HDR_TAGS"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetNumPublics" syntax="GetNumPublics(amxhdr[])">
			<stacksize value="2"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetNumTags" syntax="GetNumTags(amxhdr[])">
			<stacksize value="1"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NAMETABLE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<param name="amxhdr">
				<paraminfo> [17] </paraminfo>
			</param>
		</member>
		<member name="M:GetOpcodeInstructionInformation" syntax="GetOpcodeInstructionInformation(opcode)">
			<stacksize value="1"/>
			<dependency name="GetOpcodeInstructionInformation"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetOpcodeInstructionName" syntax="GetOpcodeInstructionName(opcode)">
			<stacksize value="1"/>
			<referrer name="DisasmGetInsnName"/>
			<dependency name="GetOpcodeInstructionName"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetOpcodeInstructionParameters" syntax="GetOpcodeInstructionParameters(opcode)">
			<stacksize value="1"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmGetNumOperands"/>
			<referrer name="AsmEmitPadding"/>
			<referrer name="CodeScanMatcherPattern_"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="OpcodeInsnInfo_num_opers"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetOpcodeInstructionRelocatable" syntax="GetOpcodeInstructionRelocatable(opcode)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="DisasmNeedReloc"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="OpcodeInsnInfo_needs_reloc"/>
			<dependency name="false"/>
			<dependency name="insn_table"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:GetPlayerIp" syntax="GetPlayerIp(playerid, ip[], len)">
			<attribute name="native"/>
			<referrer name="OnPlayerConnect"/>
			<param name="playerid">
				The ID of the player to get the IP address of
			</param>
			<param name="ip">
				<paraminfo> [] </paraminfo>
				An array into which to store the player's IP address, passed by reference
			</param>
			<param name="len">
				The maximum length of the IP address (recommended 16)
			</param>
			<summary>Get the specified player's IP address and store it in a string.</summary>    <seealso name="NetStats_GetIpPort"/> <seealso name="GetPlayerName"/> <seealso name="GetPlayerPing"/> <seealso name="GetPlayerVersion"/> <seealso name="OnIncomingConnection"/> <seealso name="OnPlayerConnect"/> <seealso name="OnPlayerDisconnect"/> <remarks>This function does not work when used in <a href="#OnPlayerDisconnect">OnPlayerDisconnect</a> because the player is already disconnected. It will return an invalid IP (<b><c>255.255.255.255</c></b>). Save players' IPs under <a href="#OnPlayerConnect">OnPlayerConnect</a> if they need to be used under <a href="#OnPlayerDisconnect">OnPlayerDisconnect</a>. </remarks> <returns><b><c>1</c></b> on success and <b><c>0</c></b> on failure.</returns>
		</member>
		<member name="M:GetPlayerName" syntax="GetPlayerName(playerid, name[], len)">
			<attribute name="native"/>
			<referrer name="ReturnPlayerName"/>
			<referrer name="Misc_ReturnName"/>
			<param name="playerid">
				The ID of the player to get the name of
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				An array into which to store the name, passed by reference
			</param>
			<param name="len">
				The length of the string that should be stored. Recommended to be <b><c>MAX_PLAYER_NAME</c></b>
			</param>
			<summary>Get a player's name.</summary>    <seealso name="SetPlayerName"/> <seealso name="GetPlayerIp"/> <seealso name="GetPlayerPing"/> <seealso name="GetPlayerScore"/> <seealso name="GetPlayerVersion"/> <remarks>A player's name can be up to 24 characters long (as of <b>0.3d R2</b>) by using <a href="#SetPlayerName">SetPlayerName</a>. This is defined in <c>a_samp.inc</c> as <b><c>MAX_PLAYER_NAME</c></b>. However, the client can only join with a nickname between 3 and 20 characters, otherwise the connection will be rejected and the player has to quit to choose a valid name.</remarks> <returns>The length of the player's name. <b><c>0</c></b> if player specified doesn't exist.</returns>
		</member>
		<member name="M:GetPlayerPing" syntax="GetPlayerPing(playerid)">
			<attribute name="native"/>
			<referrer name="AK_Kick"/>
			<param name="playerid">
				The ID of the player to get the ping of
			</param>
			<summary>Get the ping of a player. The ping measures the amount of time it takes for the server to 'ping' the client and for the client to send the message back.</summary>  <seealso name="GetPlayerIp"/> <seealso name="GetPlayerName"/> <seealso name="GetPlayerVersion"/> <remarks>Player's ping may be <b><c>65535</c></b> for a while after a player connects</remarks> <returns>The current ping of the player (expressed in milliseconds).</returns>
		</member>
		<member name="M:GetPubVarAddressFromIndex" syntax="GetPubVarAddressFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetPubVarAddressFromName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetPubVarInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetPubVarAddressFromName" syntax="GetPubVarAddressFromName(name[])">
			<stacksize value="4"/>
			<dependency name="GetPubVarAddressFromIndex"/>
			<dependency name="GetPubVarIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPubVarIndexFromAddress" syntax="GetPubVarIndexFromAddress(address)">
			<stacksize value="7"/>
			<referrer name="GetPubVarNameFromAddress"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="GetNumPubVars"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="address">
			</param>
		</member>
		<member name="M:GetPubVarIndexFromName" syntax="GetPubVarIndexFromName(name[])">
			<stacksize value="10"/>
			<referrer name="GetPubVarAddressFromName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="GetNumPubVars"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPubVarInfo" syntax="GetPubVarInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetPubVarAddressFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="GetNumPubVars"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetPubVarNameFromAddress" syntax="GetPubVarNameFromAddress(address, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="GetPubVarIndexFromAddress"/>
			<dependency name="GetPubVarNameFromIndex"/>
			<param name="address">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetPubVarNameFromIndex" syntax="GetPubVarNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetPubVarNameFromAddress"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetPubVarInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetPublicAddressFromIndex" syntax="GetPublicAddressFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetPublicAddressFromName"/>
			<referrer name="Indirect_Call"/>
			<referrer name="Indirect_Callstring"/>
			<referrer name="Indirect_Callvoid"/>
			<referrer name="Indirect_Array"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetPublicInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetPublicAddressFromName" syntax="GetPublicAddressFromName(name[])">
			<stacksize value="4"/>
			<referrer name="AsmSetErrorHandlerName"/>
			<referrer name="Hooks_RepairJITInit"/>
			<dependency name="GetPublicAddressFromIndex"/>
			<dependency name="GetPublicIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPublicIndexFromAddress" syntax="GetPublicIndexFromAddress(address)">
			<stacksize value="7"/>
			<referrer name="GetPublicNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanGetFuncName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="address">
			</param>
		</member>
		<member name="M:GetPublicIndexFromName" syntax="GetPublicIndexFromName(name[])">
			<stacksize value="12"/>
			<referrer name="GetPublicAddressFromName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetPublicInfo" syntax="GetPublicInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetPublicAddressFromIndex"/>
			<referrer name="GetPublicNameFromIndex"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetPublicNameFromAddress" syntax="GetPublicNameFromAddress(address, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="GetPublicIndexFromAddress"/>
			<dependency name="GetPublicNameFromIndex"/>
			<param name="address">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetPublicNameFromIndex" syntax="GetPublicNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetPublicNameFromAddress"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanGetFuncName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetPublicInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetRawAmxHeader" syntax="GetRawAmxHeader(plain_amxhdr[])">
			<stacksize value="6"/>
			<referrer name="GetAmxHeaderNow"/>
			<referrer name="DumpAMX_WriteAMXHeader"/>
			<dependency name="ReadAmxMemory"/>
			<param name="plain_amxhdr">
				<paraminfo> [14] </paraminfo>
			</param>
		</member>
		<member name="M:GetTagIDFromIndex" syntax="GetTagIDFromIndex(index)">
			<stacksize value="7"/>
			<referrer name="GetTagIDFromName"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetTagInfo"/>
			<param name="index">
			</param>
		</member>
		<member name="M:GetTagIDFromName" syntax="GetTagIDFromName(name[])">
			<stacksize value="4"/>
			<dependency name="GetTagIDFromIndex"/>
			<dependency name="GetTagIndexFromName"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetTagIndexFromID" syntax="GetTagIndexFromID(id)">
			<stacksize value="7"/>
			<referrer name="GetTagNameFromID"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetNumTags"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="id">
			</param>
		</member>
		<member name="M:GetTagIndexFromName" syntax="GetTagIndexFromName(name[])">
			<stacksize value="10"/>
			<referrer name="GetTagIDFromName"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetNumTags"/>
			<dependency name="NtCompare"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:GetTagInfo" syntax="GetTagInfo(index, info[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="GetTagIDFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<referrer name="IsTagIndexStrong"/>
			<referrer name="IsTagIndexWeak"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="GetNumTags"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="false"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="info">
				<paraminfo> [2] </paraminfo>
			</param>
		</member>
		<member name="M:GetTagNameFromID" syntax="GetTagNameFromID(id, name[], size)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<referrer name="Indirect_Call"/>
			<referrer name="Indirect_Callstring"/>
			<referrer name="Indirect_Callvoid"/>
			<referrer name="Indirect_Array"/>
			<referrer name="Indirect_Tag"/>
			<dependency name="GetTagIndexFromID"/>
			<dependency name="GetTagNameFromIndex"/>
			<dependency name="true"/>
			<param name="id">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:GetTagNameFromIndex" syntax="GetTagNameFromIndex(index, name[], size)">
			<tagname value="bool"/>
			<stacksize value="8"/>
			<referrer name="GetTagNameFromID"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_NAMEOFS"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="GetAmxHeaderComponent"/>
			<dependency name="GetTagInfo"/>
			<dependency name="NtCopy"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="index">
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:H@" syntax="H@(...)">
			<stacksize value="1"/>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:HaveToRelocateOpcodes" syntax="HaveToRelocateOpcodes()">
			<tagname value="bool"/>
			<stacksize value="4"/>
			<referrer name="RelocateOpcodeNow"/>
			<dependency name="OP_CALL"/>
			<dependency name="ReadOpcodeNearThis"/>
		</member>
		<member name="M:HeapAllocBytes" syntax="HeapAllocBytes(nbytes)">
			<stacksize value="2"/>
			<referrer name="HeapAllocCells"/>
			<param name="nbytes">
			</param>
		</member>
		<member name="M:HeapAllocCells" syntax="HeapAllocCells(ncells)">
			<stacksize value="4"/>
			<referrer name="YHNPS_Push"/>
			<dependency name="HeapAllocBytes"/>
			<param name="ncells">
			</param>
		</member>
		<member name="M:HeapRelease" syntax="HeapRelease(address)">
			<stacksize value="1"/>
			<referrer name="Hooks_OnCodeInit"/>
			<param name="address">
			</param>
		</member>
		<member name="M:HookNative" syntax="HookNative(index, address)">
			<stacksize value="8"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="GetNumNatives"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="WriteAmxMemory"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="index">
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:HookPublic" syntax="HookPublic(index, address)">
			<stacksize value="8"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="GetNumPublics"/>
			<dependency name="ReadAmxMemory"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="WriteAmxMemory"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<param name="index">
			</param>
			<param name="address">
			</param>
		</member>
		<member name="M:Hooks_Collate" syntax="Hooks_Collate(preloads[][], precount, name[], idx)">
			<stacksize value="30"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="Hooks_GenerateCode"/>
			<dependency name="Hooks_GetAllHooks"/>
			<dependency name="Hooks_GetPointerRewrite"/>
			<dependency name="Hooks_GetPreHooks"/>
			<dependency name="Hooks_IsolateName"/>
			<dependency name="Hooks_MakeLongName"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
			<param name="preloads">
				<paraminfo> [][17] </paraminfo>
			</param>
			<param name="precount">
			</param>
			<param name="name">
				<paraminfo> [32] </paraminfo>
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:Hooks_CompareNextCell" syntax="Hooks_CompareNextCell(addr0, addr1)">
			<stacksize value="6"/>
			<referrer name="Hooks_ComparePublics"/>
			<dependency name="AMX_Read"/>
			<dependency name="Cell_ReverseBytes"/>
			<param name="addr0">
				The 1st address to read.
			</param>
			<param name="addr1">
				The 2nd address to read.
			</param>
			    <returns>  -1 - The first address is bigger.  0  - The addresses are the same  1  - The second address is bigger.  </returns>  <remarks>  Reads two addresses, converts them to big endian, and compares them as four  characters of a string at once.  </remarks> 
		</member>
		<member name="M:Hooks_ComparePublics" syntax="Hooks_ComparePublics(idx0, idx1)">
			<stacksize value="9"/>
			<referrer name="Hooks_SortPublics"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="Hooks_CompareNextCell"/>
			<param name="idx0">
				The index of the 1st public.
			</param>
			<param name="idx1">
				The index of the 2nd public.
			</param>
			    <remarks>  Compares two public function entries, and if need-be, swaps them over.  </remarks> 
		</member>
		<member name="M:Hooks_Continue_" syntax="Hooks_Continue_(...)">
			<stacksize value="1"/>
			<referrer name="Hooks_GenerateContinue"/>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Hooks_CountInvalidPublics" syntax="Hooks_CountInvalidPublics()">
			<stacksize value="10"/>
			<referrer name="Hooks_SortPublics"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<remarks>  Counts the number of public functions that have had their names erased.  </remarks> 
		</member>
		<member name="M:Hooks_DoAllHooks" syntax="Hooks_DoAllHooks()">
			<stacksize value="617"/>
			<referrer name="CGen_OnCodeInit"/>
			<dependency name="AMX_GetNamePrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="E_CHAIN_HOOK"/>
			<dependency name="Hooks_Collate"/>
			<dependency name="Hooks_GetPreloadLibraries"/>
		</member>
		<member name="M:Hooks_GenerateCode" syntax="Hooks_GenerateCode(name[], hooks[], count, write, hasprehooks)">
			<stacksize value="7"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_DATA"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="CGen_AddCodeSpace"/>
			<dependency name="CGen_GetCodeSpace"/>
			<dependency name="Hooks_GetDefaultReturn"/>
			<dependency name="Hooks_WriteFunction"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Name of the function to generate.
			</param>
			<param name="hooks">
				<paraminfo> [] </paraminfo>
				All the functions to call.
			</param>
			<param name="count">
				Number of functions to call.
			</param>
			<param name="write">
				Where to write the new function's pointer.
			</param>
			<param name="hasprehooks">
				<paraminfo>bool </paraminfo>
				Needs to call other stuff first.
			</param>
			         
		</member>
		<member name="M:Hooks_GenerateContinue" syntax="Hooks_GenerateContinue(...)">
			<stacksize value="39"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitAddC"/>
			<dependency name="AsmEmitAddrPri"/>
			<dependency name="AsmEmitAnd"/>
			<dependency name="AsmEmitConstPri"/>
			<dependency name="AsmEmitJgrtrLabelStringize"/>
			<dependency name="AsmEmitJsleqLabelStringize"/>
			<dependency name="AsmEmitJumpLabelStringize"/>
			<dependency name="AsmEmitJzerLabelStringize"/>
			<dependency name="AsmEmitLabelStringize"/>
			<dependency name="AsmEmitLctrl"/>
			<dependency name="AsmEmitLoadI"/>
			<dependency name="AsmEmitLoadPri"/>
			<dependency name="AsmEmitLrefSPri"/>
			<dependency name="AsmEmitMoveAlt"/>
			<dependency name="AsmEmitMovePri"/>
			<dependency name="AsmEmitNeg"/>
			<dependency name="AsmEmitPadding"/>
			<dependency name="AsmEmitPopAlt"/>
			<dependency name="AsmEmitPopPri"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitPushPri"/>
			<dependency name="AsmEmitSctrl"/>
			<dependency name="AsmEmitShrCAlt"/>
			<dependency name="AsmEmitSrefSPri"/>
			<dependency name="AsmEmitStorAlt"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="Hooks_Continue_"/>
			<dependency name="O@A_"/>
			<dependency name="O@V_"/>
			<dependency name="YSI_g_sNPSStack"/>
			<dependency name="YSI_g_sTempRet"/>
			<dependency name="_@yH"/>
			<dependency name="ref"/>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Hooks_GetAllHooks" syntax="Hooks_GetAllHooks(name[], hooks[], idx, &amp;namelen, size)">
			<stacksize value="74"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_GetStringFromEntry"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Hooks_InvalidateName"/>
			<dependency name="Hooks_IsolateName"/>
			<dependency name="Hooks_MakeLongName"/>
			<dependency name="strcmp"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The name of the callback (with y_hooks prefix).
			</param>
			<param name="hooks">
				<paraminfo> [] </paraminfo>
				Array in which to store the function headers.
			</param>
			<param name="idx">
				Current position in the AMX header.
			</param>
			<param name="namelen">
				<paraminfo> &amp; </paraminfo>
				Min bound of space used by all these names.
			</param>
			<param name="size">
			</param>
			        <returns>  The number of hooks found.  </returns>  <remarks>  The name of the function currently being processed is derived from the first  found hook.  This means we already know of one hook, but to simplify the  code we get that one again here.  Above we only know the name not the  address.  Hence the "- 1" in "i = idx - 1" (to go back one function name).  Our "namelen" variable already contains the full length of the first found  hook - this is the length of "name", plus N extra characters.  The following  are all valid, and may occur when orders are played with:  @yH_OnX@  @yH_OnX@1  @yH_OnX@01  @yH_OnX@024  @yH_OnX@ZZZ  @yH_OnX@999@024  If we want to get the EXACT space taken up by all these hook names we would  need to get the string of the name in this function then measure it.  There  is really no point in doing this - if we have a second we will always have  enough space for our new names.  Instead, we assume that they are all just  @yH_OnX@  And add on that minimum length accordingly (plus 1 for the NULL character).  This length is used if the original callback doesn't exist but hooks do.  In  that case we need to add the callback to the AMX header, and there is a tiny  chance that the original name will be longer than one hook's name.  In that  case, having two or more hooks will (AFAIK) always ensure that we have  enough space to write the longer name.  If there is only one hook, no original function, and the name of the hook is  shorter than the name of the original function then we have an issue and  will have to do something else instead.  </remarks> 
		</member>
		<member name="M:Hooks_GetDefaultReturn" syntax="Hooks_GetDefaultReturn(name[])">
			<stacksize value="73"/>
			<referrer name="Hooks_GenerateCode"/>
			<dependency name="AMX_GetEntry"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="CallFunction"/>
			<dependency name="Hooks_MakeShortName"/>
			<dependency name="strcat"/>
			<dependency name="true"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				The function to get the default return of.
			</param>
			  <returns>  The default return for a callback, normally 1.  </returns> 
		</member>
		<member name="M:Hooks_GetFunctionWritePoint" syntax="Hooks_GetFunctionWritePoint(name[], &amp;write)">
			<stacksize value="8"/>
			<dependency name="AMX_GetEntry"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="true"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The function to get the address pointer of.
			</param>
			<param name="write">
				<paraminfo> &amp; </paraminfo>
				Destination variable.
			</param>
			    <returns>  The address at which this function's pointer is stored in the AMX header, if  the function exists of course.  </returns> 
		</member>
		<member name="M:Hooks_GetPointerRewrite" syntax="Hooks_GetPointerRewrite(hooks[], num, &amp;ptr, &amp;next, name[], nlen)">
			<stacksize value="39"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_DATA"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="AMX_WriteString"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Hooks_GetStubEntry"/>
			<dependency name="OP_JUMP"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="strlen"/>
			<dependency name="strpack"/>
			<param name="hooks">
				<paraminfo> [] </paraminfo>
				All the prehooks for this callback.
			</param>
			<param name="num">
				The number of prehooks.
			</param>
			<param name="ptr">
				<paraminfo> &amp; </paraminfo>
				A pointer to write the new stub address to.
			</param>
			<param name="next">
				<paraminfo> &amp; </paraminfo>
				The pointer for the function called after y_hooks.
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The name of the callback being processed.
			</param>
			<param name="nlen">
				Space available in the header to write text in.
			</param>
			           
		</member>
		<member name="M:Hooks_GetPreHooks" syntax="Hooks_GetPreHooks(preloads[][], precount, name[], hooks[], &amp;count)">
			<stacksize value="73"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="AMX_GetEntry"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="E_CHAIN_HOOK_NAME"/>
			<dependency name="Hooks_MakeShortName"/>
			<dependency name="strcat"/>
			<dependency name="true"/>
			<param name="preloads">
				<paraminfo> [][17] </paraminfo>
				Names of libraries that come before y_hooks.
			</param>
			<param name="precount">
				Number of pre libraries.
			</param>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Name of the callback.
			</param>
			<param name="hooks">
				<paraminfo> [] </paraminfo>
				Destination in which to store the headers.
			</param>
			<param name="count">
				<paraminfo> &amp; </paraminfo>
				Number of headers found.
			</param>
			          <remarks>  Finds all the AMX file headers for functions with a similar name to the  given callback that should be called before (or near) the given callback.  </remarks> 
		</member>
		<member name="M:Hooks_GetPreloadLibraries" syntax="Hooks_GetPreloadLibraries(preloads[][], &amp;precount, size)">
			<stacksize value="161"/>
			<referrer name="Hooks_DoAllHooks"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_GetEntryPrefix"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_ReadString"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="CallFunction"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_CHAIN_HOOK"/>
			<dependency name="E_CHAIN_HOOK_NAME"/>
			<dependency name="E_CHAIN_HOOK_VALUE"/>
			<dependency name="Hooks_InvalidateName"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
			<dependency name="unpack"/>
			<dependency name="unpack"/>
			<param name="preloads">
				<paraminfo> [][17] </paraminfo>
				Desination in which to store all the preloads.
			</param>
			<param name="precount">
				<paraminfo> &amp; </paraminfo>
				Number of found preload libraries.
			</param>
			<param name="size">
				Maximum number of libraries to store.
			</param>
			      <remarks>  Some includes, like "fixes.inc" and anti-cheats MUST come before all other  includes in order for everything to function correctly (at least fixes.inc  must).  This function looks for these definitions:  PRE_HOOK(FIXES)  Which tell y_hooks that any "FIXES_" prefixed callbacks are part of one of  these chains.  </remarks> 
		</member>
		<member name="M:Hooks_GetStubEntry" syntax="Hooks_GetStubEntry(stub)">
			<stacksize value="13"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmGetNumOperands"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmInit"/>
			<dependency name="DisasmNextInsn"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_JUMP"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_SWITCH"/>
			<param name="stub">
				Starting address of the function.
			</param>
			  <returns>  The address at which the actual code in this function starts.  </returns>  <remarks>  This handles three cases.  Regular functions end instantly as found.  Functions that start with a switch (even before "PROC") are assumed to be  state-based functions, and we find the most likely state to be used (i.e. we  remove all future state changes).  </remarks> 
		</member>
		<member name="M:Hooks_InvalidateName" syntax="Hooks_InvalidateName(entry)">
			<stacksize value="5"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="CGen_OnCodeInit"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<param name="entry">
				The public function slot to destroy.
			</param>
			  <remarks>  Basically, once we know a function has been included, wipe it from the AMX  header.  </remarks> 
		</member>
		<member name="M:Hooks_IsolateName" syntax="Hooks_IsolateName(name[])">
			<stacksize value="152"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="Debug_Print0"/>
			<dependency name="false"/>
			<dependency name="strdel"/>
			<dependency name="strfind"/>
			<dependency name="unpack"/>
			<dependency name="unpack"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The string to get the hooked function name from.
			</param>
			  <returns>  The input string without y_hooks name decorations.  </returns> 
		</member>
		<member name="M:Hooks_MakeLongName" syntax="Hooks_MakeLongName(name[])">
			<stacksize value="10"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_LONG"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MIN"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_SHORT"/>
			<dependency name="Hooks_MakeShortName"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsShortOrder"/>
			<dependency name="false"/>
			<dependency name="strdel"/>
			<dependency name="strfind"/>
			<dependency name="strins"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Function name to modify.
			</param>
			  <remarks>  Expands all name parts like "CP" and "Obj" to their full versions (in this  example "Checkpoint" and "Object").  </remarks> 
		</member>
		<member name="M:Hooks_MakeShortName" syntax="Hooks_MakeShortName(name[])">
			<stacksize value="10"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_LONG"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_SHORT"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsLongOrder"/>
			<dependency name="false"/>
			<dependency name="strdel"/>
			<dependency name="strfind"/>
			<dependency name="strins"/>
			<dependency name="strlen"/>
			<param name="name">
				<paraminfo> [64] </paraminfo>
				Function name to modify.
			</param>
			  <remarks>  Compresses function names when required to fit within 32 characters  according to well defined rules (see "YSI_g_sReplacements").  </remarks> 
		</member>
		<member name="M:Hooks_NumArgs" syntax="Hooks_NumArgs()">
			<stacksize value="1"/>
			<dependency name="__COMPILER_DEFAULT"/>
		</member>
		<member name="M:Hooks_OnCodeInit" syntax="Hooks_OnCodeInit()">
			<attribute name="public"/>
			<stacksize value="28"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
			<dependency name="AMX_Write"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmGetCurIp"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="DisasmInit"/>
			<dependency name="DisasmNextInsn"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="GetAmxHeapTop"/>
			<dependency name="HeapRelease"/>
			<dependency name="Hooks_GenerateContinue"/>
			<dependency name="Indirect_Call"/>
			<dependency name="Indirect_Init"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_NONE"/>
			<dependency name="OP_NOP"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_STACK"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="YHNPS_Find"/>
			<dependency name="YHNPS_Push"/>
			<dependency name="YSI_g_sNPSBaseCall"/>
			<dependency name="YSI_g_sNPSReplace"/>
			<dependency name="YSI_g_sNPSStack"/>
			<dependency name="YSI_g_sNPSTrampoline"/>
			<dependency name="cellmin"/>
		</member>
		<member name="M:Hooks_Ordinal" syntax="Hooks_Ordinal(n)">
			<stacksize value="13"/>
			<referrer name="OnRuntimeError"/>
			<dependency name="Hooks_Ordinal"/>
			<dependency name="strcat"/>
			<dependency name="valstr"/>
			<param name="n">
			</param>
		</member>
		<member name="M:Hooks_RepairJITInit" syntax="Hooks_RepairJITInit()">
			<stacksize value="7"/>
			<referrer name="CGen_OnCodeInit"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="FALSE"/>
			<dependency name="GetPublicAddressFromName"/>
			<dependency name="YSI_g_sInitFSIdx"/>
			<dependency name="YSI_g_sInitFSPtr"/>
			<dependency name="YSI_g_sInitFSRep"/>
			<dependency name="YSI_g_sInitGMIdx"/>
			<dependency name="YSI_g_sInitGMPtr"/>
			<dependency name="YSI_g_sInitGMRep"/>
			<dependency name="_Hooks_RepairStubFS"/>
			<dependency name="_Hooks_RepairStubGM"/>
		</member>
		<member name="M:Hooks_SortPublics" syntax="Hooks_SortPublics()">
			<stacksize value="8"/>
			<referrer name="CGen_OnCodeInit"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_NATIVES"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="Hooks_ComparePublics"/>
			<dependency name="Hooks_CountInvalidPublics"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="Server_JITExists"/>
			<dependency name="YSI_g_sInitPublicDiff"/>
			<dependency name="YSI_g_sSortedOnce"/>
			<dependency name="true"/>
			<remarks>  Goes through the whole of the public functions table and sorts them all in  to alphabetical order.  This is done as we move and rename some so we need  to fix the virtual machine's binary search.  </remarks> 
		</member>
		<member name="M:Hooks_SortReplacements" syntax="Hooks_SortReplacements()">
			<stacksize value="6"/>
			<referrer name="CGen_OnCodeInit"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MIN"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsLongOrder"/>
			<dependency name="YSI_g_sReplacementsShortOrder"/>
			<remarks>  Once all the replacement strings have been found, sort them by the length of  the short versions of the strings.  This is so that the longest (and special  case, e.g. "DynamicCP"-> "DynamicCP") replacements are always done first.  </remarks> 
		</member>
		<member name="M:Hooks_WriteFunction" syntax="Hooks_WriteFunction(pointers[], size, ret, skipable)">
			<stacksize value="29"/>
			<referrer name="Hooks_GenerateCode"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_REAL_ADDRESS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmContext_buffer_offset"/>
			<dependency name="AsmEmitAddC"/>
			<dependency name="AsmEmitAddrPri"/>
			<dependency name="AsmEmitAnd"/>
			<dependency name="AsmEmitCall"/>
			<dependency name="AsmEmitInvert"/>
			<dependency name="AsmEmitJsgeqLabelStringize"/>
			<dependency name="AsmEmitJslessLabelStringize"/>
			<dependency name="AsmEmitJumpLabelStringize"/>
			<dependency name="AsmEmitJzerLabelStringize"/>
			<dependency name="AsmEmitLabelStringize"/>
			<dependency name="AsmEmitLctrl"/>
			<dependency name="AsmEmitLoadSAlt"/>
			<dependency name="AsmEmitLoadSPri"/>
			<dependency name="AsmEmitMoveAlt"/>
			<dependency name="AsmEmitMovePri"/>
			<dependency name="AsmEmitMovs"/>
			<dependency name="AsmEmitOr"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitPush"/>
			<dependency name="AsmEmitPushAlt"/>
			<dependency name="AsmEmitPushC"/>
			<dependency name="AsmEmitPushPri"/>
			<dependency name="AsmEmitRetn"/>
			<dependency name="AsmEmitSctrl"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="AsmEmitStorPri"/>
			<dependency name="AsmEmitStorSPri"/>
			<dependency name="AsmEmitSub"/>
			<dependency name="AsmEmitSysreq"/>
			<dependency name="AsmEmitXchg"/>
			<dependency name="AsmEmitZeroAlt"/>
			<dependency name="CGen_GetCodeSpace"/>
			<dependency name="CGen_UseCodeSpace"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Server_JITExists"/>
			<dependency name="YSI_g_sActiveHooks"/>
			<dependency name="ref"/>
			<param name="pointers">
				<paraminfo> [] </paraminfo>
				The hooks to link together.
			</param>
			<param name="size">
				The number of functions in the array.
			</param>
			<param name="ret">
				The default return.
			</param>
			<param name="skipable">
				Can future hooks be ignored on -1?
			</param>
			        <returns>  The number of bytes written to memory.  </returns>  <remarks>  Generate some new code, very nicely :D.  </remarks> 
		</member>
		<member name="M:IPToInt" syntax="IPToInt(ip[])">
			<stacksize value="5"/>
			<referrer name="OnPlayerConnect"/>
			<dependency name="strval"/>
			<param name="ip">
				<paraminfo> [] </paraminfo>
				Dot notation IP to convert to an integer.
			</param>
			 
		</member>
		<member name="M:Indirect_Array" syntax="Indirect_Array(func, tag, params[], size)">
			<stacksize value="6"/>
			<dependency name="GetPublicAddressFromIndex"/>
			<dependency name="GetTagNameFromID"/>
			<dependency name="INDIRECTION_DATA"/>
			<dependency name="INDIRECTION_TAG"/>
			<dependency name="funcidx"/>
			<dependency name="gsCodSize"/>
			<dependency name="memcpy"/>
			<param name="func">
			</param>
			<param name="tag">
			</param>
			<param name="params">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:Indirect_Call" syntax="Indirect_Call(func, tag, ...)">
			<stacksize value="6"/>
			<referrer name="Indirect_FromCallback"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="GetPublicAddressFromIndex"/>
			<dependency name="GetTagNameFromID"/>
			<dependency name="INDIRECTION_DATA"/>
			<dependency name="INDIRECTION_TAG"/>
			<dependency name="funcidx"/>
			<dependency name="gsCodSize"/>
			<param name="func">
			</param>
			<param name="tag">
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Indirect_Callstring" syntax="Indirect_Callstring(func, tag, ...)">
			<stacksize value="145"/>
			<dependency name="GetPublicAddressFromIndex"/>
			<dependency name="GetTagNameFromID"/>
			<dependency name="INDIRECTION_DATA"/>
			<dependency name="INDIRECTION_TAG"/>
			<dependency name="Indirect_Callstring"/>
			<dependency name="funcidx"/>
			<dependency name="gsCodSize"/>
			<param name="func">
			</param>
			<param name="tag">
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Indirect_Callvoid" syntax="Indirect_Callvoid(func, tag, ...)">
			<stacksize value="6"/>
			<dependency name="GetPublicAddressFromIndex"/>
			<dependency name="GetTagNameFromID"/>
			<dependency name="INDIRECTION_DATA"/>
			<dependency name="INDIRECTION_TAG"/>
			<dependency name="funcidx"/>
			<dependency name="gsCodSize"/>
			<param name="func">
			</param>
			<param name="tag">
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Indirect_Claim_" syntax="Indirect_Claim_(func)">
			<stacksize value="1"/>
			<dependency name="gsCodSize"/>
			<param name="func">
				The function pointer you want to use later.
			</param>
			  <remarks>  If a function pointer is used within one function, that is not a problem.  However, if you want to store the function pointer for use later, you must  first "claim" it, so that any associated data is not cleared when the  parent function ends (i.e. the function that called your function).  After  use it must be released, and the number of claims must match the number of  releases.  </remarks> 
		</member>
		<member name="M:Indirect_DePtr_" syntax="Indirect_DePtr_(ptr)">
			<stacksize value="2"/>
			<dependency name="gsCodSize"/>
			<dependency name="numargs"/>
			<param name="ptr">
			</param>
			<param name="">The array to convert to an offset pointer.</param>  <remarks>  Strings and arrays are passed relative to `COD` not `DAT` so they can be  distinguished from normal function pointers.  This function does the offset.  </remarks> 
		</member>
		<member name="M:Indirect_DeRef_" syntax="Indirect_DeRef_(...)">
			<stacksize value="2"/>
			<dependency name="gsCodSize"/>
			<dependency name="numargs"/>
			<param name="...">
				The array to convert to an offset pointer.
			</param>
			  <remarks>  Strings and arrays are passed relative to `COD` not `DAT` so they can be  distinguished from normal function pointers.  This function does the offset.  </remarks> 
		</member>
		<member name="M:Indirect_FromCallback" syntax="Indirect_FromCallback(cb, release)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<dependency name="Indirect_Call"/>
			<dependency name="Indirect_Release_"/>
			<param name="cb">
				<paraminfo>F@_@ </paraminfo>
			</param>
			<param name="release">
				<paraminfo>bool </paraminfo>
			</param>
			<remarks>  A generic public wrapper for calling inline functions.  </remarks> 
		</member>
		<member name="M:Indirect_GetMeta_" syntax="Indirect_GetMeta_(func)">
			<stacksize value="1"/>
			<dependency name="gsCodSize"/>
			<param name="func">
				The function pointer with attached metadata.
			</param>
			  <remarks>  Gets extra data from the pointer.  </remarks> 
		</member>
		<member name="M:Indirect_Init" syntax="Indirect_Init()">
			<stacksize value="21"/>
			<referrer name="ScriptInit_OnJITCompile"/>
			<referrer name="ScriptInit_OnFilterScriptInit"/>
			<referrer name="ScriptInit_OnGameModeInit"/>
			<referrer name="AMX_OnCodeInit"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="AMX_HDR"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AddressofResolve"/>
			<dependency name="GetAmxHeader"/>
			<dependency name="gsCodSize"/>
			<remarks>  Get the size of the COD AMX segment.  </remarks> 
		</member>
		<member name="M:Indirect_Ptr_" syntax="Indirect_Ptr_(ptr)">
			<stacksize value="2"/>
			<dependency name="gsCodSize"/>
			<dependency name="numargs"/>
			<param name="ptr">
			</param>
			<param name="">The array to convert to an offset pointer.</param>  <remarks>  Strings and arrays are passed relative to `COD` not `DAT` so they can be  distinguished from normal function pointers.  This function does the offset.  </remarks> 
		</member>
		<member name="M:Indirect_Ref_" syntax="Indirect_Ref_(...)">
			<stacksize value="2"/>
			<dependency name="gsCodSize"/>
			<dependency name="numargs"/>
			<param name="...">
				The array to convert to an offset pointer.
			</param>
			  <remarks>  Strings and arrays are passed relative to `COD` not `DAT` so they can be  distinguished from normal function pointers.  This function does the offset.  </remarks> 
		</member>
		<member name="M:Indirect_Release_" syntax="Indirect_Release_(func)">
			<stacksize value="1"/>
			<referrer name="Indirect_FromCallback"/>
			<dependency name="gsCodSize"/>
			<param name="func">
				The function pointer you had previously stored.
			</param>
			  <remarks>  If a function pointer is used within one function, that is not a problem.  However, if you want to store the function pointer for use later, you must  first "claim" it, so that any associated data is not cleared when the  parent function ends (i.e. the function that called your function).  After  use it must be released, and the number of claims must match the number of  releases.  </remarks> 
		</member>
		<member name="M:Indirect_SetMeta_" syntax="Indirect_SetMeta_(func, data)">
			<stacksize value="1"/>
			<dependency name="gsCodSize"/>
			<param name="func">
				The function pointer to attach metadata to.
			</param>
			<param name="data">
				The metadata.
			</param>
			   
		</member>
		<member name="M:Indirect_Tag" syntax="Indirect_Tag(id, dest[])">
			<stacksize value="6"/>
			<dependency name="GetTagNameFromID"/>
			<dependency name="strcat"/>
			<param name="id">
				The ID of the tag to get the specifiers from the name of.  
			</param>
			<param name="dest">
				<paraminfo> [32] </paraminfo>
				Where to store the name.
			</param>
			    <remarks>  Functions are tagged with a special tag containing their specifiers.  Get  the string value of that tag from the AMX header.  </remarks> 
		</member>
		<member name="M:Indirection_OnGameModeInit" syntax="Indirection_OnGameModeInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="pp_use_funcidx"/>
			<dependency name="true"/>
		</member>
		<member name="M:InitOpcodeTable" syntax="InitOpcodeTable()">
			<stacksize value="5"/>
			<referrer name="RelocateOpcode"/>
			<referrer name="UnrelocateOpcode"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="RelocateOpcodeNow"/>
			<dependency name="opcode_table"/>
			<dependency name="opcode_table_is_ready"/>
			<dependency name="true"/>
		</member>
		<member name="M:InterpolateColour" syntax="InterpolateColour(startcolor, endcolor, value, maxvalue, minvalue)">
			<stacksize value="3"/>
			<param name="startcolor">
				One of the two colours.
			</param>
			<param name="endcolor">
				The other of the two colours.
			</param>
			<param name="value">
				The interpolation value between the endpoints.
			</param>
			<param name="maxvalue">
				One of the two numbers.
			</param>
			<param name="minvalue">
				The other of the two numbers.
			</param>
			<summary>  InterpolateColour(startcolor, endcolor, value, maxvalue, minvalue = 0);  </summary>            <remarks>  This function takes two endpoint values (minvalue and maxvalue, with  minvalue defaulting to 0), along with a third value (value) whose distance  between the two endpoints is calculated (as a percentage).  This percentage  value is then applied to the two colours given to find a third colour at  some point between those two colours.  For example, if the endpoints given are "0" and "10", and the value given is  "3", then that is "30%" of the way between the two endpoints.  We therefore  want to find a colour that is 30% of the way between the two given colours.  </remarks> 
		</member>
		<member name="M:IsOpcodeValid" syntax="IsOpcodeValid(opcode)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="AsmEmitPadding"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:IsPlayerConnected" syntax="IsPlayerConnected(playerid)">
			<attribute name="native"/>
			<referrer name="AdvancedKick"/>
			<param name="playerid">
				The ID of the player to check
			</param>
			<summary>Checks if a player is connected (if an ID is taken by a connected player).</summary>  <seealso name="IsPlayerAdmin"/> <seealso name="OnPlayerConnect"/> <seealso name="OnPlayerDisconnect"/> <remarks>This function can be omitted in a lot of cases. Many other functions already have some sort of connection check built in.</remarks> <returns><b><c>1</c></b> if the player is connected, <b><c>0</c></b> if not.</returns>
		</member>
		<member name="M:IsPrintableAscii" syntax="IsPrintableAscii(c)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="ToPrintableAscii"/>
			<param name="c">
			</param>
		</member>
		<member name="M:IsTagIDEmpty" syntax="IsTagIDEmpty(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIDStrong" syntax="IsTagIDStrong(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="IsTagIndexStrong"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIDWeak" syntax="IsTagIDWeak(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="IsTagIndexWeak"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIndexEmpty" syntax="IsTagIndexEmpty(tag)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIndexStrong" syntax="IsTagIndexStrong(tag)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetTagInfo"/>
			<dependency name="IsTagIDStrong"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagIndexWeak" syntax="IsTagIndexWeak(tag)">
			<tagname value="bool"/>
			<stacksize value="7"/>
			<dependency name="AMX_FUNCSTUBNT"/>
			<dependency name="AMX_FUNCSTUBNT_ADDRESS"/>
			<dependency name="GetTagInfo"/>
			<dependency name="IsTagIDWeak"/>
			<param name="tag">
			</param>
		</member>
		<member name="M:IsTagNameEmpty" syntax="IsTagNameEmpty(tag[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:IsTagNameStrong" syntax="IsTagNameStrong(tag[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:IsTagNameWeak" syntax="IsTagNameWeak(tag[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="tag">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:K@" syntax="K@(function[], fmat[], ...)">
			<stacksize value="9"/>
			<dependency name="@_"/>
			<dependency name="K@"/>
			<dependency name="Q@"/>
			<dependency name="R@"/>
			<dependency name="W@"/>
			<dependency name="YSI_g_sCallData"/>
			<dependency name="YSI_g_sPropCaller"/>
			<dependency name="YSI_g_sPropEmpty"/>
			<dependency name="YSI_g_sPropVarArg"/>
			<dependency name="YSI_g_sYSIM_STRING"/>
			<dependency name="YSI_g_sYSI_MAX_STRING"/>
			<dependency name="getproperty"/>
			<dependency name="setarg"/>
			<dependency name="setproperty"/>
			<dependency name="strunpack"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Kick" syntax="Kick(playerid)">
			<attribute name="native"/>
			<referrer name="AK_Kick"/>
			<referrer name="AdvancedKick"/>
			<param name="playerid">
				The ID of the player to kick
			</param>
			<summary>Kicks a player from the server. They will have to quit the game and re-connect if they wish to continue playing.</summary>  <seealso name="Ban"/> <seealso name="BanEx"/> <remarks>As of <b>SA-MP 0.3x</b>, any action taken directly before Kick() (such as sending a message with <a href="#SendClientMessage">SendClientMessage</a>) will not reach the player. A timer must be used to delay the kick.</remarks> <returns>This function always returns <b><c>1</c></b>, even if the function failed to execute (player specified doesn't exist).</returns>
		</member>
		<member name="M:KickEx" syntax="KickEx(playerid, reason[], usecallback)">
			<stacksize value="13"/>
			<referrer name="AdvancedKick"/>
			<referrer name="Account_RegisterHandler"/>
			<referrer name="Account_EmailDialogHandler"/>
			<referrer name="Account_LoginDialog"/>
			<referrer name="OnPasswordChecked"/>
			<dependency name="AK_Kick"/>
			<dependency name="CallLocalFunction"/>
			<dependency name="KICK_SUCCESS"/>
			<dependency name="SendClientMessage"/>
			<param name="playerid">
			</param>
			<param name="reason">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="usecallback">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:L@" syntax="L@(ret, ...)">
			<stacksize value="8"/>
			<referrer name="@@_SetColoursCanHaveSpaces"/>
			<referrer name="@@_SetColourHash"/>
			<dependency name="YSI_g_sPropReturn"/>
			<dependency name="YSI_g_sPropVarArg"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<dependency name="setproperty"/>
			<param name="ret">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:LevenshteinDistance" syntax="LevenshteinDistance(a[], b[])">
			<stacksize value="9"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DoLevenshteinDistance"/>
			<dependency name="strcmp"/>
			<dependency name="strlen"/>
			<param name="a">
				<paraminfo> [] </paraminfo>
				First string to compare.
			</param>
			<param name="b">
				<paraminfo> [] </paraminfo>
				Second string to compare.
			</param>
			    <returns>  The levenshtein difference (0 if the same).  </returns> 
		</member>
		<member name="M:Mean" syntax="Mean(arr[], num)">
			<stacksize value="5"/>
			<dependency name="Sum"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical mean value of the array.  </returns> 
		</member>
		<member name="M:Median" syntax="Median(arr[], num)">
			<stacksize value="5"/>
			<dependency name="Utils_PreSort"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical median value of the array.  </returns> 
		</member>
		<member name="M:Misc_ReturnName" syntax="Misc_ReturnName(playerid)">
			<stacksize value="1"/>
			<referrer name="account_CheckIfExists"/>
			<referrer name="Account_RegisterHandler"/>
			<referrer name="Account_EmailDialogHandler"/>
			<referrer name="registerPlayer"/>
			<referrer name="Account_LoginDialog"/>
			<dependency name="GetPlayerName"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:Mode" syntax="Mode(arr[], num)">
			<stacksize value="6"/>
			<dependency name="Utils_PreSort"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical modal value of the array.  </returns> 
		</member>
		<member name="M:NtCompare" syntax="NtCompare(s1, s2[])">
			<stacksize value="8"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetTagIndexFromName"/>
			<dependency name="ReadAmxMemory"/>
			<param name="s1">
			</param>
			<param name="s2">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:NtCopy" syntax="NtCopy(src, dest[], size)">
			<stacksize value="6"/>
			<referrer name="GetPublicNameFromIndex"/>
			<referrer name="GetNativeNameFromIndex"/>
			<referrer name="GetPubVarNameFromIndex"/>
			<referrer name="GetTagNameFromIndex"/>
			<dependency name="ReadAmxMemory"/>
			<param name="src">
			</param>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:O@A_" syntax="O@A_()">
			<tagname value="bool"/>
			<stacksize value="11"/>
			<referrer name="AddressofResolve"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="DisasmInit"/>
			<dependency name="DisasmNext"/>
			<dependency name="GetCurrentFrameReturn"/>
			<dependency name="O@V_"/>
			<dependency name="OP_CALL"/>
			<dependency name="false"/>
		</member>
		<member name="M:OnActorStreamIn" syntax="OnActorStreamIn(actorid, forplayerid)">
			<stacksize value="1"/>
			<param name="actorid">
				The ID of the actor that has been streamed in for the player
			</param>
			<param name="forplayerid">
				The ID of the player that streamed the actor in
			</param>
			<summary>This callback is called when an actor is streamed in by a player's client.</summary>   <seealso name="OnActorStreamOut"/> <seealso name="OnPlayerStreamIn"/> <remarks>This function was added in <b>SA-MP 0.3.7</b> and will not work in earlier versions!</remarks> <remarks>This callback can also be called by NPC.</remarks> <remarks>It is always called first in filterscripts.</remarks> <returns>This callback does not handle returns.</returns>
		</member>
		<member name="M:OnActorStreamOut" syntax="OnActorStreamOut(actorid, forplayerid)">
			<stacksize value="1"/>
			<param name="actorid">
				The ID of the actor that has been streamed out for the player
			</param>
			<param name="forplayerid">
				The ID of the player that streamed the actor out
			</param>
			<summary>This callback is called when an actor is streamed out by a player's client.</summary>   <seealso name="OnActorStreamIn"/> <seealso name="OnPlayerStreamOut"/> <remarks>This function was added in <b>SA-MP 0.3.7</b> and will not work in earlier versions!</remarks> <remarks>This callback can also be called by NPC.</remarks> <remarks>It is always called first in filterscripts.</remarks> <returns>This callback does not handle returns.</returns>
		</member>
		<member name="M:OnCachedInit" syntax="OnCachedInit()">
			<stacksize value="1"/>
		</member>
		<member name="M:OnClientCheckResponse" syntax="OnClientCheckResponse(playerid, actionid, memaddr, retndata)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player checked
			</param>
			<param name="actionid">
				The type of check performed
			</param>
			<param name="memaddr">
				The address requested
			</param>
			<param name="retndata">
				The result of the check
			</param>
			<summary>This callback is called when a SendClientCheck request comletes</summary>     <seealso name="SendClientCheck"/>
		</member>
		<member name="M:OnDialogResponse" syntax="OnDialogResponse(playerid, dialogid, response, listitem, inputtext[])">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that responded to the dialog
			</param>
			<param name="dialogid">
				The ID of the dialog the player responded to, assigned in ShowPlayerDialog
			</param>
			<param name="response">
				<b><c>1</c></b> for left button and <b><c>0</c></b> for right button (if only one button shown, always <b><c>1</c></b>)
			</param>
			<param name="listitem">
				The ID of the list item selected by the player (starts at <b><c>0</c></b>) (only if using a list style dialog)
			</param>
			<param name="inputtext">
				<paraminfo> [] </paraminfo>
				The text entered into the input box by the player or the selected list item text
			</param>
			<summary>This callback is called when a player responds to a dialog shown using <a href="#ShowPlayerDialog">ShowPlayerDialog</a> by either clicking a button, pressing ENTER/ESC or double-clicking a list item (if using a list style dialog).</summary>      <seealso name="ShowPlayerDialog"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>A player's dialog doesn't hide when the gamemode restarts, causing the server to print <c>"Warning: PlayerDialogResponse PlayerId: 0 dialog ID doesn't match last sent dialog ID"</c> if a player responded to this dialog after restart.</remarks> <remarks>Parameters can contain different values, based on dialog's <a href="http://wiki.sa-mp.com/wiki/Dialog_Styles">style</a>.</remarks> <returns> Returning <b><c>0</c></b> in this callback will pass the dialog to another script in case no matching code were found in your gamemode's callback.<p/> It is always called first in filterscripts so returning <b><c>1</c></b> there blocks other filterscripts from seeing it. </returns>
		</member>
		<member name="M:OnEnterExitModShop" syntax="OnEnterExitModShop(playerid, enterexit, interiorid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that entered or exited the modshop
			</param>
			<param name="enterexit">
				<b><c>1</c></b> if the player entered or <b><c>0</c></b> if they exited
			</param>
			<param name="interiorid">
				The interior ID of the modshop that the player is entering (or 0 if exiting)
			</param>
			<summary>This callback is called when a player enters or exits a mod shop.</summary>    <seealso name="OnVehicleMod"/> <seealso name="OnVehicleRespray"/> <seealso name="OnVehiclePaintjob"/> <seealso name="AddVehicleComponent"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>Players collide when they get into the same mod shop.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnFilterScriptExit" syntax="OnFilterScriptExit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="ScriptInit_OnFilterScriptExit"/>
			<dependency name="ScriptInit_OnScriptExit"/>
			<dependency name="ScriptInit_PostExitFuncs_"/>
			<dependency name="ScriptInit_PreExitFuncs_"/>
			<dependency name="YSI_FILTERSCRIPT"/>
			<summary>This callback is called when a filterscript is unloaded. It is only called inside the filterscript which is unloaded.</summary> <seealso name="OnFilterScriptInit"/> <seealso name="OnGameModeInit"/> <seealso name="OnGameModeExit"/> <returns>This callback does not handle returns.</returns>
		</member>
		<member name="M:OnFilterScriptInit" syntax="OnFilterScriptInit()">
			<attribute name="public"/>
			<stacksize value="4"/>
			<dependency name="E_SCRIPTINIT_STATE_JITING"/>
			<dependency name="ScriptInit_CallOnCodeInit"/>
			<dependency name="ScriptInit_OnFilterScriptInit"/>
			<dependency name="ScriptInit_PostInitFuncs_"/>
			<dependency name="ScriptInit_PreInitFuncs_"/>
			<dependency name="YSI_FILTERSCRIPT"/>
			<dependency name="YSI_g_sScriptInitState"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<summary>This callback is called when a filterscript is initialized (loaded). It is only called inside the filterscript which is starting.</summary> <seealso name="OnFilterScriptExit"/> <seealso name="OnGameModeInit"/> <seealso name="OnGameModeExit"/> <returns>This callback does not handle returns.</returns><p/> <transition keep="true" target="_script_init_fix_state : true"/>  <transition keep="true" target="_ALS : _ALS_go"/>  <transition target="_ALS_go"/>

		</member>
		<member name="M:OnGameModeExit" syntax="OnGameModeExit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="ScriptInit_OnGameModeExit"/>
			<dependency name="ScriptInit_OnScriptExit"/>
			<dependency name="ScriptInit_PostExitFuncs_"/>
			<dependency name="ScriptInit_PreExitFuncs_"/>
			<dependency name="YSI_FILTERSCRIPT"/>
			<summary>This callback is called when a gamemode ends, either through 'gmx', the server being shut down, or <a href="#GameModeExit">GameModeExit</a>.</summary> <seealso name="OnGameModeInit"/> <seealso name="OnFilterScriptExit"/> <seealso name="OnFilterScriptInit"/> <seealso name="GameModeExit"/> <remarks>This function can also be used in a filterscript to detect if the gamemode changes with RCON commands like changemode or gmx, as changing the gamemode does not reload a filterscript.</remarks> <remarks>When using OnGameModeExit in conjunction with the 'rcon gmx' console command keep in mind there is a potential for client bugs to occur an example of this is excessive <a href="#RemoveBuildingForPlayer">RemoveBuildingForPlayer</a> calls during OnGameModeInit which could result in a client crash. </remarks> <remarks>This callback will NOT be called if the server crashes or the process is killed by other means, such as using the Linux kill command or pressing the close-button on the Windows console. </remarks> <returns> <b><c>0</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>1</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in gamemode. </returns>
		</member>
		<member name="M:OnGameModeInit" syntax="OnGameModeInit()">
			<attribute name="public"/>
			<stacksize value="4"/>
			<dependency name="E_SCRIPTINIT_STATE_JITING"/>
			<dependency name="ScriptInit_CallOnCodeInit"/>
			<dependency name="ScriptInit_OnGameModeInit"/>
			<dependency name="ScriptInit_PostInitFuncs_"/>
			<dependency name="ScriptInit_PreInitFuncs_"/>
			<dependency name="YSI_FILTERSCRIPT"/>
			<dependency name="YSI_g_sScriptInitState"/>
			<dependency name="false"/>
			<summary>This callback is triggered when the gamemode starts.</summary> <seealso name="OnGameModeExit"/> <seealso name="OnFilterScriptInit"/> <seealso name="OnFilterScriptExit"/> <remarks>This function can also be used in a filterscript to detect if the gamemode changes with RCON commands like changemode or gmx, as changing the gamemode does not reload a filterscript.</remarks> <returns> <b><c>0</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>1</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in gamemode. </returns><p/> <transition keep="true" target="_script_init_fix_state : false"/>  <transition keep="true" target="_ALS : _ALS_go"/>  <transition target="_ALS_go"/>

		</member>
		<member name="M:OnIncomingConnection" syntax="OnIncomingConnection(playerid, ip_address[], port)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player attempting to connect
			</param>
			<param name="ip_address">
				<paraminfo> [] </paraminfo>
				The IP address of the player attempting to connect
			</param>
			<param name="port">
				The port of the attempted connection
			</param>
			<summary>This callback is called when an IP address attempts a connection to the server. To block incoming connections, use <a href="#BlockIpAddress">BlockIpAddress</a>.</summary>    <seealso name="OnPlayerConnect"/> <seealso name="OnPlayerDisconnect"/> <seealso name="OnPlayerFinishedDownloading"/> <seealso name="BlockIpAddress"/> <seealso name="UnBlockIpAddress"/> <remarks> 	This callback was added in <b>SA-MP 0.3z R2-2</b> and will not work in earlier versions!</remarks> <returns> <b><c>1</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>0</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnJITCompile" syntax="OnJITCompile()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_SCRIPTINIT_STATE_JITED"/>
			<dependency name="E_SCRIPTINIT_STATE_JITING"/>
			<dependency name="ScriptInit_CallOnCodeInit"/>
			<dependency name="ScriptInit_OnJITCompile"/>
			<dependency name="YSI_g_sScriptInitState"/>
			<dependency name="true"/>
			<transition target="_ALS_go"/>

		</member>
		<member name="M:OnObjectMoved" syntax="OnObjectMoved(objectid)">
			<stacksize value="1"/>
			<param name="objectid">
				The ID of the object that was moved
			</param>
			<summary>This callback is called when an object is moved after <a href="#MoveObject">MoveObject</a> (when it stops moving).</summary>  <seealso name="MoveObject"/> <seealso name="IsObjectMoving"/> <seealso name="StopObject"/> <seealso name="OnPlayerObjectMoved"/> <remarks><a href="#SetObjectPos">SetObjectPos</a> does not work when used in this callback. To fix it, recreate the object.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPasswordChecked" syntax="OnPasswordChecked(playerid)">
			<attribute name="public"/>
			<stacksize value="16"/>
			<dependency name="Account_LoginDialog"/>
			<dependency name="Account_ReturnLoginAttempts"/>
			<dependency name="Account_SetLoginAttempts"/>
			<dependency name="Account_SetPassword"/>
			<dependency name="KickEx"/>
			<dependency name="SetSpawnInfo"/>
			<dependency name="SpawnPlayer"/>
			<dependency name="TogglePlayerSpectating"/>
			<dependency name="bcrypt_is_equal"/>
			<dependency name="false"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPasswordHashed" syntax="OnPasswordHashed(playerid)">
			<attribute name="public"/>
			<stacksize value="66"/>
			<dependency name="Account_EmailDialogHandler"/>
			<dependency name="Account_SetPassword"/>
			<dependency name="bcrypt_get_hash"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerAccountChecked" syntax="OnPlayerAccountChecked(playerid)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<dependency name="Account_LoginDialog"/>
			<dependency name="Account_RegisterHandler"/>
			<dependency name="Account_SetEmail"/>
			<dependency name="Account_SetPassword"/>
			<dependency name="TogglePlayerSpectating"/>
			<dependency name="cache_get_value_name"/>
			<dependency name="cache_num_rows"/>
			<dependency name="true"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerClickMap" syntax="OnPlayerClickMap(playerid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that placed a target/waypoint
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
				The X float coordinate where the player clicked
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
				The Y float coordinate where the player clicked
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
				The Z float coordinate where the player clicked (inaccurate - see note below)
			</param>
			<summary>OnPlayerClickMap is called when a player places a target/waypoint on the pause menu map (by right-clicking).</summary>     <seealso name="SetPlayerPos"/> <seealso name="SetPlayerPosFindZ"/> <seealso name="GetPlayerPos"/> <remarks>This callback was added in <b>SA-MP 0.3d</b> and will not work in earlier versions!</remarks> <remarks>The Z value returned will be <b><c>0</c></b> (invalid) if it is far away from the player; use the <a href="http://forum.sa-mp.com/showthread.php?t=275492">MapAndreas plugin</a> to get a more accurate Z coordinate.</remarks> <returns> <b><c>1</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>0</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in gamemode. </returns>
		</member>
		<member name="M:OnPlayerClickPlayer" syntax="OnPlayerClickPlayer(playerid, clickedplayerid, source)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that clicked on a player on the scoreboard
			</param>
			<param name="clickedplayerid">
				The ID of the player that was clicked on
			</param>
			<param name="source">
				The source of the player's click
			</param>
			<summary>Called when a player double-clicks on a player on the scoreboard.</summary>    <seealso name="OnPlayerClickTextDraw"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>There is currently only one <paramref name="source"/> (<b><c>0 - CLICK_SOURCE_SCOREBOARD</c></b>). The existence of this argument suggests that more sources may be supported in the future.</remarks> <returns> <b><c>1</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>0</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerClickPlayerTextDraw" syntax="OnPlayerClickPlayerTextDraw(playerid, playertextid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that selected a textdraw
			</param>
			<param name="playertextid">
				<paraminfo>PlayerText </paraminfo>
				The ID of the player-textdraw that the player selected
			</param>
			<summary>This callback is called when a player clicks on a player-textdraw. It is not called when player cancels the select mode (ESC) - however, <a href="#OnPlayerClickTextDraw">OnPlayerClickTextDraw</a> is.</summary>   <seealso name="PlayerTextDrawSetSelectable"/> <seealso name="OnPlayerClickTextDraw"/> <seealso name="OnPlayerClickPlayer"/> <remarks>This callback was added in <b>SA-MP 0.3e</b> and will not work in earlier versions!</remarks> <remarks>When a player presses ESC to cancel selecting a textdraw, <a href="#OnPlayerClickTextDraw">OnPlayerClickTextDraw</a> is called with a textdraw ID of <b><c>INVALID_TEXT_DRAW</c></b>. <a href="#OnPlayerClickPlayerTextDraw">OnPlayerClickPlayerTextDraw</a> won't be called also.</remarks> <returns> Returning <b><c>1</c></b> in this callback will prevent it being called in other scripts. This should be used to signal that the textdraw on which they clicked was 'found' and no further processing is needed. You should return <b><c>0</c></b> if the textdraw on which they clicked wasn't found, just like in <a href="#OnPlayerCommandText">OnPlayerCommandText</a>.<p/> It is always called first in filterscripts so returning <b><c>1</c></b> there also blocks other scripts from seeing it. </returns>
		</member>
		<member name="M:OnPlayerClickTextDraw" syntax="OnPlayerClickTextDraw(playerid, clickedid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that clicked on the textdraw
			</param>
			<param name="clickedid">
				<paraminfo>Text </paraminfo>
				The ID of the clicked textdraw. <b><c>INVALID_TEXT_DRAW</c></b> if selection was cancelled
			</param>
			<summary>This callback is called when a player clicks on a textdraw or cancels the select mode with the Escape key.</summary>   <seealso name="OnPlayerClickPlayerTextDraw"/> <seealso name="OnPlayerClickPlayer"/> <remarks>This callback was added in <b>SA-MP 0.3e</b> and will not work in earlier versions!</remarks> <remarks>The clickable area is defined by <a href="#TextDrawTextSize">TextDrawTextSize</a>. The x and y parameters passed to that function must not be zero or negative. </remarks> <remarks>Do not use <a href="#CancelSelectTextDraw">CancelSelectTextDraw</a> unconditionally within this callback. This results in an infinite loop. </remarks> <returns> Returning <b><c>1</c></b> in this callback will prevent it being called in other scripts. This should be used to signal that the textdraw on which they clicked was 'found' and no further processing is needed. You should return <b><c>0</c></b> if the textdraw on which they clicked wasn't found, just like in <a href="#OnPlayerCommandText">OnPlayerCommandText</a>.<p/> It is always called first in filterscripts so returning <b><c>1</c></b> there also blocks other scripts from seeing it. </returns>
		</member>
		<member name="M:OnPlayerCommandText" syntax="OnPlayerCommandText(playerid, cmdtext[])">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that entered a command
			</param>
			<param name="cmdtext">
				<paraminfo> [] </paraminfo>
				The command that was entered (including the forward slash)
			</param>
			<summary>This callback is called when a player enters a command into the client chat window. Commands are anything that start with a forward slash, e.g. <c>/help</c>.</summary>   <seealso name="OnPlayerText"/> <seealso name="OnRconCommand"/> <seealso name="SendRconCommand"/> <remarks>This callback can also be called by NPC.</remarks> <returns> Return <b><c>1</c></b> if the command was processed, otherwise <b><c>0</c></b>; If the command was not found both in filterscripts and in gamemode, the player will be received a message: <em>SERVER: Unknown command</em>.<p/> It is always called first in filterscripts so returning <b><c>1</c></b> there blocks other scripts from seeing it. </returns>
		</member>
		<member name="M:OnPlayerConnect" syntax="OnPlayerConnect(playerid)">
			<attribute name="public"/>
			<stacksize value="21"/>
			<dependency name="GetPlayerIp"/>
			<dependency name="IPToInt"/>
			<dependency name="YSI_gPlayerIP"/>
			<param name="playerid">
				The ID of the player that connected
			</param>
			<summary>This callback is called when a player connects to the server.</summary>  <seealso name="OnPlayerDisconnect"/> <seealso name="OnIncomingConnection"/> <seealso name="OnPlayerFinishedDownloading"/> <remarks>This callback can also be called by NPC.</remarks> <returns> <b><c>0</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>1</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerDeath" syntax="OnPlayerDeath(playerid, killerid, reason)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that died
			</param>
			<param name="killerid">
				The ID of the player that killed the player who died, or <b><c>INVALID_PLAYER_ID</c></b> if there was none
			</param>
			<param name="reason">
				The ID of the <a href="http://wiki.sa-mp.com/wiki/Weapons">reason</a> for the player's death
			</param>
			<summary>This callback is called when a player dies, either by suicide or by being killed by another player.</summary>    <seealso name="OnPlayerSpawn"/> <seealso name="SendDeathMessage"/> <seealso name="SetPlayerHealth"/> <remarks> The reason will return 37 (flame thrower) from any fire sources (e.g. molotov, 18)<p/> The reason will return 51 from any weapon that creates an explosion (e.g. RPG, grenade)<p/> You do not need to check whether killerid is valid before using it in <a href="#SendDeathMessage">SendDeathMessage</a>. <b><c>INVALID_PLAYER_ID</c></b> is a valid killerid ID parameter in that function.<p/> <b>playerid</b> is the only one who can call the callback. (good to know for anti fake death) </remarks> <returns> <b><c>0</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>1</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerDisconnect" syntax="OnPlayerDisconnect(playerid, reason)">
			<attribute name="public"/>
			<stacksize value="1"/>
			<dependency name="YSI_gPlayerIP"/>
			<param name="playerid">
				The ID of the player that disconnected
			</param>
			<param name="reason">
				The reason for the disconnection. See table below
			</param>
			<summary>This callback is called when a player disconnects from the server.</summary>   <seealso name="OnPlayerConnect"/> <seealso name="OnIncomingConnection"/> <seealso name="OnPlayerFinishedDownloading"/> <remarks>This callback can also be called by NPC.</remarks> <remarks>Some functions might not work correctly when used in this callback because the player is already disconnected when the callback is called. This means that you can't get unambiguous information from functions like <a href="#GetPlayerIp">GetPlayerIp</a> and <a href="#GetPlayerPos">GetPlayerPos</a>.</remarks> <remarks> <b>Reasons:</b><p/> <ul> <li><b><c>0</c></b> - timeout/Crash - the player's connection was lost. Either their game crashed or their network had a fault.</li> <li><b><c>1</c></b> - quit - the player purposefully quit, either using the <b><c>/quit (/q)</c></b> command or via the pause menu.</li> <li><b><c>2</c></b> - kick/ban - the player was kicked or banned by the server.</li> </ul> </remarks> <returns> <b><c>0</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>1</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerEditAttachedObject" syntax="OnPlayerEditAttachedObject(playerid, response, index, modelid, boneid, fOffsetX, fOffsetY, fOffsetZ, fRotX, fRotY, fRotZ, fScaleX, fScaleY, fScaleZ)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that ended edition mode
			</param>
			<param name="response">
				<b><c>0</c></b> if they cancelled (ESC) or <b><c>1</c></b> if they clicked the save icon
			</param>
			<param name="index">
				The index of the attached object
			</param>
			<param name="modelid">
				The model of the attached object that was edited
			</param>
			<param name="boneid">
				The bone of the attached object that was edited
			</param>
			<param name="fOffsetX">
				<paraminfo>Float </paraminfo>
				The X offset for the attached object that was edited
			</param>
			<param name="fOffsetY">
				<paraminfo>Float </paraminfo>
				The Y offset for the attached object that was edited
			</param>
			<param name="fOffsetZ">
				<paraminfo>Float </paraminfo>
				The Z offset for the attached object that was edited
			</param>
			<param name="fRotX">
				<paraminfo>Float </paraminfo>
				The X rotation for the attached object that was edited
			</param>
			<param name="fRotY">
				<paraminfo>Float </paraminfo>
				The Y rotation for the attached object that was edited
			</param>
			<param name="fRotZ">
				<paraminfo>Float </paraminfo>
				The Z rotation for the attached object that was edited
			</param>
			<param name="fScaleX">
				<paraminfo>Float </paraminfo>
				The X scale for the attached object that was edited
			</param>
			<param name="fScaleY">
				<paraminfo>Float </paraminfo>
				The Y scale for the attached object that was edited
			</param>
			<param name="fScaleZ">
				<paraminfo>Float </paraminfo>
				The Z scale for the attached object that was edited
			</param>
			<summary>This callback is called when a player ends attached object edition mode.</summary>               <seealso name="EditAttachedObject"/> <seealso name="SetPlayerAttachedObject"/> <remarks>This callback was added in <b>SA-MP 0.3e</b> and will not work in earlier versions!</remarks> <remarks>Editions should be discarded if response was <b><c>0</c></b> (cancelled). This must be done by storing the offsets etc. in an array BEFORE using <a href="#EditAttachedObject">EditAttachedObject</a>.</remarks> <returns> <b><c>1</c></b> - Will prevent other scripts from receiving this callback.<p/> <b><c>0</c></b> - Indicates that this callback will be passed to the next script.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerEditObject" syntax="OnPlayerEditObject(playerid, playerobject, objectid, response, fX, fY, fZ, fRotX, fRotY, fRotZ)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that edited an object
			</param>
			<param name="playerobject">
				<b><c>0</c></b> if it is a global object or <b><c>1</c></b> if it is a playerobject
			</param>
			<param name="objectid">
				The ID of the edited object
			</param>
			<param name="response">
				The type of response
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
				The X offset for the object that was edited
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
				The Y offset for the object that was edited
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
				The Z offset for the object that was edited
			</param>
			<param name="fRotX">
				<paraminfo>Float </paraminfo>
				The X rotation for the object that was edited
			</param>
			<param name="fRotY">
				<paraminfo>Float </paraminfo>
				The Y rotation for the object that was edited
			</param>
			<param name="fRotZ">
				<paraminfo>Float </paraminfo>
				The Z rotation for the object that was edited
			</param>
			<summary>This callback is called when a player finishes editing an object (<a href="#EditObject">EditObject</a>/<a href="#EditPlayerObject">EditPlayerObject</a>).</summary>           <seealso name="EditObject"/> <seealso name="CreateObject"/> <seealso name="DestroyObject"/> <seealso name="MoveObject"/> <remarks>This callback was added in <b>SA-MP 0.3e</b> and will not work in earlier versions!</remarks> <remarks>When using <b><c>EDIT_RESPONSE_UPDATE</c></b> be aware that this callback will not be called when releasing an edit in progress resulting in the last update of <b><c>EDIT_RESPONSE_UPDATE</c></b> being out of sync of the objects current position.</remarks> <returns> <b><c>1</c></b> - Will prevent other scripts from receiving this callback.<p/> <b><c>0</c></b> - Indicates that this callback will be passed to the next script.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerEnterCheckpoint" syntax="OnPlayerEnterCheckpoint(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The player who entered the checkpoint
			</param>
			<summary>This callback is called when a player enters the checkpoint set for that player.</summary>  <seealso name="OnPlayerLeaveCheckpoint"/> <seealso name="OnPlayerEnterRaceCheckpoint"/> <seealso name="OnPlayerLeaveRaceCheckpoint"/> <seealso name="SetPlayerCheckpoint"/> <seealso name="DisablePlayerCheckpoint"/> <seealso name="IsPlayerInCheckpoint"/> <seealso name="SetPlayerRaceCheckpoint"/> <seealso name="DisablePlayerRaceCheckpoint"/> <seealso name="IsPlayerInRaceCheckpoint"/> <remarks>This callback can also be called by NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerEnterRaceCheckpoint" syntax="OnPlayerEnterRaceCheckpoint(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player who entered the race checkpoint
			</param>
			<summary>This callback is called when a player enters a race checkpoint.</summary>  <seealso name="OnPlayerEnterCheckpoint"/> <seealso name="OnPlayerLeaveCheckpoint"/> <seealso name="OnPlayerLeaveRaceCheckpoint"/> <seealso name="SetPlayerCheckpoint"/> <seealso name="DisablePlayerCheckpoint"/> <seealso name="IsPlayerInCheckpoint"/> <seealso name="SetPlayerRaceCheckpoint"/> <seealso name="DisablePlayerRaceCheckpoint"/> <seealso name="IsPlayerInRaceCheckpoint"/> <remarks>This callback can also be called by NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerEnterVehicle" syntax="OnPlayerEnterVehicle(playerid, vehicleid, ispassenger)">
			<stacksize value="1"/>
			<param name="playerid">
				ID of the player who attempts to enter a vehicle
			</param>
			<param name="vehicleid">
				ID of the vehicle the player is attempting to enter
			</param>
			<param name="ispassenger">
				<b><c>0</c></b> if entering as driver. <b><c>1</c></b> if entering as passenger
			</param>
			<summary>This callback is called when a player <b><c>starts</c></b> to enter a vehicle, meaning the player is not in vehicle yet at the time this callback is called.</summary>    <seealso name="OnPlayerExitVehicle"/> <seealso name="OnPlayerStateChange"/> <seealso name="PutPlayerInVehicle"/> <seealso name="GetPlayerVehicleSeat"/> <remarks>This callback is called when a player <b>BEGINS</b> to enter a vehicle, not when they HAVE entered it. See <a href="#OnPlayerStateChange">OnPlayerStateChange</a>. </remarks> <remarks>This callback is still called if the player is denied entry to the vehicle (e.g. it is locked or full). </remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerExitVehicle" syntax="OnPlayerExitVehicle(playerid, vehicleid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that is exiting a vehicle
			</param>
			<param name="vehicleid">
				The ID of the vehicle the player is exiting
			</param>
			<summary>This callback is called when a player <b>starts</b> to exit a vehicle.</summary>   <seealso name="OnPlayerEnterVehicle"/> <seealso name="OnPlayerStateChange"/> <seealso name="RemovePlayerFromVehicle"/> <seealso name="GetPlayerVehicleSeat"/> <remarks>Not called if the player falls off a bike or is removed from a vehicle by other means such as using <a href="#SetPlayerPos">SetPlayerPos</a>.</remarks> <remarks>You must use <a href="#OnPlayerStateChange">OnPlayerStateChange</a> and check if their old state is <b><c>PLAYER_STATE_DRIVER</c></b> or <b><c>PLAYER_STATE_PASSENGER</c></b> and their new state is <b><c>PLAYER_STATE_ONFOOT</c></b>.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerExitedMenu" syntax="OnPlayerExitedMenu(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that exited the menu
			</param>
			<summary>Called when a player exits a menu.</summary>  <seealso name="OnPlayerSelectedMenuRow"/> <seealso name="CreateMenu"/> <seealso name="DestroyMenu"/> <returns> This callback does not handle returns.<p/> It is always called first in gamemode. </returns>
		</member>
		<member name="M:OnPlayerFinishedDownloading" syntax="OnPlayerFinishedDownloading(playerid, virtualworld)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that finished downloading custom models
			</param>
			<param name="virtualworld">
				The ID of the virtual world the player finished downloading custom models for
			</param>
			<summary>This callback is called when a player finishes downloading custom models. For more information on how to add custom models to your server, see <a href="http://forum.sa-mp.com/showthread.php?t=644105">the release thread</a> and <a href="http://forum.sa-mp.com/showthread.php?t=644123">this tutorial</a>.</summary>   <seealso name="OnPlayerConnect"/> <seealso name="OnPlayerDisconnect"/> <seealso name="OnIncomingConnection"/> <remarks>This callback was added in <b>SA-MP 0.3DL</b> and will not work in earlier versions!</remarks> <remarks>This callback is called every time a player changes virtual worlds, even if there are no custom models present in that world.</remarks> <returns>This callback does not handle returns.</returns>
		</member>
		<member name="M:OnPlayerGiveDamage" syntax="OnPlayerGiveDamage(playerid, damagedid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that gave damage
			</param>
			<param name="damagedid">
				The ID of the player that received damage
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
				The amount of health/armour damagedid has lost (combined)
			</param>
			<param name="weaponid">
				The <a href="http://wiki.sa-mp.com/wiki/Weapons">reason</a> that caused the damage
			</param>
			<param name="bodypart">
				The body part that was hit. (NOTE: This parameter was added in <b>0.3z</b>. Leave it out if using an older version!)
			</param>
			<summary>This callback is called when a player gives damage to another player.</summary>      <seealso name="OnPlayerTakeDamage"/> <remarks>This callback was added in <b>SA-MP 0.3d</b> and will not work in earlier versions!</remarks> <remarks> Keep in mind this function can be inaccurate in some cases.<p/> If you want to prevent certain players from damaging eachother, use <a href="#SetPlayerTeam">SetPlayerTeam</a>.<p/> The weaponid will return <b><c>37</c></b> (flame thrower) from any fire sources (e.g. molotov, 18)<p/> The weaponid will return <b><c>51</c></b> from any weapon that creates an explosion (e.g. RPG, grenade)<p/> <b>playerid</b> is the only one who can call the callback.<p/> The amount is always the maximum damage the weaponid can do, even when the health left is less than that maximum damage. So when a player has <b><c>100.0</c></b> health and gets shot with a Desert Eagle which has a damage value of <b><c>46.2</c></b>, it takes 3 shots to kill that player. All 3 shots will show an amount of <b><c>46.2</c></b>, even though when the last shot hits, the player only has <b><c>7.6</c></b> health left. </remarks> <returns> <b><c>1</c></b> - Callback will not be called in other filterscripts.<p/> <b><c>0</c></b> - Allows this callback to be called in other filterscripts.<p/> It is always called first in filterscripts so returning <b><c>1</c></b> there blocks other filterscripts from seeing it. </returns>
		</member>
		<member name="M:OnPlayerGiveDamageActor" syntax="OnPlayerGiveDamageActor(playerid, damaged_actorid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that gave damage
			</param>
			<param name="damaged_actorid">
				The ID of the actor that received damage
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
				The amount of health/armour damaged_actorid has lost
			</param>
			<param name="weaponid">
				The reason that caused the damage
			</param>
			<param name="bodypart">
				The body part that was hit
			</param>
			<summary>This callback is called when a player gives damage to an actor.</summary>      <seealso name="CreateActor"/> <seealso name="SetActorInvulnerable"/> <seealso name="SetActorHealth"/> <seealso name="GetActorHealth"/> <seealso name="IsActorInvulnerable"/> <seealso name="IsValidActor"/> <seealso name="OnActorStreamOut"/> <seealso name="OnPlayerStreamIn"/> <remarks>This callback was added in <b>SA-MP 0.3.7</b> and will not work in earlier versions!</remarks> <remarks>This function does not get called if the actor is set invulnerable (WHICH IS BY DEFAULT). See <a href="#SetActorInvulnerable">SetActorInvulnerable</a>.</remarks> <returns> <b><c>1</c></b> - Callback will not be called in other filterscripts.<p/> <b><c>0</c></b> - Allows this callback to be called in other filterscripts.<p/> It is always called first in filterscripts so returning <b><c>1</c></b> there blocks other filterscripts from seeing it. </returns>
		</member>
		<member name="M:OnPlayerInteriorChange" syntax="OnPlayerInteriorChange(playerid, newinteriorid, oldinteriorid)">
			<stacksize value="1"/>
			<param name="playerid">
				The playerid who changed interior
			</param>
			<param name="newinteriorid">
				The interior the player is now in
			</param>
			<param name="oldinteriorid">
				The interior the player was in before
			</param>
			<summary>Called when a player changes interior. Can be triggered by SetPlayerInterior or when a player enter/exits a building.</summary>    <seealso name="SetPlayerInterior"/> <seealso name="GetPlayerInterior"/> <seealso name="LinkVehicleToInterior"/> <seealso name="OnPlayerStateChange"/> <returns> This callback does not handle returns.<p/> It is always called first in gamemode. </returns>
		</member>
		<member name="M:OnPlayerKeyStateChange" syntax="OnPlayerKeyStateChange(playerid, newkeys, oldkeys)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that pressed or released a key
			</param>
			<param name="newkeys">
				A map (bitmask) of the keys currently held - see <a href="http://wiki.sa-mp.com/wiki/Keys">here</a>
			</param>
			<param name="oldkeys">
				A map (bitmask) of the keys held prior to the current change - see <a href="http://wiki.sa-mp.com/wiki/Keys">here</a>
			</param>
			<summary>This callback is called when the state of any supported key is changed (pressed/released). Directional keys do not trigger OnPlayerKeyStateChange (up/down/left/right).</summary>    <seealso name="GetPlayerKeys"/> <remarks>This callback can also be called by NPC.</remarks> <remarks> Useful macros:<p/> <code> // HOLDING(keys)<p/> #define HOLDING(%0) ((newkeys &amp; (%0)) == (%0))<p/> <p/> // PRESSED(keys)<p/> #define PRESSED(%0) (((newkeys &amp; (%0)) == (%0)) &amp;&amp; ((oldkeys &amp; (%0)) != (%0)))<p/> <p/> // PRESSING(keyVariable, keys)<p/> #define PRESSING(%0,%1) (%0 &amp; (%1))<p/> <p/> // RELEASED(keys)<p/> #define RELEASED(%0) (((newkeys &amp; (%0)) != (%0)) &amp;&amp; ((oldkeys &amp; (%0)) == (%0)))<p/> </code> </remarks> <returns> This callback does not handle returns.<p/> It is always called first in gamemode. </returns>
		</member>
		<member name="M:OnPlayerKicked" syntax="OnPlayerKicked(playerid, kickerid, reason[], time, responselevel)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="kickerid">
			</param>
			<param name="reason">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="time">
			</param>
			<param name="responselevel">
			</param>
			PawnPlus v1.3.1 by IllidanS4 *
		</member>
		<member name="M:OnPlayerLeaveCheckpoint" syntax="OnPlayerLeaveCheckpoint(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that left their checkpoint
			</param>
			<summary>This callback is called when a player leaves the checkpoint set for them by <a href="#SetPlayerCheckpoint">SetPlayerCheckpoint</a>. Only one checkpoint can be set at a time.</summary>  <seealso name="OnPlayerEnterCheckpoint"/> <seealso name="OnPlayerEnterRaceCheckpoint"/> <seealso name="OnPlayerLeaveRaceCheckpoint"/> <seealso name="SetPlayerCheckpoint"/> <seealso name="DisablePlayerCheckpoint"/> <seealso name="IsPlayerInCheckpoint"/> <seealso name="SetPlayerRaceCheckpoint"/> <seealso name="DisablePlayerRaceCheckpoint"/> <seealso name="IsPlayerInRaceCheckpoint"/> <remarks>This callback can also be called by NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerLeaveRaceCheckpoint" syntax="OnPlayerLeaveRaceCheckpoint(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that left the race checkpoint
			</param>
			<summary>This callback is called when a player leaves the race checkpoint.</summary>  <seealso name="OnPlayerEnterCheckpoint"/> <seealso name="OnPlayerLeaveCheckpoint"/> <seealso name="OnPlayerEnterRaceCheckpoint"/> <seealso name="SetPlayerCheckpoint"/> <seealso name="DisablePlayerCheckpoint"/> <seealso name="IsPlayerInCheckpoint"/> <seealso name="SetPlayerRaceCheckpoint"/> <seealso name="DisablePlayerRaceCheckpoint"/> <seealso name="IsPlayerInRaceCheckpoint"/> <remarks>This callback can also be called by NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerObjectMoved" syntax="OnPlayerObjectMoved(playerid, objectid)">
			<stacksize value="1"/>
			<param name="playerid">
				The playerid the object is assigned to
			</param>
			<param name="objectid">
				The ID of the player object that was moved
			</param>
			<summary>This callback is called when a player object is moved after <a href="#MovePlayerObject">MovePlayerObject</a> (when it stops moving).</summary>   <seealso name="OnObjectMoved"/> <seealso name="MovePlayerObject"/> <seealso name="IsPlayerObjectMoving"/> <seealso name="StopPlayerObject"/> <remarks>This callback can also be called for NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerPickUpPickup" syntax="OnPlayerPickUpPickup(playerid, pickupid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that picked up the pickup
			</param>
			<param name="pickupid">
				The ID of the pickup, returned by CreatePickup
			</param>
			<summary>Called when a player picks up a pickup created with <a href="#CreatePickup">CreatePickup</a>.</summary>   <seealso name="CreatePickup"/> <seealso name="DestroyPickup"/> <returns> This callback does not handle returns.<p/> It is always called first in gamemode. </returns>
		</member>
		<member name="M:OnPlayerRegister" syntax="OnPlayerRegister(playerid)">
			<attribute name="public"/>
			<stacksize value="15"/>
			<dependency name="Account_SetID"/>
			<dependency name="SetSpawnInfo"/>
			<dependency name="SpawnPlayer"/>
			<dependency name="TogglePlayerSpectating"/>
			<dependency name="cache_insert_id"/>
			<dependency name="false"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:OnPlayerRequestClass" syntax="OnPlayerRequestClass(playerid, classid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that changed class
			</param>
			<param name="classid">
				The ID of the current class being viewed (returned by <a href="#AddPlayerClass">AddPlayerClass</a>)
			</param>
			<summary>Called when a player changes class at class selection (and when class selection first appears).</summary>   <seealso name="OnPlayerRequestSpawn"/> <seealso name="AddPlayerClass"/> <remarks>This callback can also be called by NPC.</remarks> <remarks>This callback is also called when a player presses <b>F4</b>.</remarks> <returns> Returning <b><c>0</c></b> in this callback will prevent the player from spawning. The player can be forced to spawn when <a href="#SpawnPlayer">SpawnPlayer</a> is used.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerRequestDownload" syntax="OnPlayerRequestDownload(playerid, type, crc)">
			<stacksize value="1"/>
			<param name="playerid">
			</param>
			<param name="type">
			</param>
			<param name="crc">
			</param>
		</member>
		<member name="M:OnPlayerRequestSpawn" syntax="OnPlayerRequestSpawn(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that requested to spawn
			</param>
			<summary>Called when a player attempts to spawn via class selection either by pressing SHIFT or clicking the 'Spawn' button.</summary>  <seealso name="OnPlayerSpawn"/> <seealso name="OnPlayerRequestClass"/> <remarks>This callback can also be called by NPC.</remarks> <remarks>To prevent players from spawning with certain classes, the last viewed class must be saved in a variable in <a href="#OnPlayerRequestClass">OnPlayerRequestClass</a>.</remarks> <returns> Returning <b><c>0</c></b> in this callback will prevent the player from spawning.<p/> It is always called first in filterscripts so returning <b><c>0</c></b> there also blocks other scripts from seeing it. </returns>
		</member>
		<member name="M:OnPlayerSelectObject" syntax="OnPlayerSelectObject(playerid, type, objectid, modelid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that selected an object
			</param>
			<param name="type">
				The type of selection
			</param>
			<param name="objectid">
				The ID of the selected object
			</param>
			<param name="modelid">
				The model ID of the selected object
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
				The X position of the selected object
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
				The Y position of the selected object
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
				The Z position of the selected object
			</param>
			<summary>This callback is called when a player selects an object after <a href="#SelectObject">SelectObject</a> has been used.</summary>        <seealso name="SelectObject"/> <remarks>This function was added in <b>SA-MP 0.3e</b> and will not work in earlier versions!</remarks> <returns> <b><c>1</c></b> - Will prevent other scripts from receiving this callback.<p/> <b><c>0</c></b> - Indicates that this callback will be passed to the next script.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerSelectedMenuRow" syntax="OnPlayerSelectedMenuRow(playerid, row)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that selected a menu item
			</param>
			<param name="row">
				The ID of the row that was selected. The first row is ID <b><c>0</c></b>
			</param>
			<summary>This callback is called when a player selects an item from a menu (<a href="#ShowMenuForPlayer">ShowMenuForPlayer</a>).</summary>   <seealso name="OnPlayerExitedMenu"/> <seealso name="OnDialogResponse"/> <seealso name="CreateMenu"/> <seealso name="DestroyMenu"/> <seealso name="AddMenuItem"/> <seealso name="ShowMenuForPlayer"/> <seealso name="HideMenuForPlayer"/> <remarks>The menu ID is not passed to this callback. <a href="#GetPlayerMenu">GetPlayerMenu</a> must be used to determine which menu the player selected an item on.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in gamemode. </returns>
		</member>
		<member name="M:OnPlayerSpawn" syntax="OnPlayerSpawn(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that spawned
			</param>
			<summary>This callback is called when a player spawns.(i.e. after caling <a href="#SpawnPlayer">SpawnPlayer</a> function).</summary>  <seealso name="OnPlayerDeath"/> <seealso name="OnVehicleSpawn"/> <seealso name="SpawnPlayer"/> <seealso name="AddPlayerClass"/> <seealso name="SetSpawnInfo"/> <remarks>This callback can also be called by NPC.</remarks> <remarks>The game sometimes deducts $100 from players after spawn.</remarks> <returns> <b><c>0</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>1</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerStateChange" syntax="OnPlayerStateChange(playerid, newstate, oldstate)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that changed state
			</param>
			<param name="newstate">
				The player's new state
			</param>
			<param name="oldstate">
				The player's previous state
			</param>
			<summary>This callback is called when a player changes state. For example, when a player changes from being the driver of a vehicle to being on-foot.</summary>    <seealso name="OnPlayerInteriorChange"/> <seealso name="GetPlayerState"/> <seealso name="GetPlayerSpecialAction"/> <seealso name="SetPlayerSpecialAction"/> <remarks>This callback can also be called by NPC.</remarks> <remarks> <b>States:</b><p/> <ul> <li><b><c>PLAYER_STATE_NONE</c></b> - empty (while initializing)</li> <li><b><c>PLAYER_STATE_ONFOOT</c></b> - player is on foot</li> <li><b><c>PLAYER_STATE_DRIVER</c></b> - player is the driver of a vehicle</li> <li><b><c>PLAYER_STATE_PASSENGER</c></b> - player is passenger of a vehicle</li> <li><b><c>PLAYER_STATE_WASTED</c></b> - player is dead or on class selection</li> <li><b><c>PLAYER_STATE_SPAWNED</c></b> - player is spawned</li> <li><b><c>PLAYER_STATE_SPECTATING</c></b> - player is spectating</li> <li><b><c>PLAYER_STATE_EXIT_VEHICLE</c></b> - player exits a vehicle</li> <li><b><c>PLAYER_STATE_ENTER_VEHICLE_DRIVER</c></b> - player enters a vehicle as driver</li> <li><b><c>PLAYER_STATE_ENTER_VEHICLE_PASSENGER</c></b> - player enters a vehicle as passenger </li> </ul> </remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerStreamIn" syntax="OnPlayerStreamIn(playerid, forplayerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player who has been streamed
			</param>
			<param name="forplayerid">
				The ID of the player that streamed the other player in
			</param>
			<summary>This callback is called when a player is streamed by some other player's client.</summary>   <seealso name="OnPlayerStreamOut"/> <seealso name="OnActorStreamIn"/> <seealso name="OnVehicleStreamIn"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>This callback can also be called by NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerStreamOut" syntax="OnPlayerStreamOut(playerid, forplayerid)">
			<stacksize value="1"/>
			<param name="playerid">
				The player who has been destreamed
			</param>
			<param name="forplayerid">
				The player who has destreamed the other player
			</param>
			<summary>This callback is called when a player is streamed out from some other player's client.</summary>   <seealso name="OnPlayerStreamIn"/> <seealso name="OnActorStreamOut"/> <seealso name="OnVehicleStreamOut"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>This callback can also be called by NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerTakeDamage" syntax="OnPlayerTakeDamage(playerid, issuerid, amount, weaponid, bodypart)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that took damage
			</param>
			<param name="issuerid">
				The ID of the player that caused the damage. <b><c>INVALID_PLAYER_ID</c></b> if self-inflicted
			</param>
			<param name="amount">
				<paraminfo>Float </paraminfo>
				The amount of damage the player took (health and armour combined)
			</param>
			<param name="weaponid">
				The ID of the <a href="http://wiki.sa-mp.com/wiki/Weapons">weapon/reason</a> for the damage
			</param>
			<param name="bodypart">
				The body part that was hit. (NOTE: This parameter was added in <b>0.3z</b>. Leave it out if using an older version!)
			</param>
			<summary>This callback is called when a player takes damage.</summary>      <seealso name="OnPlayerGiveDamage"/> <seealso name="OnPlayerWeaponShot"/> <remarks>This callback was added in <b>SA-MP 0.3d</b> and will not work in earlier versions!</remarks> <remarks><a href="#GetPlayerHealth">GetPlayerHealth</a> and <a href="#GetPlayerArmour">GetPlayerArmour</a> will return the old amounts of the player before this callback. </remarks> <remarks> The weaponid will return <b><c>37</c></b> (flame thrower) from any fire sources (e.g. molotov, <b><c>18</c></b>).<p/> The weaponid will return <b><c>51</c></b> from any weapon that creates an explosion (e.g. RPG, grenade)<p/> <b>playerid</b> is the only one who can call the callback.<p/> The amount is always the maximum damage the weaponid can do, even when the health left is less than that maximum damage. So when a player has <b><c>100.0</c></b> health and gets shot with a Desert Eagle which has a damage value of <b><c>46.2</c></b>, it takes 3 shots to kill that player. All 3 shots will show an amount of <b><c>46.2</c></b>, even though when the last shot hits, the player only has <b><c>7.6</c></b> health left. </remarks> <returns> <b><c>1</c></b> - Callback will not be called in other filterscripts.<p/> <b><c>0</c></b> - Allows this callback to be called in other filterscripts.<p/> It is always called first in filterscripts so returning <b><c>1</c></b> there blocks other filterscripts from seeing it. </returns>
		</member>
		<member name="M:OnPlayerText" syntax="OnPlayerText(playerid, text[])">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player who typed the text
			</param>
			<param name="text">
				<paraminfo> [] </paraminfo>
				The text the player typed
			</param>
			<summary>Called when a player sends a chat message.</summary>   <seealso name="OnPlayerCommandText"/> <seealso name="SendPlayerMessageToPlayer"/> <seealso name="SendPlayerMessageToAll"/> <remarks>This callback can also be called by NPC.</remarks> <returns> Returning <b><c>0</c></b> in this callback will stop the text from being sent to all players.<p/> It is always called first in filterscripts so returning <b><c>0</c></b> there blocks other scripts from seeing it. </returns>
		</member>
		<member name="M:OnPlayerUpdate" syntax="OnPlayerUpdate(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				ID of the player sending an update packet
			</param>
			<summary>This callback is called every time a client/player updates the server with their status. It is often used to create custom callbacks for client updates that aren't actively tracked by the server, such as health or armor updates or players switching weapons.</summary>  <remarks>This callback can also be called by NPC.</remarks> <remarks>This callback is called, on average, 30 times per second, per player; only use it when you know what it's meant for (or more importantly what it's NOT meant for). </remarks> <remarks>The frequency with which this callback is called for each player varies, depending on what the player is doing. Driving or shooting will trigger a lot more updates than idling. </remarks> <returns> <b><c>0</c></b> - Update from this player will not be replicated to other clients.<p/> <b><c>1</c></b> - Indicates that this update can be processed normally and sent to other players.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnPlayerWeaponShot" syntax="OnPlayerWeaponShot(playerid, weaponid, hittype, hitid, fX, fY, fZ)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that shot a weapon
			</param>
			<param name="weaponid">
				The ID of the <a href="http://wiki.sa-mp.com/wiki/Weapons">weapon</a> shot by the player
			</param>
			<param name="hittype">
				The type of thing the shot hit (none, player, vehicle, or (player)object)
			</param>
			<param name="hitid">
				The ID of the player, vehicle or object that was hit
			</param>
			<param name="fX">
				<paraminfo>Float </paraminfo>
				The X coordinate that the shot hit
			</param>
			<param name="fY">
				<paraminfo>Float </paraminfo>
				The Y coordinate that the shot hit
			</param>
			<param name="fZ">
				<paraminfo>Float </paraminfo>
				The Z coordinate that the shot hit
			</param>
			<summary>This callback is called when a player fires a shot from a weapon. Only bullet weapons are supported. Only <b>passenger</b> drive-by is supported (not driver drive-by, and not sea sparrow / hunter shots).</summary>        <seealso name="OnPlayerGiveDamage"/> <seealso name="GetPlayerLastShotVectors"/> <remarks>This callback was added in <b>SA-MP 0.3z</b> and will not work in earlier versions!</remarks> <remarks> <li><b><c>BULLET_HIT_TYPE_NONE(0)</c></b></li> <li><b><c>BULLET_HIT_TYPE_PLAYER(1)</c></b></li> <li><b><c>BULLET_HIT_TYPE_VEHICLE(2)</c></b></li> <li><b><c>BULLET_HIT_TYPE_OBJECT(3)</c></b></li> <li><b><c>BULLET_HIT_TYPE_PLAYER_OBJECT(4)</c></b></li> </remarks> <remarks><b><c>BULLET_HIT_TYPE_PLAYER</c></b> is also called for NPCs. Actors are ignored by this callback and detects as <b><c>BULLET_HIT_TYPE_NONE</c></b>.</remarks> <remarks>This callback is only called when lag compensation is <b>enabled</b>. </remarks> <remarks> If hittype is:<p/> <ul> <li>- <b><c>BULLET_HIT_TYPE_NONE</c></b>: the fX, fY and fZ parameters are normal coordinates, will give 0.0 for coordinates if nothing was hit (e.g. far object that the bullet can't reach);</li> <li>- Others: the fX, fY and fZ are offsets relative to the hitid.</li> </ul> </remarks> <remarks> Isn't called if you fired in vehicle as driver or if you are looking behind with the aim enabled (shooting in air).<p/> It is called as <b><c>BULLET_HIT_TYPE_VEHICLE</c></b> with the correct hitid (the hit player's vehicleid) if you are shooting a player which is in a vehicle. It won't be called as <b><c>BULLET_HIT_TYPE_PLAYER</c></b> at all.<p/> <b>Partially fixed in SA-MP 0.3.7:</b> If fake weapon data is sent by a malicious user, other player clients may freeze or crash. To combat this, check if the reported weaponid can actually fire bullets. </remarks> <remarks> </remarks> <remarks><a href="#GetPlayerLastShotVectors">GetPlayerLastShotVectors</a> can be used in this callback for more detailed bullet vector information.</remarks> <returns> <b><c>0</c></b> - Prevent the bullet from causing damage.<p/> <b><c>1</c></b> - Allow the bullet to cause damage.<p/> It is always called first in filterscripts so returning <b><c>0</c></b> there also blocks other scripts from seeing it. </returns>
		</member>
		<member name="M:OnQueryError" syntax="OnQueryError(errorid, error[], callback[], query[], handle)">
			<stacksize value="1"/>
			<param name="errorid">
			</param>
			<param name="error">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="callback">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="query">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="handle">
				<paraminfo>MySQL </paraminfo>
			</param>
		</member>
		<member name="M:OnRconCommand" syntax="OnRconCommand(cmd[])">
			<stacksize value="1"/>
			<param name="cmd">
				<paraminfo> [] </paraminfo>
				A string containing the command that was typed, as well as any passed parameters
			</param>
			<summary>This callback is called when a command is sent through the server console, remote RCON, or via the in-game "/rcon command".</summary>  <seealso name="IsPlayerAdmin"/> <seealso name="OnRconLoginAttempt"/> <remarks>You will need to include this callback in a loaded filterscript for it to work in the gamemode!</remarks> <remarks>"/rcon" is not included in "cmd" when a player types a command. </remarks> <remarks>If you use the <a href="#print">print</a> function here, it will send a message to the player who typed the command in-game as well as the log.</remarks> <remarks>This callback is not called when the player is not logged in as RCON admin. </remarks> <remarks>When the player is not logged in as RCON admin and uses <b>/rcon login</b>, this callback will not be called and <a href="#OnRconLoginAttempt">OnRconLoginAttempt</a> is called instead. However, when the player is logged in as RCON admin, the use of this command will call this callback. </remarks> <returns> <b><c>0</c></b> if the command was not processed, it will be passed to another script or <b><c>1</c></b> if the command was processed, will not be passed to other scripts.<p/> It is always called first in filterscripts so returning <b><c>1</c></b> there blocks gamemode from seeing it. </returns>
		</member>
		<member name="M:OnRconLoginAttempt" syntax="OnRconLoginAttempt(ip[], password[], success)">
			<stacksize value="1"/>
			<param name="ip">
				<paraminfo> [] </paraminfo>
				The IP of the player that tried to log in to RCON
			</param>
			<param name="password">
				<paraminfo> [] </paraminfo>
				The password used to login with
			</param>
			<param name="success">
				<b><c>0</c></b> if the password was incorrect or <b><c>1</c></b> if it was correct
			</param>
			<summary>This callback is called when someone attempts to log in to RCON in-game; successful or not.</summary>    <seealso name="OnRconCommand"/> <seealso name="IsPlayerAdmin"/> <seealso name="SendRconCommand"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>This callback is only called when /rcon login is used in-game. </remarks> <remarks>This callback is only called when the player is not yet logged in. When the player is logged in, <a href="#OnRconCommand">OnRconCommand</a> is called instead.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnRuntimeError" syntax="OnRuntimeError(code, &amp;suppress)">
			<attribute name="public"/>
			<stacksize value="16"/>
			<dependency name="AMX_Read"/>
			<dependency name="Hooks_Ordinal"/>
			<dependency name="Hooks_Ordinal"/>
			<dependency name="YSI_g_sActiveHooks"/>
			<dependency name="printf"/>
			<param name="code">
			</param>
			<param name="suppress">
				<paraminfo>bool &amp; </paraminfo>
			</param>
		</member>
		<member name="M:OnScriptCash" syntax="OnScriptCash(playerid, amount, source)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player who got cash from the game
			</param>
			<param name="amount">
				The amount of cash given
			</param>
			<param name="source">
				Where the money came from
			</param>
			<summary>This callback is called when a SendClientCheck request comletes</summary>    <remarks>Doesn't work</remarks>
		</member>
		<member name="M:OnTrailerUpdate" syntax="OnTrailerUpdate(playerid, vehicleid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player who sent a trailer update
			</param>
			<param name="vehicleid">
				The Trailer being updated
			</param>
			<summary>This callback is called when a player sent a trailer update.</summary>   <seealso name="OnUnoccupiedVehicleUpdate"/> <seealso name="GetVehicleTrailer"/> <seealso name="IsTrailerAttachedToVehicle"/> <seealso name="AttachTrailerToVehicle"/> <seealso name="DetachTrailerFromVehicle"/> <remarks>This callback was added in <b>SA-MP 0.3z R4</b> and will not work in earlier versions!</remarks> <remarks>This callback is called very frequently per second per trailer. You should refrain from implementing intensive calculations or intensive file writing/reading operations in this callback. </remarks> <returns> <b><c>0</c></b> - Cancels any trailer updates from being sent to other players. Update is still sent to the updating player.<p/> <b><c>1</c></b> - Processes the trailer update as normal and synchronizes it between all players.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnUnoccupiedVehicleUpdate" syntax="OnUnoccupiedVehicleUpdate(vehicleid, playerid, passenger_seat, new_x, new_y, new_z, vel_x, vel_y, vel_z)">
			<stacksize value="1"/>
			<param name="vehicleid">
				The ID of the vehicle that's position was updated
			</param>
			<param name="playerid">
				The ID of the player that sent a vehicle position sync update
			</param>
			<param name="passenger_seat">
				The ID of the seat if the player is a passenger. 0=not in vehicle, 1=front passenger, 2=backleft 3=backright 4+ is for coach/bus etc. with many passenger seats
			</param>
			<param name="new_x">
				<paraminfo>Float </paraminfo>
				The new X coordinate of the vehicle. This parameter was added in <b>0.3z</b>. Leave it out if using an earlier version
			</param>
			<param name="new_y">
				<paraminfo>Float </paraminfo>
				The new Y coordinate of the vehicle. This parameter was added in <b>0.3z</b>. Leave it out if using an earlier version
			</param>
			<param name="new_z">
				<paraminfo>Float </paraminfo>
				The new Z coordinate of the vehicle. This parameter was added in <b>0.3z</b>. Leave it out if using an earlier version
			</param>
			<param name="vel_x">
				<paraminfo>Float </paraminfo>
				The new X velocity of the vehicle. This parameter was added in <b>0.3z R4</b>. Leave it out if using an earlier version
			</param>
			<param name="vel_y">
				<paraminfo>Float </paraminfo>
				The new Y velocity of the vehicle. This parameter was added in <b>0.3z R4</b>. Leave it out if using an earlier version
			</param>
			<param name="vel_z">
				<paraminfo>Float </paraminfo>
				The new Z velocity of the vehicle. This parameter was added in <b>0.3z R4</b>. Leave it out if using an earlier version
			</param>
			<summary>This callback is called when a player's client updates/syncs the position of a vehicle they're not driving. This can happen outside of the vehicle or when the player is a passenger of a vehicle that has no driver.</summary>          <seealso name="OnTrailerUpdate"/> <remarks>This callback was added in <b>SA-MP 0.3c R3</b> and will not work in earlier versions!</remarks> <remarks>This callback is called very frequently per second per unoccupied vehicle. You should refrain from implementing intensive calculations or intensive file writing/reading operations in this callback.</remarks> <remarks><a href="#GetVehiclePos">GetVehiclePos</a> will return the old coordinates of the vehicle before this update.</remarks> <returns> Returning <b><c>0</c></b> in this callback will stop the vehicle's position being synced to other players. Update is still sent to the updating player. Useful for combating vehicle teleport hacks.<p/> It is always called first in filterscripts so returning <b><c>0</c></b> there also blocks other scripts from seeing it. </returns>
		</member>
		<member name="M:OnVehicleDamageStatusUpdate" syntax="OnVehicleDamageStatusUpdate(vehicleid, playerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
				The ID of the vehicle that was changed its damage status
			</param>
			<param name="playerid">
				The ID of the player who synced the change in the damage status (who had the car damaged or repaired)
			</param>
			<summary>This callback is called when a vehicle element such as doors, tires, panels, or lights change their damage status.</summary>   <seealso name="GetVehicleDamageStatus"/> <seealso name="UpdateVehicleDamageStatus"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>This does not include vehicle health changes</remarks> <returns> <b><c>1</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>0</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in filterscripts.<p/> </returns>
		</member>
		<member name="M:OnVehicleDeath" syntax="OnVehicleDeath(vehicleid, killerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
				The ID of the vehicle that was destroyed
			</param>
			<param name="killerid">
				The ID of the player that reported (synced) the vehicle's destruction (name is misleading). Generally the driver or a passenger (if any) or the closest player
			</param>
			<summary>This callback is called when a vehicle is destroyed - either by exploding or becoming submerged in water.</summary>   <seealso name="OnVehicleSpawn"/> <seealso name="SetVehicleHealth"/> <remarks>This callback can also be called by NPC.</remarks> <remarks>This callback will also be called when a vehicle enters water, but the vehicle can be saved from destruction by teleportation or driving out (if only partially submerged). The callback won't be called a second time, and the vehicle may disappear when the driver exits, or after a short time.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnVehicleMod" syntax="OnVehicleMod(playerid, vehicleid, componentid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the driver of the vehicle
			</param>
			<param name="vehicleid">
				The ID of the vehicle which is modded
			</param>
			<param name="componentid">
				The ID of the component which was added to the vehicle
			</param>
			<summary>This callback is called when a vehicle is modded.</summary>    <seealso name="AddVehicleComponent"/> <seealso name="OnEnterExitModShop"/> <seealso name="OnVehiclePaintjob"/> <seealso name="OnVehicleRespray"/> <remarks>This callback is NOT called by <a href="#AddVehicleComponent">AddVehicleComponent</a>.</remarks> <returns> Return <b><c>0</c></b> to desync the mod (or an invalid mod) from propagating and / or crashing players.<p/> It is always called first in gamemode so returning <b><c>0</c></b> there also blocks other filterscripts from seeing it. </returns>
		</member>
		<member name="M:OnVehiclePaintjob" syntax="OnVehiclePaintjob(playerid, vehicleid, paintjobid)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that changed the paintjob of their vehicle
			</param>
			<param name="vehicleid">
				The ID of the vehicle that had its paintjob changed
			</param>
			<param name="paintjobid">
				The ID of the new paintjob
			</param>
			<summary>Called when a player previews a vehicle paintjob inside a mod shop. Watch out, this callback is not called when the player buys the paintjob.</summary>    <seealso name="ChangeVehiclePaintjob"/> <seealso name="ChangeVehicleColor"/> <seealso name="OnVehicleRespray"/> <seealso name="OnVehicleMod"/> <remarks>This callback is not called by <a href="#ChangeVehiclePaintjob">ChangeVehiclePaintjob</a>.</remarks> <returns> This callback does not handle returns. Returning <b><c>0</c></b> won't deny the paintjob change.<p/> It is always called first in gamemode so returning <b><c>0</c></b> there blocks other filterscripts from seeing it. </returns>
		</member>
		<member name="M:OnVehicleRespray" syntax="OnVehicleRespray(playerid, vehicleid, color1, color2)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that is driving the vehicle
			</param>
			<param name="vehicleid">
				The ID of the vehicle that was resprayed
			</param>
			<param name="color1">
				The color that the vehicle's primary color was changed to
			</param>
			<param name="color2">
				The color that the vehicle's secondary color was changed to
			</param>
			<summary>This callback is called when a player exits a mod shop, even if the colors weren't changed. Watch out, the name is ambiguous, Pay 'n' Spray shops don't call this callback.</summary>     <seealso name="ChangeVehicleColor"/> <seealso name="ChangeVehiclePaintjob"/> <seealso name="OnVehiclePaintjob"/> <seealso name="OnVehicleMod"/> <seealso name="OnEnterExitModShop"/> <remarks>Previewing a component inside a mod shop might call this callback.</remarks> <remarks>This callback is not called by <a href="#ChangeVehicleColor">ChangeVehicleColor</a>.</remarks> <returns> Returning <b><c>0</c></b> in this callback will deny the colour change. Returning <b><c>1</c></b> will allow it. This can be used to prevent hackers from changing vehicle colours using cheats.<p/> It is always called first in gamemode so returning <b><c>0</c></b> there also blocks other filterscripts from seeing it. </returns>
		</member>
		<member name="M:OnVehicleSirenStateChange" syntax="OnVehicleSirenStateChange(playerid, vehicleid, newstate)">
			<stacksize value="1"/>
			<param name="playerid">
				The ID of the player that toggled the siren (driver)
			</param>
			<param name="vehicleid">
				The ID of the vehicle of which the siren was toggled for
			</param>
			<param name="newstate">
				<b><c>0</c></b> if siren was turned off, <b><c>1</c></b> if siren was turned on
			</param>
			<summary>This callback is called when a vehicle's siren is toggled.</summary>    <seealso name="GetVehicleParamsSirenState"/> <remarks>This callback was added in <b>SA-MP 0.3.7</b> and will not work in earlier versions!</remarks> <remarks>This callback can also be called by NPC.</remarks> <remarks>This callback is only called when a vehicle's siren is toggled on or off, NOT when the alternate siren is in use (holding horn).</remarks> <returns> <b><c>1</c></b> - Will prevent gamemode from receiving this callback.<p/> <b><c>0</c></b> - Indicates that this callback will be passed to the gamemode.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnVehicleSpawn" syntax="OnVehicleSpawn(vehicleid)">
			<stacksize value="1"/>
			<param name="vehicleid">
				The ID of the vehicle that spawned
			</param>
			<summary>This callback is called when a vehicle <b>re</b>spawns.</summary>  <seealso name="OnVehicleDeath"/> <seealso name="OnPlayerSpawn"/> <seealso name="SetVehicleToRespawn"/> <seealso name="CreateVehicle"/> <returns> <b><c>0</c></b> - Will prevent other filterscripts from receiving this callback.<p/> <b><c>1</c></b> - Indicates that this callback will be passed to the next filterscript.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnVehicleStreamIn" syntax="OnVehicleStreamIn(vehicleid, forplayerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
				The ID of the vehicle that streamed in for the player
			</param>
			<param name="forplayerid">
				The ID of the player who the vehicle streamed in for
			</param>
			<summary>Called when a vehicle is streamed to a player's client.</summary>   <seealso name="OnVehicleStreamOut"/> <seealso name="OnPlayerStreamIn"/> <seealso name="OnPlayerStreamOut"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>This callback can also be called by NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:OnVehicleStreamOut" syntax="OnVehicleStreamOut(vehicleid, forplayerid)">
			<stacksize value="1"/>
			<param name="vehicleid">
				The ID of the vehicle that streamed out
			</param>
			<param name="forplayerid">
				The ID of the player who is no longer streaming the vehicle
			</param>
			<summary>This callback is called when a vehicle is streamed out for a player's client (it's so far away that they can't see it).</summary>   <seealso name="OnVehicleStreamIn"/> <seealso name="OnPlayerStreamIn"/> <seealso name="OnPlayerStreamOut"/> <remarks>This callback was added in <b>SA-MP 0.3a</b> and will not work in earlier versions!</remarks> <remarks>This callback can also be called by NPC.</remarks> <returns> This callback does not handle returns.<p/> It is always called first in filterscripts. </returns>
		</member>
		<member name="M:Pop" syntax="Pop(&amp;arg)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="false"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<dependency name="true"/>
			<param name="arg">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:PrintAmxHeader" syntax="PrintAmxHeader()">
			<stacksize value="4"/>
			<dependency name="AMX_HDR_AMX_VERSION"/>
			<dependency name="AMX_HDR_CIP"/>
			<dependency name="AMX_HDR_COD"/>
			<dependency name="AMX_HDR_DAT"/>
			<dependency name="AMX_HDR_DEFSIZE"/>
			<dependency name="AMX_HDR_FILE_VERSION"/>
			<dependency name="AMX_HDR_FLAGS"/>
			<dependency name="AMX_HDR_HEA"/>
			<dependency name="AMX_HDR_LIBRARIES"/>
			<dependency name="AMX_HDR_MAGIC"/>
			<dependency name="AMX_HDR_NAMETABLE"/>
			<dependency name="AMX_HDR_NATIVES"/>
			<dependency name="AMX_HDR_PUBLICS"/>
			<dependency name="AMX_HDR_PUBVARS"/>
			<dependency name="AMX_HDR_SIZE"/>
			<dependency name="AMX_HDR_STP"/>
			<dependency name="AMX_HDR_TAGS"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="printf"/>
		</member>
		<member name="M:PrintArg" syntax="PrintArg(n)">
			<stacksize value="1"/>
			<dependency name="__COMPILER_DEFAULT"/>
			<dependency name="print"/>
			<param name="n">
				The numeric parameter position to print.
			</param>
			  <returns>  Prints a string passed as a vararg to the calling function.  </returns> 
		</member>
		<member name="M:Push" syntax="Push(arg)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="PushString"/>
			<dependency name="false"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<dependency name="true"/>
			<param name="arg">
			</param>
		</member>
		<member name="M:PushString" syntax="PushString(string[])">
			<tagname value="bool"/>
			<stacksize value="5"/>
			<dependency name="Push"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:R@" syntax="R@(function[], format[], ...)">
			<attribute name="native"/>
			<referrer name="ScriptInit_CallOnCodeInit"/>
			<referrer name="K@"/>
			<referrer name="D@"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:Random" syntax="Random(min, max)">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<dependency name="random"/>
			<param name="min">
			</param>
			<param name="max">
				Upper bound.
			</param>
			<param name="minmax">Lower bound, or upper bound when only parameter.</param>    <remarks>  Generate a random float between the given numbers (min &lt;= n &lt; max).  Default minimum is 0 (changes the parameter order).  </remarks> 
		</member>
		<member name="M:RandomFloat" syntax="RandomFloat(min, max, dp)">
			<tagname value="Float"/>
			<stacksize value="5"/>
			<dependency name="operator!=(Float:,Float:)"/>
			<dependency name="operator-(Float:)"/>
			<dependency name="operator-(Float:,Float:)"/>
			<dependency name="operator+(Float:,Float:)"/>
			<dependency name="operator/(Float:,Float:)"/>
			<dependency name="operator*(Float:,Float:)"/>
			<dependency name="operator&lt;(Float:,Float:)"/>
			<dependency name="float"/>
			<dependency name="floatpower"/>
			<dependency name="floatround"/>
			<dependency name="random"/>
			<param name="min">
				<paraminfo>Float </paraminfo>
			</param>
			<param name="max">
				<paraminfo>Float </paraminfo>
				Upper bound.
			</param>
			<param name="dp">
				How small to make the differences
			</param>
			<param name="minmax">Lower bound, or upper bound when only parameter.</param>      <remarks>  Generate a random float between the given numbers (min &lt;= n &lt; max).  Default  minimum is 0.0 (changes the parameter order).  </remarks> 
		</member>
		<member name="M:Range" syntax="Range(arr[], num)">
			<stacksize value="4"/>
			<dependency name="cellmax"/>
			<dependency name="cellmin"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need averaging.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  The mathematical range of the values of the array.  </returns> 
		</member>
		<member name="M:ReadAmxCell" syntax="ReadAmxCell(offset)">
			<stacksize value="5"/>
			<dependency name="GetAmxAddress"/>
			<dependency name="ReadPhysMemoryCell"/>
			<param name="offset">
			</param>
		</member>
		<member name="M:ReadAmxMemory" syntax="ReadAmxMemory(address)">
			<stacksize value="1"/>
			<referrer name="ReadAmxMemoryArray"/>
			<referrer name="GetRawAmxHeader"/>
			<referrer name="NtCompare"/>
			<referrer name="NtCopy"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="DisasmGetOperand"/>
			<referrer name="DisasmGetNumOperands"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteDataRowChar"/>
			<referrer name="DisasmWriteDataRowHex"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="CodeScanCheckJumpTarget"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="CodeScanRunFastPrescan"/>
			<referrer name="DumpAMX_WriteAMXData"/>
			<referrer name="DumpAMX_WriteAMXHeader"/>
			<referrer name="DumpAMX_WriteAMXCode"/>
			<param name="address">
			</param>
		</member>
		<member name="M:ReadAmxMemoryArray" syntax="ReadAmxMemoryArray(address, values[], size)">
			<stacksize value="5"/>
			<dependency name="ReadAmxMemory"/>
			<param name="address">
			</param>
			<param name="values">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:ReadOpcodeNearThis" syntax="ReadOpcodeNearThis(offset)">
			<tagname value="Opcode"/>
			<stacksize value="2"/>
			<referrer name="HaveToRelocateOpcodes"/>
			<referrer name="RelocateOpcodeNow"/>
			<dependency name="OP_NONE"/>
			<param name="offset">
			</param>
		</member>
		<member name="M:ReadPhysMemory" syntax="ReadPhysMemory(address, dest[], num)">
			<stacksize value="5"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:ReadPhysMemoryCell" syntax="ReadPhysMemoryCell(address)">
			<stacksize value="5"/>
			<referrer name="ReadAmxCell"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
		</member>
		<member name="M:RelToAbs" syntax="RelToAbs(address)">
			<stacksize value="3"/>
			<referrer name="refabs"/>
			<dependency name="GetAmxBaseAddress"/>
			<dependency name="GetDat"/>
			<param name="address">
			</param>
		</member>
		<member name="M:RelocateOpcode" syntax="RelocateOpcode(opcode)">
			<tagname value="Opcode"/>
			<stacksize value="3"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="SysreqC"/>
			<referrer name="SysreqD"/>
			<referrer name="SysreqCN"/>
			<referrer name="SysreqDN"/>
			<referrer name="CallNative"/>
			<referrer name="CallNativeByAddress"/>
			<referrer name="AsmEmitOpcode"/>
			<referrer name="AsmEmitPadding"/>
			<referrer name="CodeScanInit"/>
			<referrer name="CGen_SetupCodeSpace"/>
			<referrer name="ThirdParty_OnCodeInit"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="InitOpcodeTable"/>
			<dependency name="opcode_table"/>
			<dependency name="opcode_table_is_ready"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:RelocateOpcodeNow" syntax="RelocateOpcodeNow(opcode)">
			<tagname value="Opcode"/>
			<stacksize value="5"/>
			<referrer name="RelocateOpcodeNow"/>
			<referrer name="InitOpcodeTable"/>
			<dependency name="HaveToRelocateOpcodes"/>
			<dependency name="OP_ADD"/>
			<dependency name="OP_ADDR_ALT"/>
			<dependency name="OP_ADDR_PRI"/>
			<dependency name="OP_ADD_C"/>
			<dependency name="OP_ALIGN_ALT"/>
			<dependency name="OP_ALIGN_PRI"/>
			<dependency name="OP_AND"/>
			<dependency name="OP_BOUNDS"/>
			<dependency name="OP_BREAK"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_CASETBL"/>
			<dependency name="OP_CMPS"/>
			<dependency name="OP_CONST_ALT"/>
			<dependency name="OP_CONST_PRI"/>
			<dependency name="OP_DEC"/>
			<dependency name="OP_DEC_ALT"/>
			<dependency name="OP_DEC_I"/>
			<dependency name="OP_DEC_PRI"/>
			<dependency name="OP_DEC_S"/>
			<dependency name="OP_EQ"/>
			<dependency name="OP_EQ_C_ALT"/>
			<dependency name="OP_EQ_C_PRI"/>
			<dependency name="OP_FILL"/>
			<dependency name="OP_GEQ"/>
			<dependency name="OP_GRTR"/>
			<dependency name="OP_HALT"/>
			<dependency name="OP_HEAP"/>
			<dependency name="OP_IDXADDR"/>
			<dependency name="OP_IDXADDR_B"/>
			<dependency name="OP_INC"/>
			<dependency name="OP_INC_ALT"/>
			<dependency name="OP_INC_I"/>
			<dependency name="OP_INC_PRI"/>
			<dependency name="OP_INC_S"/>
			<dependency name="OP_INVERT"/>
			<dependency name="OP_JEQ"/>
			<dependency name="OP_JGEQ"/>
			<dependency name="OP_JGRTR"/>
			<dependency name="OP_JLEQ"/>
			<dependency name="OP_JLESS"/>
			<dependency name="OP_JNEQ"/>
			<dependency name="OP_JNZ"/>
			<dependency name="OP_JSGEQ"/>
			<dependency name="OP_JSGRTR"/>
			<dependency name="OP_JSLEQ"/>
			<dependency name="OP_JSLESS"/>
			<dependency name="OP_JUMP"/>
			<dependency name="OP_JZER"/>
			<dependency name="OP_LCTRL"/>
			<dependency name="OP_LEQ"/>
			<dependency name="OP_LESS"/>
			<dependency name="OP_LIDX"/>
			<dependency name="OP_LIDX_B"/>
			<dependency name="OP_LOAD_ALT"/>
			<dependency name="OP_LOAD_I"/>
			<dependency name="OP_LOAD_PRI"/>
			<dependency name="OP_LOAD_S_ALT"/>
			<dependency name="OP_LOAD_S_PRI"/>
			<dependency name="OP_LODB_I"/>
			<dependency name="OP_LREF_ALT"/>
			<dependency name="OP_LREF_PRI"/>
			<dependency name="OP_LREF_S_ALT"/>
			<dependency name="OP_LREF_S_PRI"/>
			<dependency name="OP_MOVE_ALT"/>
			<dependency name="OP_MOVE_PRI"/>
			<dependency name="OP_MOVS"/>
			<dependency name="OP_NEG"/>
			<dependency name="OP_NEQ"/>
			<dependency name="OP_NOP"/>
			<dependency name="OP_NOT"/>
			<dependency name="OP_OR"/>
			<dependency name="OP_POP_ALT"/>
			<dependency name="OP_POP_PRI"/>
			<dependency name="OP_PROC"/>
			<dependency name="OP_PUSH"/>
			<dependency name="OP_PUSH_ADR"/>
			<dependency name="OP_PUSH_ALT"/>
			<dependency name="OP_PUSH_C"/>
			<dependency name="OP_PUSH_PRI"/>
			<dependency name="OP_PUSH_S"/>
			<dependency name="OP_RET"/>
			<dependency name="OP_RETN"/>
			<dependency name="OP_SCTRL"/>
			<dependency name="OP_SDIV"/>
			<dependency name="OP_SDIV_ALT"/>
			<dependency name="OP_SGEQ"/>
			<dependency name="OP_SGRTR"/>
			<dependency name="OP_SHL"/>
			<dependency name="OP_SHL_C_ALT"/>
			<dependency name="OP_SHL_C_PRI"/>
			<dependency name="OP_SHR"/>
			<dependency name="OP_SHR_C_ALT"/>
			<dependency name="OP_SHR_C_PRI"/>
			<dependency name="OP_SIGN_ALT"/>
			<dependency name="OP_SIGN_PRI"/>
			<dependency name="OP_SLEQ"/>
			<dependency name="OP_SLESS"/>
			<dependency name="OP_SMUL"/>
			<dependency name="OP_SMUL_C"/>
			<dependency name="OP_SREF_ALT"/>
			<dependency name="OP_SREF_PRI"/>
			<dependency name="OP_SREF_S_ALT"/>
			<dependency name="OP_SREF_S_PRI"/>
			<dependency name="OP_SSHR"/>
			<dependency name="OP_STACK"/>
			<dependency name="OP_STOR_ALT"/>
			<dependency name="OP_STOR_I"/>
			<dependency name="OP_STOR_PRI"/>
			<dependency name="OP_STOR_S_ALT"/>
			<dependency name="OP_STOR_S_PRI"/>
			<dependency name="OP_STRB_I"/>
			<dependency name="OP_SUB"/>
			<dependency name="OP_SUB_ALT"/>
			<dependency name="OP_SWAP_ALT"/>
			<dependency name="OP_SWAP_PRI"/>
			<dependency name="OP_SWITCH"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="OP_UDIV"/>
			<dependency name="OP_UDIV_ALT"/>
			<dependency name="OP_UMUL"/>
			<dependency name="OP_XCHG"/>
			<dependency name="OP_XOR"/>
			<dependency name="OP_ZERO"/>
			<dependency name="OP_ZERO_ALT"/>
			<dependency name="OP_ZERO_PRI"/>
			<dependency name="OP_ZERO_S"/>
			<dependency name="ReadOpcodeNearThis"/>
			<dependency name="debug"/>
			<dependency name="false"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:ResetStaticAmxHeader" syntax="ResetStaticAmxHeader()">
			<stacksize value="4"/>
			<referrer name="GetAmxHeader"/>
			<referrer name="GetAmxHeaderComponent"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="GetPublicIndexFromAddress"/>
			<referrer name="GetPublicInfo"/>
			<referrer name="GetPublicIndexFromName"/>
			<referrer name="HookPublic"/>
			<referrer name="GetNativeIndexFromAddress"/>
			<referrer name="GetNativeInfo"/>
			<referrer name="GetNativeIndexFromName"/>
			<referrer name="HookNative"/>
			<referrer name="GetPubVarInfo"/>
			<referrer name="GetPubVarIndexFromName"/>
			<referrer name="GetPubVarIndexFromAddress"/>
			<referrer name="GetTagInfo"/>
			<referrer name="GetTagIndexFromName"/>
			<referrer name="GetTagIndexFromID"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="_Hooks_RepairStub"/>
			<dependency name="GetAmxHeaderNow"/>
			<dependency name="gHdr"/>
			<dependency name="gInitialized"/>
			<dependency name="true"/>
		</member>
		<member name="M:ResolveJITAddress" syntax="ResolveJITAddress(addr)">
			<stacksize value="1"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:ReturnPlayerName" syntax="ReturnPlayerName(playerid)">
			<stacksize value="29"/>
			<dependency name="GetPlayerName"/>
			<dependency name="ReturnPlayerName"/>
			<param name="playerid">
				Player whose name you want to get.
			</param>
			<summary>  ReturnPlayerName  </summary>    <remarks>  Now uses a global array to avoid repeated function calls.  Actually doesn't  because that causes issues with multiple scripts.  </remarks> 
		</member>
		<member name="M:RunShellcode" syntax="RunShellcode(code_ptr, align)">
			<stacksize value="5"/>
			<referrer name="GetAmxAddress"/>
			<dependency name="SysreqD"/>
			<param name="code_ptr">
			</param>
			<param name="align">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:ScriptInit_CallOnCodeInit" syntax="ScriptInit_CallOnCodeInit(jit)">
			<stacksize value="5"/>
			<referrer name="OnJITCompile"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="OnGameModeInit"/>
			<dependency name="Debug_Print0"/>
			<dependency name="DumpAMX_Write"/>
			<dependency name="E_SCRIPTINIT_STATE_DUMPED"/>
			<dependency name="E_SCRIPTINIT_STATE_JITED"/>
			<dependency name="E_SCRIPTINIT_STATE_JITING"/>
			<dependency name="E_SCRIPTINIT_STATE_RELOAD"/>
			<dependency name="R@"/>
			<dependency name="Server_DisableLongCall"/>
			<dependency name="Server_EnableLongCall"/>
			<dependency name="YSI_Print"/>
			<dependency name="YSI_g_sScriptInitState"/>
			<param name="jit">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:ScriptInit_OnCodeInit" syntax="ScriptInit_OnCodeInit()">
			<attribute name="public"/>
			<stacksize value="5"/>
			<dependency name="Debug_Print0"/>
			<dependency name="Debug_SetState"/>
			<dependency name="YSI_FILTERSCRIPT"/>
			<remarks>  Does some strange mangling of <c>YSI_FILTERSCRIPT</c> because at one point I  found a compiler bug where the first automata in the script could conflict  with the first variable in the script.  I don't know what triggered it, and  it has never shown up since I messed about with this file to try mangle some  things.  Never the less, if it ever happens again this code might detect it.  Actually, that's less likely now, since that variable is now very unlikely  to be the first in the script ever.  </remarks> 
		</member>
		<member name="M:ScriptInit_OnFilterScriptExit" syntax="ScriptInit_OnFilterScriptExit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="OnFilterScriptExit"/>
		</member>
		<member name="M:ScriptInit_OnFilterScriptInit" syntax="ScriptInit_OnFilterScriptInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="_ALS"/>
			<referrer name="OnFilterScriptInit"/>
			<dependency name="Indirect_Init"/>
		</member>
		<member name="M:ScriptInit_OnGameModeExit" syntax="ScriptInit_OnGameModeExit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="OnGameModeExit"/>
		</member>
		<member name="M:ScriptInit_OnGameModeInit" syntax="ScriptInit_OnGameModeInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="_ALS"/>
			<referrer name="OnGameModeInit"/>
			<dependency name="Indirect_Init"/>
		</member>
		<member name="M:ScriptInit_OnJITCompile" syntax="ScriptInit_OnJITCompile()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="_ALS"/>
			<referrer name="OnJITCompile"/>
			<dependency name="Indirect_Init"/>
		</member>
		<member name="M:ScriptInit_OnScriptExit" syntax="ScriptInit_OnScriptExit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="OnFilterScriptExit"/>
			<referrer name="OnGameModeExit"/>
		</member>
		<member name="M:ScriptInit_OnScriptInit" syntax="ScriptInit_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<automaton name="_ALS"/>
			<dependency name="YSI_Print"/>
			<dependency name="YVers_OnScriptInit"/>
		</member>
		<member name="M:ScriptInit_PostExitFuncs_" syntax="ScriptInit_PostExitFuncs_()">
			<stacksize value="9"/>
			<referrer name="OnFilterScriptExit"/>
			<referrer name="OnGameModeExit"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
		</member>
		<member name="M:ScriptInit_PostInitFuncs_" syntax="ScriptInit_PostInitFuncs_()">
			<stacksize value="9"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="OnGameModeInit"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
		</member>
		<member name="M:ScriptInit_PreExitFuncs_" syntax="ScriptInit_PreExitFuncs_()">
			<stacksize value="9"/>
			<referrer name="OnFilterScriptExit"/>
			<referrer name="OnGameModeExit"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
		</member>
		<member name="M:ScriptInit_PreInitFuncs_" syntax="ScriptInit_PreInitFuncs_()">
			<stacksize value="9"/>
			<referrer name="OnFilterScriptInit"/>
			<referrer name="OnGameModeInit"/>
			<dependency name="AMX_GetPointerPrefix"/>
			<dependency name="AMX_TABLE_PUBLICS"/>
		</member>
		<member name="M:SendClientMessage" syntax="SendClientMessage(playerid, color, message[])">
			<attribute name="native"/>
			<referrer name="KickEx"/>
			<param name="playerid">
				The ID of the player to display the message to
			</param>
			<param name="color">
				The color of the message (<b>RGBA</b>)
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
				The text that will be displayed <b>(max 144 characters)</b>
			</param>
			<summary>This function sends a message to a specific player with a chosen color in the chat. The whole line in the chatbox will be in the set color unless color embedding is used (since <b><c>0.3c</c></b>).</summary>    <seealso name="SendClientMessageToAll"/> <seealso name="SendPlayerMessageToPlayer"/> <seealso name="SendPlayerMessageToAll"/> <remarks>If a message is longer than 144 characters, it will not be sent. Truncation can be used to prevent this. Displaying a message on multiple lines will also solve this issue. </remarks> <remarks>Avoid using the percent sign (or format specifiers) in the actual message text without properly escaping it (like <b><c>%%</c></b>). It will result in crashes otherwise. </remarks> <remarks>You can use color embedding for multiple colors in the message. </remarks> <returns> <b><c>1</c></b>: The function executed successfully. Success is reported when the string is over 144 characters, but the message won't be sent.<p/> <b><c>0</c></b>: The function failed to execute. The player is not connected. </returns>
		</member>
		<member name="M:Server_CacheLoaded" syntax="Server_CacheLoaded()">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="E_SCRIPTINIT_STATE_RELOAD"/>
			<dependency name="YSI_g_sScriptInitState"/>
		</member>
		<member name="M:Server_CacheSaved" syntax="Server_CacheSaved()">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="E_SCRIPTINIT_STATE_DUMPED"/>
			<dependency name="YSI_g_sScriptInitState"/>
		</member>
		<member name="M:Server_CrashDetectExists" syntax="Server_CrashDetectExists()">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="false"/>
		</member>
		<member name="M:Server_DisableLongCall" syntax="Server_DisableLongCall()">
			<stacksize value="1"/>
			<referrer name="ScriptInit_CallOnCodeInit"/>
		</member>
		<member name="M:Server_EnableLongCall" syntax="Server_EnableLongCall()">
			<stacksize value="1"/>
			<referrer name="ScriptInit_CallOnCodeInit"/>
		</member>
		<member name="M:Server_GetLongCallDefault" syntax="Server_GetLongCallDefault()">
			<stacksize value="1"/>
		</member>
		<member name="M:Server_GetLongCallTime" syntax="Server_GetLongCallTime()">
			<stacksize value="1"/>
		</member>
		<member name="M:Server_IsFilterscript" syntax="Server_IsFilterscript()">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="YSI_FILTERSCRIPT"/>
		</member>
		<member name="M:Server_IsGameMode" syntax="Server_IsGameMode()">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="YSI_FILTERSCRIPT"/>
		</member>
		<member name="M:Server_IsLongCallEnabled" syntax="Server_IsLongCallEnabled()">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="false"/>
		</member>
		<member name="M:Server_JITComplete" syntax="Server_JITComplete()">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<dependency name="E_SCRIPTINIT_STATE_JITED"/>
			<dependency name="YSI_g_sScriptInitState"/>
		</member>
		<member name="M:Server_JITExists" syntax="Server_JITExists()">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="Hooks_SortPublics"/>
			<referrer name="CGen_OnCodeInit"/>
			<dependency name="E_SCRIPTINIT_STATE_JITING"/>
			<dependency name="YSI_g_sScriptInitState"/>
		</member>
		<member name="M:Server_ResetLongCallTime" syntax="Server_ResetLongCallTime()">
			<stacksize value="1"/>
		</member>
		<member name="M:Server_RestartLongCall" syntax="Server_RestartLongCall()">
			<stacksize value="1"/>
		</member>
		<member name="M:Server_SetLongCallTime" syntax="Server_SetLongCallTime(usTime)">
			<stacksize value="1"/>
			<param name="usTime">
			</param>
		</member>
		<member name="M:SetAmxFrame" syntax="SetAmxFrame(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetAmxHeapTop" syntax="SetAmxHeapTop(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetAmxNextInstructionPointer" syntax="SetAmxNextInstructionPointer(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetAmxStackBottom" syntax="SetAmxStackBottom(ptr)">
			<stacksize value="1"/>
			<param name="ptr">
			</param>
		</member>
		<member name="M:SetColour" syntax="SetColour(name[], color)">
			<stacksize value="9"/>
			<dependency name="SetColourHash"/>
			<dependency name="YHash"/>
			<dependency name="YSI_g_sCheckSpaces"/>
			<dependency name="false"/>
			<dependency name="hash_bernstein"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<dependency name="true"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="color">
			</param>
		</member>
		<member name="M:SetColourHash" syntax="SetColourHash(hash, color)">
			<stacksize value="5"/>
			<referrer name="SetColour"/>
			<dependency name="I@"/>
			<dependency name="J@"/>
			<dependency name="_@_SetColourHash"/>
			<param name="hash">
			</param>
			<param name="color">
			</param>
		</member>
		<member name="M:SetColoursCanHaveSpaces" syntax="SetColoursCanHaveSpaces(set)">
			<stacksize value="4"/>
			<dependency name="I@"/>
			<dependency name="J@"/>
			<dependency name="_@_SetColoursCanHaveSpaces"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:SetCurrentFramePreviousFrame" syntax="SetCurrentFramePreviousFrame(addr)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFramePreviousFrame"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetCurrentFrameReturn" syntax="SetCurrentFrameReturn(addr)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFrameReturn"/>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetCurrentParameterCount" syntax="SetCurrentParameterCount(count)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFrameParameterCount"/>
			<param name="count">
			</param>
		</member>
		<member name="M:SetCurrentParameterSize" syntax="SetCurrentParameterSize(size)">
			<stacksize value="5"/>
			<dependency name="GetCallerFrame"/>
			<dependency name="SetFrameParameterSize"/>
			<param name="size">
			</param>
		</member>
		<member name="M:SetFrameLocal" syntax="SetFrameLocal(frm_addr, param, value)">
			<stacksize value="1"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:SetFrameParameter" syntax="SetFrameParameter(frm_addr, param, value, idx)">
			<stacksize value="1"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="value">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:SetFrameParameterCount" syntax="SetFrameParameterCount(frm_addr, count)">
			<stacksize value="5"/>
			<referrer name="SetCurrentParameterCount"/>
			<dependency name="SetFrameParameterSize"/>
			<param name="frm_addr">
			</param>
			<param name="count">
			</param>
		</member>
		<member name="M:SetFrameParameterSize" syntax="SetFrameParameterSize(frm_addr, size)">
			<stacksize value="1"/>
			<referrer name="SetFrameParameterCount"/>
			<referrer name="SetCurrentParameterSize"/>
			<param name="frm_addr">
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:SetFramePreviousFrame" syntax="SetFramePreviousFrame(frm_addr, addr)">
			<stacksize value="1"/>
			<referrer name="SetCurrentFramePreviousFrame"/>
			<param name="frm_addr">
			</param>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetFrameReturn" syntax="SetFrameReturn(frm_addr, addr)">
			<stacksize value="1"/>
			<referrer name="SetCurrentFrameReturn"/>
			<param name="frm_addr">
			</param>
			<param name="addr">
			</param>
		</member>
		<member name="M:SetFrameVariable" syntax="SetFrameVariable(frm_addr, param, value, idx)">
			<stacksize value="1"/>
			<param name="frm_addr">
			</param>
			<param name="param">
			</param>
			<param name="value">
			</param>
			<param name="idx">
			</param>
		</member>
		<member name="M:SetSpawnInfo" syntax="SetSpawnInfo(playerid, team, skin, x, y, z, rotation, weapon1, weapon1_ammo, weapon2, weapon2_ammo, weapon3, weapon3_ammo)">
			<attribute name="native"/>
			<referrer name="OnPlayerRegister"/>
			<referrer name="OnPasswordChecked"/>
			<param name="playerid">
				The PlayerID of who you want to set the spawn information
			</param>
			<param name="team">
				The Team-ID of the chosen player
			</param>
			<param name="skin">
				The skin which the player will spawn with
			</param>
			<param name="x">
				<paraminfo>Float </paraminfo>
				The X-coordinate of the player's spawn position
			</param>
			<param name="y">
				<paraminfo>Float </paraminfo>
				The Y-coordinate of the player's spawn position
			</param>
			<param name="z">
				<paraminfo>Float </paraminfo>
				The Z-coordinate of the player's spawn position
			</param>
			<param name="rotation">
				<paraminfo>Float </paraminfo>
				The direction in which the player needs to be facing after spawning
			</param>
			<param name="weapon1">
				The first spawn-<a href="http://wiki.sa-mp.com/wiki/Weapons">weapon</a> for the player
			</param>
			<param name="weapon1_ammo">
				The amount of ammunition for the primary spawnweapon
			</param>
			<param name="weapon2">
				The second spawn-<a href="http://wiki.sa-mp.com/wiki/Weapons">weapon</a> for the player
			</param>
			<param name="weapon2_ammo">
				The amount of ammunition for the second spawnweapon
			</param>
			<param name="weapon3">
				The third spawn-<a href="http://wiki.sa-mp.com/wiki/Weapons">weapon</a> for the player
			</param>
			<param name="weapon3_ammo">
				The amount of ammunition for the third spawnweapon
			</param>
			<summary>This function can be used to change the spawn information of a specific player. It allows you to automatically set someone's spawn weapons, their team, skin and spawn position, normally used in case of minigames or automatic-spawn systems. This function is more crash-safe then using <a href="#SetPlayerSkin">SetPlayerSkin</a> in <a href="#OnPlayerSpawn">OnPlayerSpawn</a> and/or <a href="#OnPlayerRequestClass">OnPlayerRequestClass</a>, even though this has been fixed in 0.2.</summary>              <seealso name="SetPlayerSkin"/> <seealso name="SetPlayerTeam"/> <seealso name="SpawnPlayer"/>
		</member>
		<member name="M:ShowPlayerAsyncDialog" syntax="ShowPlayerAsyncDialog(playerid, style, caption[], info[], button1[], button2[])">
			<tagname value="Task"/>
			<stacksize value="12"/>
			<dependency name="PAWN_PLUS_DIALOG_ID"/>
			<dependency name="PlayerDialogTasks"/>
			<dependency name="pawn_call_native"/>
			<dependency name="task_delete"/>
			<dependency name="task_new"/>
			<param name="playerid">
			</param>
			<param name="style">
			</param>
			<param name="caption">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="info">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="button1">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="button2">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:ShowPlayerAsyncDialogStr" syntax="ShowPlayerAsyncDialogStr(playerid, style, caption, info, button1, button2)">
			<tagname value="Task"/>
			<stacksize value="12"/>
			<referrer name="Account_RegisterHandler"/>
			<referrer name="Account_EmailDialogHandler"/>
			<referrer name="Account_LoginDialog"/>
			<dependency name="PAWN_PLUS_DIALOG_ID"/>
			<dependency name="PlayerDialogTasks"/>
			<dependency name="pawn_call_native"/>
			<dependency name="task_delete"/>
			<dependency name="task_new"/>
			<param name="playerid">
			</param>
			<param name="style">
			</param>
			<param name="caption">
				<paraminfo> {String@Const,String} </paraminfo>
			</param>
			<param name="info">
				<paraminfo> {String@Const,String} </paraminfo>
			</param>
			<param name="button1">
				<paraminfo> {String@Const,String} </paraminfo>
			</param>
			<param name="button2">
				<paraminfo> {String@Const,String} </paraminfo>
			</param>
		</member>
		<member name="M:SkipWhitespace" syntax="SkipWhitespace(str[], pos)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to skip over part of.
			</param>
			<param name="pos">
				The start of the whitespace.
			</param>
			    <returns>  The end of the whitespace.  </returns>  <remarks>  Doesn't skip over NULL terminators.  </remarks> 
		</member>
		<member name="M:SpawnPlayer" syntax="SpawnPlayer(playerid)">
			<attribute name="native"/>
			<referrer name="OnPlayerRegister"/>
			<referrer name="OnPasswordChecked"/>
			<param name="playerid">
				The ID of the player to spawn
			</param>
			<summary>(Re)Spawns a player.</summary>  <seealso name="SetSpawnInfo"/> <seealso name="AddPlayerClass"/> <seealso name="OnPlayerSpawn"/> <remarks>Kills the player if they are in a vehicle and then they spawn with a bottle in their hand.</remarks> <returns> <b><c>1</c></b>: The function executed successfully.<p/> <b><c>0</c></b>: The function failed to execute. This means the player is not connected. </returns>
		</member>
		<member name="M:StrToLower" syntax="StrToLower(str[], len)">
			<stacksize value="5"/>
			<dependency name="tolower"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to convert.
			</param>
			<param name="len">
				How much of the string to convert.
			</param>
			   
		</member>
		<member name="M:StrToUpper" syntax="StrToUpper(str[], len)">
			<stacksize value="5"/>
			<dependency name="toupper"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to convert.
			</param>
			<param name="len">
				How much of the string to convert.
			</param>
			   
		</member>
		<member name="M:Strip" syntax="Strip(str[])">
			<stacksize value="9"/>
			<dependency name="memcpy"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to remove whitespace from the start and end of.
			</param>
			 
		</member>
		<member name="M:StripL" syntax="StripL(str[])">
			<stacksize value="9"/>
			<dependency name="memcpy"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to remove whitespace from the start of.
			</param>
			 
		</member>
		<member name="M:StripNL" syntax="StripNL(str[])">
			<stacksize value="4"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to remove whitespace from the end of.
			</param>
			  <remarks>  Updated from old versions, should be more efficient  </remarks> 
		</member>
		<member name="M:Sum" syntax="Sum(arr[], num)">
			<stacksize value="2"/>
			<referrer name="Mean"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array whose values need summing.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <returns>  All the values in the array added together.  </returns> 
		</member>
		<member name="M:SysreqC" syntax="SysreqC(index, auto_pop)">
			<stacksize value="9"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="index">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:SysreqCN" syntax="SysreqCN(index, args_to_push, auto_pop)">
			<stacksize value="10"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="index">
			</param>
			<param name="args_to_push">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:SysreqD" syntax="SysreqD(address, auto_pop)">
			<stacksize value="9"/>
			<referrer name="RunShellcode"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:SysreqDN" syntax="SysreqDN(address, args_to_push, auto_pop)">
			<stacksize value="10"/>
			<dependency name="GetJITGeneratorVersion"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="cellmin"/>
			<dependency name="g_args"/>
			<dependency name="g_nargs"/>
			<param name="address">
			</param>
			<param name="args_to_push">
			</param>
			<param name="auto_pop">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:T@" syntax="T@(ret[], ...)">
			<stacksize value="8"/>
			<dependency name="YSI_g_sPropEmpty"/>
			<dependency name="YSI_g_sPropVarArg"/>
			<dependency name="getarg"/>
			<dependency name="numargs"/>
			<dependency name="setproperty"/>
			<param name="ret">
				<paraminfo> [144] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:ThirdParty_OnCodeInit" syntax="ThirdParty_OnCodeInit()">
			<attribute name="public"/>
			<stacksize value="11"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AMX_Write"/>
			<dependency name="CGen_SetupCodeSpace"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmInit"/>
			<dependency name="DisasmNextInsn"/>
			<dependency name="OP_NONE"/>
			<dependency name="OP_NOP"/>
			<dependency name="RelocateOpcode"/>
			<dependency name="YSI_g_sCodeSpace"/>
		</member>
		<member name="M:ToHexStr" syntax="ToHexStr(x)">
			<stacksize value="15"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteDataRowHex"/>
			<referrer name="DisasmWriteData"/>
			<dependency name="ToHexStr"/>
			<param name="x">
			</param>
		</member>
		<member name="M:ToPrintableAscii" syntax="ToPrintableAscii(c)">
			<stacksize value="4"/>
			<referrer name="DisasmWriteDataRowChar"/>
			<dependency name="IsPrintableAscii"/>
			<param name="c">
			</param>
		</member>
		<member name="M:TogglePlayerSpectating" syntax="TogglePlayerSpectating(playerid, toggle)">
			<attribute name="native"/>
			<referrer name="Account_RegisterHandler"/>
			<referrer name="Account_LoginDialog"/>
			<referrer name="OnPlayerAccountChecked"/>
			<referrer name="OnPlayerRegister"/>
			<referrer name="OnPasswordChecked"/>
			<param name="playerid">
				The ID of the player who should spectate
			</param>
			<param name="toggle">
				<b><c>1</c></b> to enable spectating and <b><c>0</c></b> to disable
			</param>
			<summary>Toggle whether a player is in spectator mode or not. While in spectator mode a player can spectate (watch) other players and vehicles. After using this function, either <a href="#PlayerSpectatePlayer">PlayerSpectatePlayer</a> or <a href="#PlayerSpectateVehicle">PlayerSpectateVehicle</a> needs to be used.</summary>   <seealso name="PlayerSpectatePlayer"/> <seealso name="PlayerSpectateVehicle"/> <remarks>If the player is not loaded in before setting the spectate status to false, the connection can be closed unexpectedly.</remarks> <remarks>When spectator mode is disabled, <a href="#OnPlayerSpawn">OnPlayerSpawn</a> will automatically be called, if you wish to restore player to state before spectating, you will have to handle that in <a href="#OnPlayerSpawn">OnPlayerSpawn</a>. Note also, that player can also go to class selection before if they used F4 during spectate, a player also CAN die in spectate mode due to various glitches.</remarks> <remarks>When a player is in spectate mode their HUD is hidden, making it useful for setting a player's camera without the HUD. Also, objects near the player's camera will be streamed in, making this useful for interpolating cameras.</remarks> <returns> <b><c>1</c></b>: The function executed successfully.<p/> <b><c>0</c></b>: The function failed to execute. The player does not exist. </returns>
		</member>
		<member name="M:Trim" syntax="Trim(str[], &amp;start, &amp;end)">
			<stacksize value="1"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to trim.
			</param>
			<param name="start">
				<paraminfo> &amp; </paraminfo>
				Start of the substring.
			</param>
			<param name="end">
				<paraminfo> &amp; </paraminfo>
				End of the substring.
			</param>
			      <remarks>  Modifies "start" and "end" to be tight on text in "str".  </remarks> 
		</member>
		<member name="M:UnrelocateOpcode" syntax="UnrelocateOpcode(opcode)">
			<tagname value="Opcode"/>
			<stacksize value="3"/>
			<referrer name="GetFrameFunction"/>
			<referrer name="DisasmDecodeInsn"/>
			<referrer name="CodeScanRunFastPrescan"/>
			<dependency name="InitOpcodeTable"/>
			<dependency name="NUM_OPCODES"/>
			<dependency name="OP_NONE"/>
			<dependency name="opcode_table"/>
			<dependency name="opcode_table_is_ready"/>
			<param name="opcode">
				<paraminfo>Opcode </paraminfo>
			</param>
		</member>
		<member name="M:Utils_PreSort" syntax="Utils_PreSort(arr[], num)">
			<stacksize value="4"/>
			<referrer name="Mode"/>
			<referrer name="Median"/>
			<dependency name="false"/>
			<dependency name="true"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				The array to sort.
			</param>
			<param name="num">
				The size of the array.
			</param>
			    <remarks>  Sorts the array in place.  Uses bubble sort because it is easy and fast for  pre-sorted arrays (which the callers are likely to be).  </remarks> 
		</member>
		<member name="M:W@" syntax="W@(function[], format[], ...)">
			<attribute name="native"/>
			<referrer name="K@"/>
			<referrer name="D@"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:WriteAmxCell" syntax="WriteAmxCell(offset, value)">
			<stacksize value="6"/>
			<dependency name="GetAmxAddress"/>
			<dependency name="WritePhysMemoryCell"/>
			<param name="offset">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:WriteAmxMemory" syntax="WriteAmxMemory(address, value)">
			<stacksize value="1"/>
			<referrer name="WriteAmxMemoryArray"/>
			<referrer name="HookPublic"/>
			<referrer name="HookNative"/>
			<referrer name="AsmEmitCell"/>
			<referrer name="AsmEmitLabelStringize"/>
			<referrer name="AsmEmitPadding"/>
			<param name="address">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:WriteAmxMemoryArray" syntax="WriteAmxMemoryArray(address, values[], size)">
			<stacksize value="6"/>
			<dependency name="WriteAmxMemory"/>
			<param name="address">
			</param>
			<param name="values">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:WritePhysMemory" syntax="WritePhysMemory(address, src[], num)">
			<stacksize value="5"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="num">
			</param>
		</member>
		<member name="M:WritePhysMemoryCell" syntax="WritePhysMemoryCell(address, what)">
			<stacksize value="5"/>
			<referrer name="WriteAmxCell"/>
			<dependency name="AbsToRel"/>
			<param name="address">
			</param>
			<param name="what">
			</param>
		</member>
		<member name="M:X@" syntax="X@(n)">
			<stacksize value="6"/>
			<dependency name="YSI_g_sPropReturn"/>
			<dependency name="setproperty"/>
			<param name="n">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:YHNPS_Find" syntax="YHNPS_Find(heap, end, value)">
			<stacksize value="7"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="AMX_Read"/>
			<dependency name="cellmin"/>
			<param name="heap">
			</param>
			<param name="end">
			</param>
			<param name="value">
			</param>
		</member>
		<member name="M:YHNPS_Insert" syntax="YHNPS_Insert(heap, count, value, ptr)">
			<stacksize value="10"/>
			<referrer name="YHNPS_Push"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="cellmax"/>
			<dependency name="rawMemcpy_"/>
			<param name="heap">
			</param>
			<param name="count">
			</param>
			<param name="value">
			</param>
			<param name="ptr">
			</param>
		</member>
		<member name="M:YHNPS_Push" syntax="YHNPS_Push(heap, &amp;allocated, &amp;nativeCount, &amp;stockCount, base, find, replace)">
			<stacksize value="7"/>
			<referrer name="Hooks_OnCodeInit"/>
			<dependency name="GetNativeAddressFromIndex"/>
			<dependency name="HeapAllocCells"/>
			<dependency name="YHNPS_Insert"/>
			<dependency name="cellmax"/>
			<dependency name="max"/>
			<dependency name="rawMemcpy_"/>
			<param name="heap">
			</param>
			<param name="allocated">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="nativeCount">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="stockCount">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="base">
			</param>
			<param name="find">
			</param>
			<param name="replace">
			</param>
		</member>
		<member name="M:YHash" syntax="YHash(str[], sensitive, type, len, pack)">
			<stacksize value="4"/>
			<referrer name="SetColour"/>
			<referrer name="GetColour"/>
			<referrer name="GetColourStream"/>
			<dependency name="cellmin"/>
			<dependency name="hash_bernstein"/>
			<dependency name="hash_fnv1"/>
			<dependency name="hash_fnv1a"/>
			<dependency name="min"/>
			<dependency name="strlen"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				The string to hash.
			</param>
			<param name="sensitive">
				<paraminfo>bool </paraminfo>
				Wether the hash is case sensitive or not.
			</param>
			<param name="type">
				<paraminfo>e_HASH_TYPE </paraminfo>
			</param>
			<param name="len">
			</param>
			<param name="pack">
			</param>
			    <returns>  The reverse Bernstein hash of the string.  </returns>  <remarks>  Based on Bernstein hash, but backwards to match the macros.  The only  characters which can be used in the compile time version of this code are:  a-z, A-Z, 0-9, _ and space.  native Hash(str[]);  NOW FORWARD AGAIN.  </remarks> 
		</member>
		<member name="M:YSI_Print" syntax="YSI_Print(string[])">
			<attribute name="native"/>
			<referrer name="ScriptInit_CallOnCodeInit"/>
			<referrer name="ScriptInit_OnScriptInit"/>
			<referrer name="YVers_Callback"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:YSI_PrintF" syntax="YSI_PrintF(format[], ...)">
			<attribute name="native"/>
			<referrer name="YVers_Callback"/>
			<referrer name="Debug_Print0"/>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
			</param>
		</member>
		<member name="M:YVers_Callback" syntax="YVers_Callback(index, code, data[])">
			<attribute name="public"/>
			<stacksize value="8"/>
			<dependency name="YSI_Print"/>
			<dependency name="YSI_PrintF"/>
			<dependency name="false"/>
			<dependency name="strcmp"/>
			<dependency name="strfind"/>
			<param name="index">
			</param>
			<param name="code">
			</param>
			<param name="data">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:YVers_OnScriptInit" syntax="YVers_OnScriptInit()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_ALS"/>
			<referrer name="ScriptInit_OnScriptInit"/>
		</member>
		<member name="M:_@_SetColourHash" syntax="_@_SetColourHash(hash, color)">
			<stacksize value="7"/>
			<referrer name="SetColourHash"/>
			<dependency name="D@"/>
			<dependency name="F@"/>
			<dependency name="I@"/>
			<dependency name="J@"/>
			<param name="hash">
			</param>
			<param name="color">
			</param>
		</member>
		<member name="M:_@_SetColoursCanHaveSpaces" syntax="_@_SetColoursCanHaveSpaces(set)">
			<stacksize value="6"/>
			<referrer name="SetColoursCanHaveSpaces"/>
			<dependency name="D@"/>
			<dependency name="F@"/>
			<dependency name="I@"/>
			<dependency name="J@"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:_@_y_cgen_@_0" syntax="_@_y_cgen_@_0()">
			<attribute name="public"/>
			<stacksize value="55"/>
			<dependency name="CGEN"/>
		</member>
		<member name="M:_@_y_cgen_@_1" syntax="_@_y_cgen_@_1()">
			<attribute name="public"/>
			<stacksize value="1"/>
		</member>
		<member name="M:_@yH" syntax="_@yH(&amp;a, &amp;b, &amp;c, &amp;d, &amp;e, &amp;f)">
			<stacksize value="1"/>
			<referrer name="Hooks_GenerateContinue"/>
			<param name="a">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="b">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="c">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="d">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="e">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="f">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:_Hooks_AddReplacement" syntax="_Hooks_AddReplacement(longName[], shortName[])">
			<stacksize value="5"/>
			<referrer name="@_yHCheckpoint"/>
			<referrer name="@_yHContainer"/>
			<referrer name="@_yHInventory"/>
			<referrer name="@_yHDynamic"/>
			<referrer name="@_yHTextDraw"/>
			<referrer name="@_yHUpdate"/>
			<referrer name="@_yHObject"/>
			<referrer name="@_yHCommand"/>
			<referrer name="@_yHDynamicCP"/>
			<dependency name="Debug_Print0"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_LONG"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MAX"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_MIN"/>
			<dependency name="E_HOOK_NAME_REPLACEMENT_SHORT"/>
			<dependency name="YSI_g_sReplacePtr"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacements"/>
			<dependency name="YSI_g_sReplacementsLongOrder"/>
			<dependency name="YSI_g_sReplacementsShortOrder"/>
			<dependency name="strcat"/>
			<dependency name="strlen"/>
			<param name="longName">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="shortName">
				<paraminfo> [] </paraminfo>
			</param>
			<remarks>  Call the main hook run code, then advance the ALS chain.  </remarks> 
		</member>
		<member name="M:_Hooks_RepairStub" syntax="_Hooks_RepairStub()">
			<stacksize value="5"/>
			<referrer name="_Hooks_RepairStubFS"/>
			<referrer name="_Hooks_RepairStubGM"/>
			<dependency name="AMX_BASE_ADDRESS"/>
			<dependency name="AMX_HEADER_PUBLICS"/>
			<dependency name="AMX_Read"/>
			<dependency name="AMX_Write"/>
			<dependency name="ResetStaticAmxHeader"/>
			<dependency name="YSI_g_sInitFSIdx"/>
			<dependency name="YSI_g_sInitFSRep"/>
			<dependency name="YSI_g_sInitGMIdx"/>
			<dependency name="YSI_g_sInitGMRep"/>
			<dependency name="YSI_g_sInitPublicDiff"/>
			<dependency name="YSI_g_sSortedOnce"/>
			<dependency name="true"/>
		</member>
		<member name="M:_Hooks_RepairStubFS" syntax="_Hooks_RepairStubFS()">
			<stacksize value="3"/>
			<referrer name="Hooks_RepairJITInit"/>
			<dependency name="YSI_g_sInitFSPtr"/>
			<dependency name="_Hooks_RepairStub"/>
		</member>
		<member name="M:_Hooks_RepairStubGM" syntax="_Hooks_RepairStubGM()">
			<stacksize value="3"/>
			<referrer name="Hooks_RepairJITInit"/>
			<dependency name="YSI_g_sInitGMPtr"/>
			<dependency name="_Hooks_RepairStub"/>
		</member>
		<member name="M:_PreHook_IncludeStates" syntax="_PreHook_IncludeStates()">
			<stacksize value="1"/>
			<automaton name="_ALS"/>
		</member>
		<member name="M:_ScriptInit_FixState" syntax="_ScriptInit_FixState()">
			<attribute name="public"/>
			<stacksize value="1"/>
			<automaton name="_script_init_fix_state"/>
		</member>
		<member name="M:_SetColourHash" syntax="_SetColourHash(hash, color)">
			<stacksize value="5"/>
			<referrer name="@@_SetColourHash"/>
			<dependency name="GetColourHash"/>
			<dependency name="YSI_g_sColours"/>
			<dependency name="YSI_g_sColours"/>
			<dependency name="true"/>
			<param name="hash">
			</param>
			<param name="color">
			</param>
		</member>
		<member name="M:_SetColoursCanHaveSpaces" syntax="_SetColoursCanHaveSpaces(set)">
			<stacksize value="1"/>
			<referrer name="@@_SetColoursCanHaveSpaces"/>
			<dependency name="YSI_g_sCheckSpaces"/>
			<param name="set">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:_YSI_ConstMod" syntax="_YSI_ConstMod(&amp;var, val)">
			<stacksize value="1"/>
			<param name="var">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="val">
			</param>
		</member>
		<member name="M:__CompilerSecondPass" syntax="__CompilerSecondPass()">
			<stacksize value="1"/>
		</member>
		<member name="M:__MACRO__Debug_Code1" syntax="__MACRO__Debug_Code1(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code1(if (bla == 2) { bla++; YSI_PrintF("%d", bla); });  </code>  Or:  <code>  C:1(if (bla == 2) { bla++; YSI_PrintF("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 1</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Code2" syntax="__MACRO__Debug_Code2(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code2(if (bla == 2) { bla++; YSI_PrintF("%d", bla); });  </code>  Or:  <code>  C:2(if (bla == 2) { bla++; YSI_PrintF("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 2</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Code3" syntax="__MACRO__Debug_Code3(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code3(if (bla == 2) { bla++; YSI_PrintF("%d", bla); });  </code>  Or:  <code>  C:3(if (bla == 2) { bla++; YSI_PrintF("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 3</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Code4" syntax="__MACRO__Debug_Code4(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code4(if (bla == 2) { bla++; YSI_PrintF("%d", bla); });  </code>  Or:  <code>  C:4(if (bla == 2) { bla++; YSI_PrintF("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 4</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Code5" syntax="__MACRO__Debug_Code5(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code5(if (bla == 2) { bla++; YSI_PrintF("%d", bla); });  </code>  Or:  <code>  C:5(if (bla == 2) { bla++; YSI_PrintF("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 5</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Code6" syntax="__MACRO__Debug_Code6(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code6(if (bla == 2) { bla++; YSI_PrintF("%d", bla); });  </code>  Or:  <code>  C:6(if (bla == 2) { bla++; YSI_PrintF("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 6</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Code7" syntax="__MACRO__Debug_Code7(code)">
			<stacksize value="1"/>
			<param name="code">
				Code to run.
			</param>
			  <remarks>  Code is not a variable, it's a code chunk and may be written as so:  <code>  Debug_Code7(if (bla == 2) { bla++; YSI_PrintF("%d", bla); });  </code>  Or:  <code>  C:7(if (bla == 2) { bla++; YSI_PrintF("%d", bla); });  </code>  The code must all be on one line to avoid errors.  This isn't really a function as the first parameter is part of the name.  Only compiles the code when <c>_DEBUG %gt;= 7</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Print1" syntax="__MACRO__Debug_Print1(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print1("variables: %d, %d", i, j);  </code>  Or:  <code>  P:1("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 1</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Print2" syntax="__MACRO__Debug_Print2(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print2("variables: %d, %d", i, j);  </code>  Or:  <code>  P:2("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 2</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Print3" syntax="__MACRO__Debug_Print3(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print3("variables: %d, %d", i, j);  </code>  Or:  <code>  P:3("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 3</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Print4" syntax="__MACRO__Debug_Print4(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print4("variables: %d, %d", i, j);  </code>  Or:  <code>  P:4("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 4</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Print5" syntax="__MACRO__Debug_Print5(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print5("variables: %d, %d", i, j);  </code>  Or:  <code>  P:5("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 5</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Print6" syntax="__MACRO__Debug_Print6(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print6("variables: %d, %d", i, j);  </code>  Or:  <code>  P:6("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 6</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__Debug_Print7" syntax="__MACRO__Debug_Print7(str[], ...)">
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				Format.
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
				
			</param>
			    <remarks>  This isn't really a function as the first parameter is part of the name:  <code>  Debug_Print7("variables: %d, %d", i, j);  </code>  Or:  <code>  P:7("variables: %d, %d", i, j);  </code>  Only prints the data when <c>_DEBUG %gt;= 7</c>.  </remarks> 
		</member>
		<member name="M:__MACRO__GetIP" syntax="__MACRO__GetIP(playerid)">
			<stacksize value="1"/>
			<param name="playerid">
				Player to get IP of.
			</param>
			  <returns>  IP as a 32bit int.  </returns> 
		</member>
		<member name="M:__MACRO__IS_IN_RANGE" syntax="__MACRO__IS_IN_RANGE(value, lower, upper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				The number to compare.
			</param>
			<param name="lower">
				The lower limit.
			</param>
			<param name="upper">
				The upper limit.
			</param>
			      <returns>  Is the value in the given range.  </returns>  <remarks>  Equivalent to:  <code>		(%1) &lt;= (%0) &lt; (%2)</code>  </remarks> 
		</member>
		<member name="M:__MACRO__NOT_IN_RANGE" syntax="__MACRO__NOT_IN_RANGE(value, lower, upper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				The number to compare.
			</param>
			<param name="lower">
				The lower limit.
			</param>
			<param name="upper">
				The upper limit.
			</param>
			      <returns>  Is the value outside the given range.  </returns>  <remarks>  Equivalent to:  <code>		(%1) &lt;= (%0) &lt; (%2)</code>  </remarks> 
		</member>
		<member name="M:__MACRO__UCMP" syntax="__MACRO__UCMP(value, upper)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				The unsigned number to compare.
			</param>
			<param name="upper">
				The upper limit.
			</param>
			    <returns>  An unsigned comparison between the two values.  </returns> 
		</member>
		<member name="M:__MACRO__VALID_PLAYERID" syntax="__MACRO__VALID_PLAYERID(playerid)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="playerid">
				The player to check.
			</param>
			  <returns>  Is this a valid playerid (NOT, is the player connected).  </returns> 
		</member>
		<member name="M:__MACRO__ceildiv" syntax="__MACRO__ceildiv(numerator, denominator)">
			<stacksize value="1"/>
			<referrer name="Base64Encode"/>
			<param name="numerator">
				The top of the division.
			</param>
			<param name="denominator">
				The bottom of the division.
			</param>
			    <returns>  (numerator / denominator) rounded up.  </returns>  <remarks>  Normal integer division ALWAYS rounds down - this always rounds up.  </remarks> 
		</member>
		<member name="M:__MACRO__floordiv" syntax="__MACRO__floordiv(numerator, denominator)">
			<stacksize value="1"/>
			<param name="numerator">
				The top of the division.
			</param>
			<param name="denominator">
				The bottom of the division.
			</param>
			<summary>  floordiv(numerator, denominator);  </summary>      <returns>  (numerator / denominator) rounded down.  </returns>  <remarks>  Normal integer division ALWAYS rounds down - this also always rounds down,  making it a little pointless, but also more explicit in function.  </remarks> 
		</member>
		<member name="M:__MACRO__iseven" syntax="__MACRO__iseven(value)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				Value to check if is even.
			</param>
			 
		</member>
		<member name="M:__MACRO__isnull" syntax="__MACRO__isnull(str[])">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to check if is null.
			</param>
			  <remarks>  Uses a new shorter and branchless method, which also works with offsets so  this is valid:  <code>  new str[32]; isnull(str[5]);  </code>  </remarks> 
		</member>
		<member name="M:__MACRO__isodd" syntax="__MACRO__isodd(value)">
			<tagname value="bool"/>
			<stacksize value="1"/>
			<param name="value">
				Value to check if is odd.
			</param>
			 
		</member>
		<member name="M:__MACRO__strcpy" syntax="__MACRO__strcpy(dest[], src[], len)">
			<stacksize value="1"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
				Destination string.
			</param>
			<param name="src">
				<paraminfo> [] </paraminfo>
				Source string.
			</param>
			<param name="len">
				(Implicit) maximum length of the destination.
			</param>
			     
		</member>
		<member name="M:__TU" syntax="__TU(t, iters)">
			<stacksize value="27"/>
			<dependency name="operator/(Float:,Float:)"/>
			<dependency name="__TU"/>
			<dependency name="float"/>
			<dependency name="format"/>
			<param name="t">
				The time in ms.
			</param>
			<param name="iters">
				The number of iterations completed in this time.
			</param>
			    <remarks>  Formats and returns a string representing the time taken for one iteration,  given the time required for many iterations.  This attempts to format the  number using a reasonable fraction of a second.  </remarks> 
		</member>
		<member name="M:__ppAsyncMySQLError" syntax="__ppAsyncMySQLError(callback_handler, task_handle, errorid, error[], callback[], query[], handle)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<dependency name="operator==(Handle:,Handle:)"/>
			<dependency name="amx_err_exit"/>
			<dependency name="amx_try_decode_value"/>
			<dependency name="handle_get"/>
			<dependency name="handle_linked"/>
			<dependency name="handle_release"/>
			<dependency name="pawn_unregister_callback"/>
			<dependency name="task_set_error"/>
			<param name="callback_handler">
				<paraminfo>CallbackHandler </paraminfo>
			</param>
			<param name="task_handle">
				<paraminfo>Handle </paraminfo>
			</param>
			<param name="errorid">
			</param>
			<param name="error">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="callback">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="query">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="handle">
				<paraminfo>MySQL </paraminfo>
			</param>
		</member>
		<member name="M:__ppAsyncMySQLHandler" syntax="__ppAsyncMySQLHandler(callback_handler, task_handle)">
			<attribute name="public"/>
			<stacksize value="6"/>
			<dependency name="handle_get"/>
			<dependency name="handle_linked"/>
			<dependency name="handle_release"/>
			<dependency name="pawn_unregister_callback"/>
			<dependency name="task_set_result"/>
			<dependency name="true"/>
			<param name="callback_handler">
				<paraminfo>CallbackHandler </paraminfo>
			</param>
			<param name="task_handle">
				<paraminfo>Handle </paraminfo>
			</param>
		</member>
		<member name="M:_pp@on_exit@PPAsyncDialogs" syntax="_pp@on_exit@PPAsyncDialogs()">
			<attribute name="public"/>
			<stacksize value="3"/>
			<dependency name="AsyncDialogResponseHandler"/>
			<dependency name="pawn_unregister_callback"/>
		</member>
		<member name="M:_pp@on_init@PPAsyncDialogs" syntax="_pp@on_init@PPAsyncDialogs()">
			<attribute name="public"/>
			<stacksize value="6"/>
			<dependency name="AsyncDialogResponseHandler"/>
			<dependency name="pawn_register_callback"/>
			<dependency name="wait_ticks"/>
		</member>
		<member name="M:_yH@" syntax="_yH@(compressedFormat)">
			<stacksize value="34"/>
			<dependency name="AMX_HEADER_COD"/>
			<dependency name="AsmContext"/>
			<dependency name="AsmEmitCallAbs"/>
			<dependency name="AsmEmitHeap"/>
			<dependency name="AsmEmitLctrl"/>
			<dependency name="AsmEmitLoadPri"/>
			<dependency name="AsmEmitMovs"/>
			<dependency name="AsmEmitPadding"/>
			<dependency name="AsmEmitPopAlt"/>
			<dependency name="AsmEmitPopPri"/>
			<dependency name="AsmEmitProc"/>
			<dependency name="AsmEmitPush"/>
			<dependency name="AsmEmitPushAlt"/>
			<dependency name="AsmEmitPushC"/>
			<dependency name="AsmEmitPushPri"/>
			<dependency name="AsmEmitRetn"/>
			<dependency name="AsmEmitStack"/>
			<dependency name="AsmEmitStorAlt"/>
			<dependency name="AsmEmitSysreqC"/>
			<dependency name="AsmInitPtr"/>
			<dependency name="DisasmContext"/>
			<dependency name="DisasmGetOpcode"/>
			<dependency name="DisasmGetOperand"/>
			<dependency name="DisasmGetOperandReloc"/>
			<dependency name="DisasmInit"/>
			<dependency name="DisasmNext"/>
			<dependency name="GetCurrentFrameReturn"/>
			<dependency name="OP_CALL"/>
			<dependency name="OP_SYSREQ_C"/>
			<dependency name="OP_SYSREQ_D"/>
			<dependency name="YSI_g_sNPSBaseCall"/>
			<dependency name="YSI_g_sNPSReplace"/>
			<dependency name="YSI_g_sNPSStack"/>
			<dependency name="YSI_g_sNPSTrampoline"/>
			<dependency name="YSI_g_sTempRet"/>
			<dependency name="cellbits"/>
			<dependency name="cellmin"/>
			<dependency name="ref"/>
			<param name="compressedFormat">
			</param>
		</member>
		<member name="M:account_CheckIfExists" syntax="account_CheckIfExists(playerid, race_check)">
			<stacksize value="32"/>
			<referrer name="@yH_OnPlayerConnect@002"/>
			<dependency name="AmxString:operator=(String:)"/>
			<dependency name="AK_Kick"/>
			<dependency name="Database_ReturnHandle"/>
			<dependency name="Misc_ReturnName"/>
			<dependency name="Misc_ReturnName"/>
			<dependency name="auth_RaceCheck"/>
			<dependency name="mysql_tquery_s"/>
			<dependency name="str_format"/>
			<param name="playerid">
			</param>
			<param name="race_check">
			</param>
		</member>
		<member name="M:amx_encode_value_public_name" syntax="amx_encode_value_public_name(function[], value)">
			<attribute name="native"/>
			<referrer name="mysql_aquery"/>
			<referrer name="mysql_aquery_s"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
				<paraminfo> {_,bool,Float,Variant,String,List,LinkedList,Map,Pool,Iter,Handle,Task,Expression} </paraminfo>
			</param>
		</member>
		<member name="M:amx_try_decode_value" syntax="amx_try_decode_value(encoded[], &amp;value)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="__ppAsyncMySQLError"/>
			<param name="encoded">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="value">
				<paraminfo> {_,bool,Float,Variant,String,List,LinkedList,Map,Pool,Iter,Handle,Task,Expression} &amp; </paraminfo>
			</param>
		</member>
		<member name="M:amx_yield" syntax="amx_yield(val)">
			<stacksize value="1"/>
			<param name="val">
			</param>
		</member>
		<member name="M:argderef" syntax="argderef(n)">
			<stacksize value="1"/>
			<dependency name="argderef"/>
			<param name="n">
			</param>
		</member>
		<member name="M:argref" syntax="argref(n)">
			<stacksize value="1"/>
			<param name="n">
			</param>
		</member>
		<member name="M:bcrypt_check" syntax="bcrypt_check(password[], hash[], callback_name[], callback_format[], ...)">
			<attribute name="native"/>
			<referrer name="Account_LoginDialog"/>
			<param name="password">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="hash">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="callback_name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="callback_format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:bcrypt_get_hash" syntax="bcrypt_get_hash(dest[])">
			<attribute name="native"/>
			<referrer name="OnPasswordHashed"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:bcrypt_hash" syntax="bcrypt_hash(key[], cost, callback_name[], callback_format[], ...)">
			<attribute name="native"/>
			<referrer name="Account_RegisterHandler"/>
			<param name="key">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="cost">
			</param>
			<param name="callback_name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="callback_format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:bcrypt_is_equal" syntax="bcrypt_is_equal()">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="OnPasswordChecked"/>
		</member>
		<member name="M:bernstein" syntax="bernstein(string[])">
			<stacksize value="4"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				the string to hash.
			</param>
			  <returns>  the bernstein hash of the input string  </returns>  <remarks>  This is a 32bit hash system so is not very secure, however we're only  using this as a string enumerator to uniquely identify strings easilly  and allow for a binary search of strings based on the hash of their name.  crc32, then jenkins were originally used however this is far faster, if a  little collision prone, but we're checking the strings manually anyway.  This doesn't matter as it would be done regardless of hash method, so this  doesn't need to be accounted for.  Speed is all that matters with at   least a bit of non collision (the number of strings we're dealing with,  this should have none-few collisions).  I modified it slightly from the original code pasted by aru, to code  closer to the code <a href="http://www.burtleburtle.net/bob/hash/doobs.html" />  and to work with PAWN (and shaved 0.2s off the time for one call :D).  Uber reduced version (just for fun):  b(s[]){new h=-1,i,j;while((j=s[i++]))h=h*33+j;return h;}  Update: Contrary to what I said above this is also used to identify colour  strings for the updated text system involving file based styling and this  is not checked for collisions as it's unimportant.  But this doesn't affect  the function at all, I just mentioned it here for "interest".  </remarks> 
		</member>
		<member name="M:binstr" syntax="binstr(string[])">
			<stacksize value="3"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				String to try convert to a boolean.
			</param>
			  <returns>  bool: passed boolean.  </returns>  <remarks>  This takes a value in 0110101 (boolean) format and returns it as a  regular value.  </remarks> 
		</member>
		<member name="M:boolstr" syntax="boolstr(string[])">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="strcmp"/>
			<dependency name="true"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				String to try convert to a boolean.
			</param>
			  <returns>  bool: passed boolean.  </returns>  <remarks>  This can take a number of ways of representing booleans - 0, false and  nothing there.  Anything not one of those things (false is not case  sensitive) is assumed true.  </remarks> 
		</member>
		<member name="M:cache_get_field_count" syntax="cache_get_field_count(&amp;destination)">
			<attribute name="native"/>
			<referrer name="cache_num_fields"/>
			<param name="destination">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:cache_get_result_count" syntax="cache_get_result_count(&amp;destination)">
			<attribute name="native"/>
			<referrer name="cache_num_results"/>
			<param name="destination">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:cache_get_row_count" syntax="cache_get_row_count(&amp;destination)">
			<attribute name="native"/>
			<referrer name="cache_num_rows"/>
			<param name="destination">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:cache_get_value_index_bool" syntax="cache_get_value_index_bool(row_idx, column_idx, &amp;destination)">
			<stacksize value="5"/>
			<dependency name="cache_get_value_index_int"/>
			<param name="row_idx">
			</param>
			<param name="column_idx">
			</param>
			<param name="destination">
				<paraminfo>bool &amp; </paraminfo>
			</param>
		</member>
		<member name="M:cache_get_value_index_int" syntax="cache_get_value_index_int(row_idx, column_idx, &amp;destination)">
			<attribute name="native"/>
			<referrer name="cache_get_value_index_bool"/>
			<param name="row_idx">
			</param>
			<param name="column_idx">
			</param>
			<param name="destination">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:cache_get_value_name" syntax="cache_get_value_name(row_idx, column_name[], destination[], max_len)">
			<attribute name="native"/>
			<referrer name="OnPlayerAccountChecked"/>
			<param name="row_idx">
			</param>
			<param name="column_name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="destination">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="max_len">
			</param>
		</member>
		<member name="M:cache_get_value_name_bool" syntax="cache_get_value_name_bool(row_idx, column_name[], &amp;destination)">
			<stacksize value="5"/>
			<dependency name="cache_get_value_name_int"/>
			<param name="row_idx">
			</param>
			<param name="column_name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="destination">
				<paraminfo>bool &amp; </paraminfo>
			</param>
		</member>
		<member name="M:cache_get_value_name_int" syntax="cache_get_value_name_int(row_idx, column_name[], &amp;destination)">
			<attribute name="native"/>
			<referrer name="cache_get_value_name_bool"/>
			<param name="row_idx">
			</param>
			<param name="column_name">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="destination">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:cache_insert_id" syntax="cache_insert_id()">
			<attribute name="native"/>
			<referrer name="OnPlayerRegister"/>
		</member>
		<member name="M:cache_num_fields" syntax="cache_num_fields()">
			<stacksize value="4"/>
			<dependency name="cache_get_field_count"/>
		</member>
		<member name="M:cache_num_results" syntax="cache_num_results()">
			<stacksize value="4"/>
			<dependency name="cache_get_result_count"/>
		</member>
		<member name="M:cache_num_rows" syntax="cache_num_rows()">
			<stacksize value="4"/>
			<referrer name="OnPlayerAccountChecked"/>
			<dependency name="cache_get_row_count"/>
		</member>
		<member name="M:chrfind" syntax="chrfind(needle, haystack[], start)">
			<stacksize value="3"/>
			<dependency name="strlen"/>
			<param name="needle">
				The character to find.
			</param>
			<param name="haystack">
				<paraminfo> [] </paraminfo>
				The string to find it in.
			</param>
			<param name="start">
				The offset to start from.
			</param>
			      <returns>  Fail - -1, Success - pos  </returns> 
		</member>
		<member name="M:chrfindp" syntax="chrfindp(needle, haystack[], start)">
			<stacksize value="1"/>
			<param name="needle">
				The character to find.
			</param>
			<param name="haystack">
				<paraminfo> [] </paraminfo>
				The string to find it in.
			</param>
			<param name="start">
				The offset to start from.
			</param>
			      <returns>  Fail - -1, Success - pos  </returns>  <remarks>  Like <symbolref name="chrfind" />, but with no upper-bounds check on  <paramref name="start" />.  </remarks> 
		</member>
		<member name="M:closeSql" syntax="closeSql()">
			<stacksize value="3"/>
			<referrer name="@yH_OnGameModeExit@001"/>
			<dependency name="Database_ReturnHandle"/>
			<dependency name="mysql_close"/>
		</member>
		<member name="M:copy_1" syntax="copy_1(&amp;dest, source[], start)">
			<stacksize value="1"/>
			<referrer name="GetAmxHeaderNow"/>
			<param name="dest">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:copy_2" syntax="copy_2(&amp;dest, source[], start)">
			<stacksize value="1"/>
			<referrer name="GetAmxHeaderNow"/>
			<param name="dest">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:copy_4" syntax="copy_4(&amp;dest, source[], start)">
			<stacksize value="1"/>
			<referrer name="GetAmxHeaderNow"/>
			<param name="dest">
				<paraminfo> &amp; </paraminfo>
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="start">
			</param>
		</member>
		<member name="M:deref" syntax="deref(v)">
			<stacksize value="1"/>
			<dependency name="deref"/>
			<param name="v">
			</param>
		</member>
		<member name="M:endofline" syntax="endofline(line[], pos)">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<dependency name="strlen"/>
			<param name="line">
				<paraminfo> [] </paraminfo>
				String to check.
			</param>
			<param name="pos">
				Postion to start from.
			</param>
			    <remarks>  Checks if the current point in a line is the end of non-whitespace data.  </remarks> 
		</member>
		<member name="M:expr_const" syntax="expr_const(value, tag_id)">
			<tagname value="Expression"/>
			<attribute name="native"/>
			<referrer name="Expression:operator=(_:)"/>
			<referrer name="Expression:operator=(Float:)"/>
			<referrer name="Expression:operator=(bool:)"/>
			<param name="value">
				<paraminfo> {_,bool,Float,Variant,String,List,LinkedList,Map,Pool,Iter,Handle,Task,Expression} </paraminfo>
			</param>
			<param name="tag_id">
				<paraminfo> {_,tag_uid} </paraminfo>
			</param>
		</member>
		<member name="M:fblockwrite" syntax="fblockwrite(handle, buffer[], size)">
			<attribute name="native"/>
			<referrer name="DumpAMX_WriteAMXHeader"/>
			<referrer name="DumpAMX_WriteEncoded"/>
			<referrer name="DumpAMX_Write"/>
			<param name="handle">
				<paraminfo>File </paraminfo>
				The File handle to use, opened by fopen()
			</param>
			<param name="buffer">
				<paraminfo> [] </paraminfo>
				The data to write to the file
			</param>
			<param name="size">
				The number of cells to write (optional=<b><c>sizeof buffer</c></b>)
			</param>
			<summary>Write data to a file in binary format, while ignoring line brakes and encoding.</summary>    <remarks>Using an <b>invalid handle</b> will crash your server! Get a <b>valid handle</b> by using <a href="#fopen">fopen</a> or <a href="#ftemp">ftemp</a>.</remarks>
		</member>
		<member name="M:fclose" syntax="fclose(handle)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="y_profile_WTF"/>
			<referrer name="ftouch"/>
			<referrer name="DisasmWrite"/>
			<referrer name="DumpAMX_Write"/>
			<param name="handle">
				<paraminfo>File </paraminfo>
				The file handle to close. Returned by <a href="#fopen">fopen</a>
			</param>
			<summary>Closes a file. Files should always be closed when the script no longer needs them (after reading/writing).</summary>  <remarks>Using an <b>invalid handle</b> will crash your server! Get a <b>valid handle</b> by using <a href="#fopen">fopen</a> or <a href="#ftemp">ftemp</a>.</remarks> <returns> <b><c>true</c></b>: The function executed successfully.<p/> <b><c>false</c></b>: The function failed to execute. The file could not be closed. It may already be closed. </returns>
		</member>
		<member name="M:fexist" syntax="fexist(name[])">
			<attribute name="native"/>
			<referrer name="y_profile_WTF"/>
			<referrer name="ftouch"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The name of the file
			</param>
			<summary>Checks if a specific file exists in the <b><c>/scriptfiles</c></b> directory.</summary>  <returns>1 if the file exists, 0 otherwise.</returns>
		</member>
		<member name="M:flength" syntax="flength(handle)">
			<attribute name="native"/>
			<referrer name="DumpAMX_Write"/>
			<param name="handle">
				<paraminfo>File </paraminfo>
				The file handle returned by <a href="#fopen">fopen</a> or <a href="#ftemp">ftemp</a>
			</param>
			<summary>Returns the length of a file.</summary>  <remarks>Using an <b>invalid handle</b> will crash your server! Get a <b>valid handle</b> by using <a href="#fopen">fopen</a> or <a href="#ftemp">ftemp</a>.</remarks> <returns>The length of a file, in bytes.</returns>
		</member>
		<member name="M:float" syntax="float(value)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator*(Float:,_:)"/>
			<referrer name="operator/(Float:,_:)"/>
			<referrer name="operator/(_:,Float:)"/>
			<referrer name="operator+(Float:,_:)"/>
			<referrer name="operator-(Float:,_:)"/>
			<referrer name="operator-(_:,Float:)"/>
			<referrer name="operator==(Float:,_:)"/>
			<referrer name="operator!=(Float:,_:)"/>
			<referrer name="operator&gt;(Float:,_:)"/>
			<referrer name="operator&gt;(_:,Float:)"/>
			<referrer name="operator&gt;=(Float:,_:)"/>
			<referrer name="operator&gt;=(_:,Float:)"/>
			<referrer name="operator&lt;(Float:,_:)"/>
			<referrer name="operator&lt;(_:,Float:)"/>
			<referrer name="operator&lt;=(Float:,_:)"/>
			<referrer name="operator&lt;=(_:,Float:)"/>
			<referrer name="__TU"/>
			<referrer name="RandomFloat"/>
			<param name="value">
			</param>
		</member>
		<member name="M:floatadd" syntax="floatadd(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator+(Float:,_:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
				First float
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
				Second float
			</param>
			<summary>Adds two floats together. This function is redundant as the standard operator (+) does the same thing.</summary>   <seealso name="floatsub"/> <seealso name="floatmul"/> <seealso name="floatdiv"/> <returns>The sum of the two given floats.</returns>
		</member>
		<member name="M:floatcmp" syntax="floatcmp(oper1, oper2)">
			<attribute name="native"/>
			<referrer name="operator==(Float:,Float:)"/>
			<referrer name="operator==(Float:,_:)"/>
			<referrer name="operator!=(Float:,Float:)"/>
			<referrer name="operator!=(Float:,_:)"/>
			<referrer name="operator&gt;(Float:,Float:)"/>
			<referrer name="operator&gt;(Float:,_:)"/>
			<referrer name="operator&gt;(_:,Float:)"/>
			<referrer name="operator&gt;=(Float:,Float:)"/>
			<referrer name="operator&gt;=(Float:,_:)"/>
			<referrer name="operator&gt;=(_:,Float:)"/>
			<referrer name="operator&lt;(Float:,Float:)"/>
			<referrer name="operator&lt;(Float:,_:)"/>
			<referrer name="operator&lt;(_:,Float:)"/>
			<referrer name="operator&lt;=(Float:,Float:)"/>
			<referrer name="operator&lt;=(Float:,_:)"/>
			<referrer name="operator&lt;=(_:,Float:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
				The first float value to compare
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
				The second float value to compare
			</param>
			<summary>floatcmp can be used to compare float values to each other, to validate the comparison.</summary>   <returns><b><c>0</c></b> if value does match, <b><c>1</c></b> if the first value is bigger and <b><c>-1</c></b> if the 2nd value is bigger.</returns>
		</member>
		<member name="M:floatdiv" syntax="floatdiv(dividend, divisor)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator/(Float:,_:)"/>
			<referrer name="operator/(_:,Float:)"/>
			<param name="dividend">
				<paraminfo>Float </paraminfo>
				First float
			</param>
			<param name="divisor">
				<paraminfo>Float </paraminfo>
				Second float (dividates the first float.)
			</param>
			<summary>Divide one float by another one. Redundant as the division operator (/) does the same thing.</summary>   <seealso name="floatadd"/> <seealso name="floatsub"/> <seealso name="floatmul"/> <returns>The quotient of the two given floats.</returns>
		</member>
		<member name="M:floatmul" syntax="floatmul(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator*(Float:,_:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
				First Float
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
				Second Float, the first one gets multiplied with
			</param>
			<summary>Multiplies two floats with each other.</summary>   <seealso name="floatadd"/> <seealso name="floatsub"/> <seealso name="floatdiv"/> <returns>The product of the two given floats.</returns>
		</member>
		<member name="M:floatpower" syntax="floatpower(value, exponent)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="RandomFloat"/>
			<param name="value">
				<paraminfo>Float </paraminfo>
				The value to raise to a power, as a floating-point number
			</param>
			<param name="exponent">
				<paraminfo>Float </paraminfo>
				The exponent is also a floating-point number. It may be zero or negative
			</param>
			<summary>Raises the given value to the power of the exponent.</summary>   <seealso name="floatsqroot"/> <seealso name="floatlog"/> <returns>The result of 'value' to the power of 'exponent'.</returns>
		</member>
		<member name="M:floatround" syntax="floatround(value, method)">
			<attribute name="native"/>
			<referrer name="RandomFloat"/>
			<param name="value">
				<paraminfo>Float </paraminfo>
				The value to round
			</param>
			<param name="method">
				<paraminfo>floatround_method </paraminfo>
				The floatround method to use (optional=<b><c>floatround_round</c></b>)
			</param>
			<summary>Round a floating point number to an integer value.</summary>   <seealso name="float"/> <seealso name="floatstr"/> <remarks> <b>Rounding methods:</b><p/> <ul> <li><b><c>floatround_round</c></b> - round to the nearest integer. A fractional part of exactly 0.5 rounds upwards (this is the default).</li> <li><b><c>floatround_floor</c></b> - round downwards.</li> <li><b><c>floatround_ceil</c></b> - round upwards.</li> <li><b><c>floatround_tozero</c></b> - round downwards for positive values and upwards for negative values ("truncate").</li> </ul> </remarks> <returns>The rounded value as an integer.</returns>
		</member>
		<member name="M:floatsub" syntax="floatsub(oper1, oper2)">
			<tagname value="Float"/>
			<attribute name="native"/>
			<referrer name="operator-(Float:,_:)"/>
			<referrer name="operator-(_:,Float:)"/>
			<param name="oper1">
				<paraminfo>Float </paraminfo>
				First Float
			</param>
			<param name="oper2">
				<paraminfo>Float </paraminfo>
				Second Float (gets subtracted from the first float.)
			</param>
			<summary>Subtracts one float from another one. Note that this function has no real use, as one can simply use the standard operator (-) instead.</summary>   <seealso name="floatadd"/> <seealso name="floatmul"/> <seealso name="floatdiv"/> <returns>The difference of the two given floats.</returns>
		</member>
		<member name="M:fopen" syntax="fopen(name[], mode)">
			<tagname value="File"/>
			<attribute name="native"/>
			<referrer name="y_profile_WTF"/>
			<referrer name="ftouch"/>
			<referrer name="DisasmWrite"/>
			<referrer name="DumpAMX_Write"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The path to the file to open (if just a filename is specified, it will open the file with the name specified in the 'scriptfiles' folder)
			</param>
			<param name="mode">
				<paraminfo>filemode </paraminfo>
				The mode to open the file with, see below (optional=<b><c>io_readwrite</c></b>)
			</param>
			<summary>Open a file (to read from or write to).</summary>   <remarks>This function can't access files outside the 'scriptfiles' folder!</remarks> <remarks>If you use <a href="#io_read">io_read</a> and the file doesn't exist, it will return a <b><c>NULL</c></b> reference. Using <b>invalid references</b> on file functions will <b>crash</b> your server!</remarks> <remarks> <b>Modes:</b><p/> <ul> <li><b><c>io_read</c></b> - reads from the file.</li> <li><b><c>io_write</c></b> - write in the file, or create the file if it does not exist. Erases all existing contents.</li> <li><b><c>io_readwrite</c></b> - reads the file or creates it if it doesn't already exist.</li> <li><b><c>io_append</c></b> - appends (adds) to file, write-only. If the file does not exist, it is created.</li> </ul> </remarks> <returns>Returns the file handle. This handle is used for reading and writing. <b><c>0</c></b> if failed to open file.</returns>
		</member>
		<member name="M:format" syntax="format(output[], len, format[], ...)">
			<attribute name="native"/>
			<referrer name="Debug_PrintArray"/>
			<referrer name="__TU"/>
			<referrer name="va_return"/>
			<param name="output">
				<paraminfo> [] </paraminfo>
				The string to output the result to
			</param>
			<param name="len">
				The maximum length output can contain
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
				The format string
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
				Indefinite number of arguments of any tag
			</param>
			<summary>Formats a string to include variables and other strings inside it.</summary>     <seealso name="print"/> <seealso name="printf"/> <remarks>This function doesn't support <a href="#strpack">packed strings</a>.</remarks> <remarks> <b>Format Specifiers:</b><p/> <ul> <li><b><c>%i</c></b> - integer (whole number)</li> <li><b><c>%d</c></b> - integer (whole number).</li> <li><b><c>%s</c></b> - string</li> <li><b><c>%f</c></b> - floating-point number (Float: tag)</li> <li><b><c>%c</c></b> - ASCII character</li> <li><b><c>%x</c></b> - hexadecimal number</li> <li><b><c>%b</c></b> - binary number</li> <li><b><c>%%</c></b> - literal <b><c>%</c></b></li> <li><b><c>%q</c></b> - escape a text for SQLite. (Added in <b>0.3.7 R2</b>)</li> </ul> </remarks> <remarks>The values for the placeholders follow in the exact same order as parameters in the call. For example, <b><c>"I am %i years old"</c></b> - the <b><c>%i</c></b> will be replaced with an Integer variable, which is the person's age.</remarks> <remarks>You may optionally put a number between the <b><c>%</c></b> and the letter of the placeholder code. This number indicates the field width; if the size of the parameter to print at the position of the placeholder is smaller than the field width, the field is expanded with spaces. To cut the number of decimal places beeing shown of a float, you can add <b><c>.&lt;max number&gt;</c></b> between the <b><c>%</c></b> and the <b><c>f</c></b>. (example: <b><c>%.2f</c></b>)</remarks>
		</member>
		<member name="M:fseek" syntax="fseek(handle, position, whence)">
			<attribute name="native"/>
			<referrer name="DumpAMX_Write"/>
			<param name="handle">
				<paraminfo>File </paraminfo>
				The file handle to use. Returned by <a href="#fopen">fopen</a>
			</param>
			<param name="position">
				The new position in the file, relative to the parameter whence (see below) (optional=<b><c>0</c></b>)
			</param>
			<param name="whence">
				<paraminfo>seek_whence </paraminfo>
				The starting position to which parameter position relates (optional=<b><c>seek_start</c></b>)
			</param>
			<summary>Change the current position in the file. You can either seek forward or backward through the file.</summary>    <remarks>Using an <b>invalid handle</b> will crash your server! Get a <b>valid handle</b> by using <a href="#fopen">fopen</a> or <a href="#ftemp">ftemp</a>.</remarks> <remarks> <b>Whences:</b><p/> <ul> <li><b><c>seek_start</c></b> - set the file position relative to the start of the file (the position parameter must be positive).</li> <li><b><c>seek_current</c></b> - set the file position relative to the current file position: the position parameter is added to the current position.</li> <li><b><c>seek_end</c></b> - set the file position relative to the end of the file (parameter position must be zero or negative).</li> </ul> </remarks>
		</member>
		<member name="M:ftouch" syntax="ftouch(filename[])">
			<stacksize value="5"/>
			<dependency name="fclose"/>
			<dependency name="fexist"/>
			<dependency name="fopen"/>
			<dependency name="io_write"/>
			<param name="filename">
				<paraminfo> [] </paraminfo>
				The file to "touch".
			</param>
			<summary>  ftouch(filename);  </summary>    <returns>  0 - File already exists.  1 - File was created.  -1 - File was not created.  </returns>  <remarks>  This "touches" a file in the Unix sense of creating it but not opening or  editing it in any way.  </remarks> 
		</member>
		<member name="M:funcidx" syntax="funcidx(name[])">
			<attribute name="native"/>
			<referrer name="Indirect_Call"/>
			<referrer name="Indirect_Callstring"/>
			<referrer name="Indirect_Callvoid"/>
			<referrer name="Indirect_Array"/>
			<referrer name="CGen_GetAddr"/>
			<referrer name="CGen_OnCodeInit"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The name of the public function to get the ID of
			</param>
			<summary>This function returns the ID of a public function by its name.</summary>  <seealso name="CallLocalFunction"/> <seealso name="CallRemoteFunction"/> <returns>The ID of the function (IDs start at <b><c>0</c></b>). <b><c>-1</c></b> if the function doesn't exist.</returns>
		</member>
		<member name="M:fwrite" syntax="fwrite(handle, string[])">
			<attribute name="native"/>
			<referrer name="y_profile_WTF"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="DisasmWriteDataRowChar"/>
			<referrer name="DisasmWriteDataRowHex"/>
			<referrer name="DisasmWriteData"/>
			<param name="handle">
				<paraminfo>File </paraminfo>
				The handle of the file to write to (returned by <a href="#fopen">fopen</a>)
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
				The string of text to write in to the file
			</param>
			<summary>Write text into a file.</summary>   <remarks>Using an <b>invalid handle</b> will crash your server! Get a <b>valid handle</b> by using <a href="#fopen">fopen</a> or <a href="#ftemp">ftemp</a>.</remarks> <remarks>This functions writes to the file in UTF-8, which does not support some localized language symbols.</remarks> <remarks>This function doesn't support <a href="#strpack">packed strings</a>.</remarks> <returns>The length of the written string as an integer.</returns>
		</member>
		<member name="M:getarg" syntax="getarg(arg, index)">
			<attribute name="native"/>
			<referrer name="L@"/>
			<referrer name="T@"/>
			<referrer name="AsmEmitInstruction"/>
			<referrer name="CodeScanMatcherPattern_"/>
			<param name="arg">
				The argument sequence number. Use <b><c>0</c></b> for first argument
			</param>
			<param name="index">
				The index (in case the argument is an array) (optional=<b><c>0</c></b>)
			</param>
			<summary>Get an argument that was passed to a function.</summary>   <seealso name="numargs"/> <seealso name="setarg"/> <returns>The value of the argument.</returns>
		</member>
		<member name="M:getproperty" syntax="getproperty(id, name[], value, string[])">
			<attribute name="native"/>
			<referrer name="K@"/>
			<referrer name="D@"/>
			<param name="id">
				The <a href="http://en.wikipedia.org/wiki/Virtual_machine">virtual machine</a> to use, you should keep this zero (optional=<b><c>0</c></b>)
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The property's name, you should keep this "" (optional=<b><c>""</c></b>)
			</param>
			<param name="value">
				The property's unique ID, Use the hash-function to calculate it from a string (optional=<b><c>cellmin</c></b>)
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
				The variable to store the result in, passed by reference (optional=<b><c>""</c></b>)
			</param>
			<summary>Get a specific property from the memory, the string is returned as a packed string!.</summary>     <seealso name="Setproperty"/> <seealso name="Deleteproperty"/> <seealso name="Existproperty"/> <returns>The value of a property when the name is passed in; fills in the string argument when the value is passed in. If the property does not exist, this function returns zero.</returns>
		</member>
		<member name="M:gettime" syntax="gettime(&amp;hour, &amp;minute, &amp;second)">
			<attribute name="native"/>
			<referrer name="y_profile_WTF"/>
			<param name="hour">
				<paraminfo> &amp; </paraminfo>
				The variable to store the hour in, passed by reference (optional=<b><c>0</c></b>)
			</param>
			<param name="minute">
				<paraminfo> &amp; </paraminfo>
				The variable to store the minute in, passed by reference (optional=<b><c>0</c></b>)
			</param>
			<param name="second">
				<paraminfo> &amp; </paraminfo>
				The variable to store the seconds in, passed by reference (optional=<b><c>0</c></b>)
			</param>
			<summary>Get the current server time.</summary>    <seealso name="getdate"/> <returns>The function itself returns a Unix Timestamp.</returns>
		</member>
		<member name="M:handle_acquire" syntax="handle_acquire(handle)">
			<tagname value="Handle"/>
			<attribute name="native"/>
			<referrer name="mysql_aquery"/>
			<referrer name="mysql_aquery_s"/>
			<param name="handle">
				<paraminfo>Handle </paraminfo>
			</param>
		</member>
		<member name="M:handle_alive" syntax="handle_alive(handle)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="operator!(Handle:)"/>
			<param name="handle">
				<paraminfo>Handle </paraminfo>
			</param>
		</member>
		<member name="M:handle_get" syntax="handle_get(handle, offset)">
			<attribute name="native"/>
			<referrer name="__ppAsyncMySQLError"/>
			<referrer name="__ppAsyncMySQLHandler"/>
			<param name="handle">
				<paraminfo>Handle </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:handle_linked" syntax="handle_linked(handle)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="__ppAsyncMySQLError"/>
			<referrer name="__ppAsyncMySQLHandler"/>
			<param name="handle">
				<paraminfo>Handle </paraminfo>
			</param>
		</member>
		<member name="M:handle_new" syntax="handle_new(value, weak, tag_id)">
			<tagname value="Handle"/>
			<attribute name="native"/>
			<referrer name="mysql_aquery"/>
			<referrer name="mysql_aquery_s"/>
			<param name="value">
				<paraminfo> {_,bool,Float,Variant,String,List,LinkedList,Map,Pool,Iter,Handle,Task,Expression} </paraminfo>
			</param>
			<param name="weak">
				<paraminfo>bool </paraminfo>
			</param>
			<param name="tag_id">
				<paraminfo> {_,tag_uid} </paraminfo>
			</param>
		</member>
		<member name="M:handle_release" syntax="handle_release(handle)">
			<tagname value="Handle"/>
			<attribute name="native"/>
			<referrer name="__ppAsyncMySQLError"/>
			<referrer name="__ppAsyncMySQLHandler"/>
			<param name="handle">
				<paraminfo>Handle </paraminfo>
			</param>
		</member>
		<member name="M:hexstr" syntax="hexstr(string[])">
			<stacksize value="4"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				String to convert to a number.
			</param>
			  <returns>  value of the passed hex string.  </returns>  <remarks>  Now stops on invalid characters.  </remarks> 
		</member>
		<member name="M:ishex" syntax="ishex(str[])">
			<stacksize value="3"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to check.
			</param>
			  <returns>  true/false.  </returns> 
		</member>
		<member name="M:isnumeric" syntax="isnumeric(str[])">
			<stacksize value="2"/>
			<dependency name="cellmin"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to check
			</param>
			  <remarks>  Checks if a given string is numeric.  </remarks> 
		</member>
		<member name="M:main" syntax="main()">
			<attribute name="entry"/>
			<stacksize value="1"/>
		</member>
		<member name="M:max" syntax="max(value1, value2)">
			<attribute name="native"/>
			<referrer name="YHNPS_Push"/>
			<param name="value1">
				The two values for which to find the highest number
			</param>
			<param name="value2">
				The two values for which to find the highest number
			</param>
			<summary>Return the highest of two numbers</summary>   <seealso name="clamp"/> <seealso name="min"/> <returns>The higher value of value1 and value2</returns>
		</member>
		<member name="M:memcmp" syntax="memcmp(arr1[], arr2[], count)">
			<stacksize value="3"/>
			<param name="arr1">
				<paraminfo> [] </paraminfo>
				First array to compare.
			</param>
			<param name="arr2">
				<paraminfo> [] </paraminfo>
				Second array to compare.
			</param>
			<param name="count">
				How many cells to compare.
			</param>
			      <returns>  The difference (0 if the same).  </returns> 
		</member>
		<member name="M:memcpy" syntax="memcpy(dest[], source[], index, numbytes, maxlength)">
			<attribute name="native"/>
			<referrer name="StripL"/>
			<referrer name="Strip"/>
			<referrer name="CodeScanCheck"/>
			<referrer name="Indirect_Array"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
				An array into which the bytes from source are copied in
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
				The source array
			</param>
			<param name="index">
				The start index in bytes in the destination array where the data should be copied to (optional=<b><c>0</c></b>)
			</param>
			<param name="numbytes">
				The number of bytes (not cells) to copy
			</param>
			<param name="maxlength">
				The maximum number of cells that fit in the destination buffer (optional=<b><c>sizeof dest</c></b>)
			</param>
			<summary>Copy bytes from one location to another.</summary>      <seealso name="strcmp"/> <seealso name="strfind"/> <seealso name="strtok"/> <seealso name="strdel"/> <seealso name="strins"/> <seealso name="strlen"/> <seealso name="strmid"/> <seealso name="strpack"/> <seealso name="strval"/> <seealso name="strcat"/> <returns><b><c>true</c></b> on success, <b><c>false</c></b> on failure.</returns>
		</member>
		<member name="M:memset" syntax="memset(arr[], val, size)">
			<stacksize value="7"/>
			<dependency name="rawMemset"/>
			<param name="arr">
				<paraminfo> [] </paraminfo>
				Array or address to set to a value.
			</param>
			<param name="val">
			</param>
			<param name="size">
			</param>
			  <param name="iValue">What to set the cells to.</param>  <param name="iSize">Number of cells to fill.</param>  <remarks>  Based on code by Slice:  <a href="http://forum.sa-mp.com/showthread.php?p=1606781#post1606781" />  Modified to use binary flags instead of a loop.  "memset" takes an array, the size of the array, and a value to fill it with  and sets the whole array to that value.  "rawmemset" is similar, but takes an AMX data segment address instead and  the size is in bytes, not cells.  However, the size must still be a multiple  of 4.  </remarks> 
		</member>
		<member name="M:min" syntax="min(value1, value2)">
			<attribute name="native"/>
			<referrer name="Base64Decode"/>
			<referrer name="DoLevenshteinDistance"/>
			<referrer name="YHash"/>
			<referrer name="DisasmWriteData"/>
			<referrer name="CodeScanAddJumpTarget"/>
			<referrer name="CodeScanAddSwitchTarget"/>
			<referrer name="GetColourStream"/>
			<param name="value1">
				The two values for which to find the lowest number
			</param>
			<param name="value2">
				The two values for which to find the lowest number
			</param>
			<summary>Return the lowest of two numbers</summary>   <seealso name="clamp"/> <seealso name="max"/> <returns>The lower value of value1 and value2</returns>
		</member>
		<member name="M:mysql_aquery" syntax="mysql_aquery(handle, query[], parallel)">
			<tagname value="Task"/>
			<stacksize value="15"/>
			<dependency name="amx_encode_value_public_name"/>
			<dependency name="amx_err_exit"/>
			<dependency name="handle_acquire"/>
			<dependency name="handle_new"/>
			<dependency name="handler_default"/>
			<dependency name="mysql_pquery"/>
			<dependency name="mysql_tquery"/>
			<dependency name="pawn_register_callback"/>
			<dependency name="pawn_unregister_callback"/>
			<dependency name="task_new"/>
			<dependency name="task_set_error_ms"/>
			<dependency name="true"/>
			<param name="handle">
				<paraminfo>MySQL </paraminfo>
			</param>
			<param name="query">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="parallel">
			</param>
		</member>
		<member name="M:mysql_aquery_s" syntax="mysql_aquery_s(handle, query, parallel)">
			<tagname value="Task"/>
			<stacksize value="15"/>
			<dependency name="amx_encode_value_public_name"/>
			<dependency name="amx_err_exit"/>
			<dependency name="handle_acquire"/>
			<dependency name="handle_new"/>
			<dependency name="handler_default"/>
			<dependency name="mysql_pquery_s"/>
			<dependency name="mysql_tquery_s"/>
			<dependency name="pawn_register_callback"/>
			<dependency name="pawn_unregister_callback"/>
			<dependency name="str_addr"/>
			<dependency name="task_new"/>
			<dependency name="task_set_error_ms"/>
			<dependency name="true"/>
			<param name="handle">
				<paraminfo>MySQL </paraminfo>
			</param>
			<param name="query">
				<paraminfo> {String@Const,String} </paraminfo>
			</param>
			<param name="parallel">
			</param>
		</member>
		<member name="M:mysql_close" syntax="mysql_close(handle)">
			<attribute name="native"/>
			<referrer name="closeSql"/>
			<param name="handle">
				<paraminfo>MySQL </paraminfo>
			</param>
		</member>
		<member name="M:mysql_connect" syntax="mysql_connect(host[], user[], password[], database[], option_id)">
			<tagname value="MySQL"/>
			<attribute name="native"/>
			<referrer name="Database_Connect"/>
			<param name="host">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="user">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="password">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="database">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="option_id">
				<paraminfo>MySQLOpt </paraminfo>
			</param>
		</member>
		<member name="M:mysql_errno" syntax="mysql_errno(handle)">
			<attribute name="native"/>
			<referrer name="Database_Connect"/>
			<param name="handle">
				<paraminfo>MySQL </paraminfo>
			</param>
		</member>
		<member name="M:mysql_init_options" syntax="mysql_init_options()">
			<tagname value="MySQLOpt"/>
			<attribute name="native"/>
			<referrer name="Database_Connect"/>
		</member>
		<member name="M:mysql_pquery" syntax="mysql_pquery(handle, query[], callback[], format[], ...)">
			<attribute name="native"/>
			<referrer name="mysql_aquery"/>
			<param name="handle">
				<paraminfo>MySQL </paraminfo>
			</param>
			<param name="query">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="callback">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:mysql_pquery_s" syntax="mysql_pquery_s(handle, query, callback[], format[], ...)">
			<attribute name="native"/>
			<referrer name="mysql_aquery_s"/>
			<param name="handle">
				<paraminfo>MySQL </paraminfo>
			</param>
			<param name="query">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="callback">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {MySQL,Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:mysql_set_option" syntax="mysql_set_option(option_id, type, ...)">
			<attribute name="native"/>
			<referrer name="Database_Connect"/>
			<param name="option_id">
				<paraminfo>MySQLOpt </paraminfo>
			</param>
			<param name="type">
				<paraminfo>E_MYSQL_OPTION </paraminfo>
			</param>
			<param name="...">
			</param>
		</member>
		<member name="M:mysql_tquery" syntax="mysql_tquery(handle, query[], callback[], format[], ...)">
			<attribute name="native"/>
			<referrer name="mysql_aquery"/>
			<param name="handle">
				<paraminfo>MySQL </paraminfo>
			</param>
			<param name="query">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="callback">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:mysql_tquery_s" syntax="mysql_tquery_s(handle, query, callback[], format[], ...)">
			<attribute name="native"/>
			<referrer name="mysql_aquery_s"/>
			<referrer name="account_CheckIfExists"/>
			<referrer name="registerPlayer"/>
			<param name="handle">
				<paraminfo>MySQL </paraminfo>
			</param>
			<param name="query">
				<paraminfo>AmxString </paraminfo>
			</param>
			<param name="callback">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {MySQL,Float,_} </paraminfo>
			</param>
		</member>
		<member name="M:numargs" syntax="numargs()">
			<attribute name="native"/>
			<referrer name="L@"/>
			<referrer name="T@"/>
			<referrer name="ref"/>
			<referrer name="AsmEmitInstruction"/>
			<referrer name="CodeScanMatcherPattern_"/>
			<referrer name="refabs"/>
			<referrer name="Indirect_Ref_"/>
			<referrer name="Indirect_Ptr_"/>
			<referrer name="Indirect_DeRef_"/>
			<referrer name="Indirect_DePtr_"/>
			<summary>Get the number of arguments passed to a function.</summary> <seealso name="getarg"/> <seealso name="setarg"/> <returns>The number of arguments passed.</returns>
		</member>
		<member name="M:pawn_call_native" syntax="pawn_call_native(function[], format[], ...)">
			<attribute name="native"/>
			<referrer name="AwaitAsyncDialog"/>
			<referrer name="AwaitAsyncDialogStr"/>
			<referrer name="ShowPlayerAsyncDialog"/>
			<referrer name="ShowPlayerAsyncDialogStr"/>
			<param name="function">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,bool,Float,Variant,String,List,LinkedList,Map,Pool,Iter,Handle,Task,Expression} </paraminfo>
			</param>
		</member>
		<member name="M:pawn_register_callback" syntax="pawn_register_callback(callback[], handler[], flags, additional_format[], ...)">
			<tagname value="CallbackHandler"/>
			<attribute name="native"/>
			<referrer name="mysql_aquery"/>
			<referrer name="mysql_aquery_s"/>
			<referrer name="_pp@on_init@PPAsyncDialogs"/>
			<param name="callback">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="handler">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="flags">
				<paraminfo>handler_flags </paraminfo>
			</param>
			<param name="additional_format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,bool,Float,Variant,String,List,LinkedList,Map,Pool,Iter,Handle,Task,Expression} </paraminfo>
			</param>
		</member>
		<member name="M:pawn_unregister_callback" syntax="pawn_unregister_callback(id)">
			<attribute name="native"/>
			<referrer name="mysql_aquery"/>
			<referrer name="mysql_aquery_s"/>
			<referrer name="__ppAsyncMySQLError"/>
			<referrer name="__ppAsyncMySQLHandler"/>
			<referrer name="_pp@on_exit@PPAsyncDialogs"/>
			<param name="id">
				<paraminfo>CallbackHandler </paraminfo>
			</param>
		</member>
		<member name="M:pp_on_error" syntax="pp_on_error(source[], message[], level, &amp;retval)">
			<stacksize value="1"/>
			<param name="source">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="message">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="level">
				<paraminfo>error_level </paraminfo>
			</param>
			<param name="retval">
				<paraminfo> &amp; </paraminfo>
			</param>
		</member>
		<member name="M:pp_use_funcidx" syntax="pp_use_funcidx(use)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="Indirection_OnGameModeInit"/>
			<param name="use">
				<paraminfo>bool </paraminfo>
			</param>
		</member>
		<member name="M:print" syntax="print(string[])">
			<attribute name="native"/>
			<referrer name="PrintArg"/>
			<referrer name="Database_Connect"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				The string to print
			</param>
			<summary>Prints a string to the server console (not in-game chat) and logs (server_log.txt).</summary>  <seealso name="printf"/>
		</member>
		<member name="M:printf" syntax="printf(format[], ...)">
			<attribute name="native"/>
			<referrer name="AMX_DumpHeader"/>
			<referrer name="PrintAmxHeader"/>
			<referrer name="CodeScanRunFast"/>
			<referrer name="Database_Connect"/>
			<referrer name="OnRuntimeError"/>
			<param name="format">
				<paraminfo> [] </paraminfo>
				The format string
			</param>
			<param name="...">
				<paraminfo> {Float,_} </paraminfo>
				Indefinite number of arguments of any tag
			</param>
			<summary>Outputs a formatted string on the console (the server window, not the in-game chat).</summary>   <seealso name="print"/> <seealso name="format"/> <remarks>The format string or its output should not exceed 1024 characters. Anything beyond that length can lead to a server to crash.</remarks> <remarks>This function doesn't support <a href="#strpack">packed</a> strings.</remarks> <remarks> <b>Format Specifiers:</b><p/> <ul> <li><b><c>%i</c></b> - integer (whole number)</li> <li><b><c>%d</c></b> - integer (whole number).</li> <li><b><c>%s</c></b> - string</li> <li><b><c>%f</c></b> - floating-point number (Float: tag)</li> <li><b><c>%c</c></b> - ASCII character</li> <li><b><c>%x</c></b> - hexadecimal number</li> <li><b><c>%b</c></b> - binary number</li> <li><b><c>%%</c></b> - literal <b><c>%</c></b></li> <li><b><c>%q</c></b> - escape a text for SQLite. (Added in <b>0.3.7 R2</b>)</li> </ul> </remarks> <remarks>The values for the placeholders follow in the exact same order as parameters in the call. For example, <b><c>"I am %i years old"</c></b> - the <b><c>%i</c></b> will be replaced with an Integer variable, which is the person's age.</remarks> <remarks>You may optionally put a number between the <b><c>%</c></b> and the letter of the placeholder code. This number indicates the field width; if the size of the parameter to print at the position of the placeholder is smaller than the field width, the field is expanded with spaces. To cut the number of decimal places beeing shown of a float, you can add <b><c>.&lt;max number&gt;</c></b> between the <b><c>%</c></b> and the <b><c>f</c></b>. (example: <b><c>%.2f</c></b>)</remarks>
		</member>
		<member name="M:random" syntax="random(max)">
			<attribute name="native"/>
			<referrer name="Random"/>
			<referrer name="RandomFloat"/>
			<param name="max">
				The range of values (from <b><c>0</c></b> to <b><c>max-1</c></b>) that can be returned
			</param>
			<summary>Get a pseudo-random number.</summary>  <remarks>Using a value smaller than <b><c>1</c></b> gives weird values.</remarks> <remarks>The standard random number generator of pawn is likely a linear congruential pseudo-random number generator with a range and a period of 2^31. Linear congruential pseudo-random number generators suffer from serial correlation (especially in the low bits) and it is unsuitable for applications that require high-quality random numbers.</remarks> <returns>A random number ranging from <b><c>0</c></b> to <b><c>max-1</c></b>.</returns>
		</member>
		<member name="M:rawMemcpy_" syntax="rawMemcpy_(dest, src, index, numbytes, maxlength)">
			<attribute name="native"/>
			<referrer name="YHNPS_Insert"/>
			<referrer name="YHNPS_Push"/>
			<param name="dest">
				Destination address.
			</param>
			<param name="src">
				Source data.
			</param>
			<param name="index">
			</param>
			<param name="numbytes">
				Number of bytes to copy.
			</param>
			<param name="maxlength">
			</param>
			<summary>  rawMemcpy  </summary>        <remarks>  Like memcpy, but takes addresses instead of arrays.  Also far less secure  because it doesn't check the destination size - it just assumes it is large  enough.  </remarks> 
		</member>
		<member name="M:rawMemset" syntax="rawMemset(iAddress, iValue, iSize)">
			<stacksize value="1"/>
			<referrer name="memset"/>
			<param name="iAddress">
				Array or address to set to a value.
			</param>
			<param name="iValue">
				What to set the cells to.
			</param>
			<param name="iSize">
				Number of cells to fill.
			</param>
			      <remarks>  Based on code by Slice:  <a href="http://forum.sa-mp.com/showthread.php?p=1606781#post1606781" />  Modified to use binary flags instead of a loop.  "memset" takes an array, the size of the array, and a value to fill it with  and sets the whole array to that value.  "rawmemset" is similar, but takes an AMX data segment address instead and  the size is in bytes, not cells.  However, the size must still be a multiple  of 4.  </remarks> 
		</member>
		<member name="M:ref" syntax="ref(...)">
			<stacksize value="2"/>
			<referrer name="AsmRaiseError"/>
			<referrer name="AsmInit"/>
			<referrer name="CodeScanAddMatcher"/>
			<referrer name="AddressofResolve"/>
			<referrer name="Hooks_WriteFunction"/>
			<referrer name="_yH@"/>
			<referrer name="Hooks_GenerateContinue"/>
			<dependency name="numargs"/>
			<param name="...">
			</param>
		</member>
		<member name="M:refabs" syntax="refabs(...)">
			<stacksize value="5"/>
			<referrer name="GetAmxAddress"/>
			<dependency name="RelToAbs"/>
			<dependency name="numargs"/>
			<param name="...">
			</param>
		</member>
		<member name="M:registerPlayer" syntax="registerPlayer(playerid)">
			<stacksize value="135"/>
			<referrer name="Account_EmailDialogHandler"/>
			<dependency name="AmxString:operator=(String:)"/>
			<dependency name="Account_ReturnEmail"/>
			<dependency name="Account_ReturnEmail"/>
			<dependency name="Account_ReturnPassword"/>
			<dependency name="Account_ReturnPassword"/>
			<dependency name="Database_ReturnHandle"/>
			<dependency name="Misc_ReturnName"/>
			<dependency name="Misc_ReturnName"/>
			<dependency name="mysql_tquery_s"/>
			<dependency name="str_format"/>
			<param name="playerid">
			</param>
		</member>
		<member name="M:returnstringarg" syntax="returnstringarg(idx)">
			<stacksize value="145"/>
			<dependency name="returnstringarg"/>
			<dependency name="strcat"/>
			<param name="idx">
				Index of the string in the parameters.
			</param>
			  <returns>  string  </returns>  <remarks>  Is passed the result of getarg, which will be the address of a string (in  theory) and uses that for DMA to get the string.  </remarks> 
		</member>
		<member name="M:setarg" syntax="setarg(arg, index, value)">
			<attribute name="native"/>
			<referrer name="K@"/>
			<referrer name="D@"/>
			<param name="arg">
				The argument sequence number. Use <b><c>0</c></b> for first argument
			</param>
			<param name="index">
				The index (if the argument is an array) (optional=<b><c>0</c></b>)
			</param>
			<param name="value">
				The value to set the argument to
			</param>
			<summary>Set an argument that was passed to a function.</summary>    <seealso name="getarg"/> <seealso name="numargs"/> <returns><b><c>1</c></b> on success and <b><c>0</c></b> if the argument or the index are invalid.</returns>
		</member>
		<member name="M:setproperty" syntax="setproperty(id, name[], value, string[])">
			<attribute name="native"/>
			<referrer name="K@"/>
			<referrer name="D@"/>
			<referrer name="L@"/>
			<referrer name="T@"/>
			<referrer name="X@"/>
			<param name="id">
				The virtual machine to use, you should keep this zero (optional=<b><c>0</c></b>)
			</param>
			<param name="name">
				<paraminfo> [] </paraminfo>
				Used in combination with value when storing integers; don't use this if you want to store a string(optional=<b><c>""</c></b>)
			</param>
			<param name="value">
				The integer value to store or the property's unique ID if storing a string. Use the hash-function to calculate it from a string (optional=<b><c>cellmin</c></b>)
			</param>
			<param name="string">
				<paraminfo> [] </paraminfo>
				The value of the property, as a string. Don't use this if you want to store an integer (optional=<b><c>""</c></b>)
			</param>
			<summary>Add a new property or change an existing property.</summary>     <seealso name="Getproperty"/> <seealso name="Deleteproperty"/> <seealso name="Existproperty"/>
		</member>
		<member name="M:str_addr" syntax="str_addr(str)">
			<tagname value="AmxString"/>
			<attribute name="native"/>
			<referrer name="mysql_aquery_s"/>
			<param name="str">
				<paraminfo>String </paraminfo>
			</param>
		</member>
		<member name="M:str_format" syntax="str_format(format[], ...)">
			<tagname value="String"/>
			<attribute name="native"/>
			<referrer name="account_CheckIfExists"/>
			<referrer name="Account_RegisterHandler"/>
			<referrer name="Account_EmailDialogHandler"/>
			<referrer name="registerPlayer"/>
			<referrer name="Account_LoginDialog"/>
			<param name="format">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="...">
				<paraminfo> {_,bool,Float,Variant,String,List,LinkedList,Map,Pool,Iter,Handle,Task,Expression} </paraminfo>
			</param>
		</member>
		<member name="M:str_new" syntax="str_new(str[], mode)">
			<tagname value="String"/>
			<attribute name="native"/>
			<referrer name="Account_RegisterHandler"/>
			<referrer name="Account_EmailDialogHandler"/>
			<referrer name="Account_LoginDialog"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
			</param>
			<param name="mode">
				<paraminfo>str_create_mode </paraminfo>
			</param>
		</member>
		<member name="M:strcat" syntax="strcat(dest[], source[], maxlength)">
			<attribute name="native"/>
			<referrer name="strcopy"/>
			<referrer name="returnstringarg"/>
			<referrer name="DisasmGetInsnName"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="CodeScanGetMatchName"/>
			<referrer name="Indirect_Tag"/>
			<referrer name="AsyncDialogsHandler"/>
			<referrer name="Hooks_GetPreHooks"/>
			<referrer name="Hooks_GetDefaultReturn"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Hooks_Ordinal"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
				The string to store the two concatenated strings in
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
				The source string
			</param>
			<param name="maxlength">
				The maximum length of the destination (optional=<b><c>sizeof dest</c></b>)
			</param>
			<summary>This function concatenates (joins together) two strings into the destination string.</summary>    <seealso name="strcmp"/> <seealso name="strfind"/> <seealso name="strtok"/> <seealso name="strdel"/> <seealso name="strins"/> <seealso name="strlen"/> <seealso name="strmid"/> <seealso name="strpack"/> <seealso name="strval"/> <returns>The length of the new destination string.</returns>
		</member>
		<member name="M:strcmp" syntax="strcmp(string1[], string2[], ignorecase, length)">
			<attribute name="native"/>
			<referrer name="strequal"/>
			<referrer name="YVers_Callback"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetName"/>
			<referrer name="boolstr"/>
			<referrer name="LevenshteinDistance"/>
			<referrer name="SetColour"/>
			<referrer name="GetColour"/>
			<referrer name="GetColourStream"/>
			<referrer name="Colours_DoHashParse"/>
			<referrer name="Hooks_GetAllHooks"/>
			<param name="string1">
				<paraminfo> [] </paraminfo>
				The first string to compare
			</param>
			<param name="string2">
				<paraminfo> [] </paraminfo>
				The second string to compare
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
				When set to true, the case doesn't matter - HeLLo is the same as Hello. When false, they're not the same (optional=<b><c>0</c></b>)
			</param>
			<param name="length">
				When this length is set, the first x chars will be compared - doing "Hello" and "Hell No" with a length of 4 will say it's the same string (optional=<b><c>cellmax</c></b>)
			</param>
			<summary>Compares two strings to see if they are the same.</summary>     <seealso name="strfind"/> <seealso name="strtok"/> <seealso name="strdel"/> <seealso name="strins"/> <seealso name="strlen"/> <seealso name="strmid"/> <seealso name="strpack"/> <seealso name="strval"/> <seealso name="strcat"/> <seealso name="strequal"/> <remarks>This function returns <b><c>0</c></b> if either string is empty. Check for null strings with <c>isnull()</c>. If you do not, for example, people can login to anyone's account by simply entering a blank password. </remarks> <remarks> <code> #if !defined isnull<p/> &#9;#define isnull(%1) ((!(%1[0])) || (((%1[0]) == '\1') &amp;&amp; (!(%1[1]))))<p/> #endif </code> </remarks> <remarks>If you compare strings from a text file, you should take in to account the 'carriage return' and 'new line' special characters (\r \n), as they are included, when using fread.</remarks> <returns> <b><c>0</c></b> if strings match each other on given length;.<p/> <b><c>1</c></b> or <b><c>-1</c></b> if some character do not match: <c>string1[i] - string2[i]</c>.<p/> <b>difference in number of characters</b> if one string matches only part of another string. </returns>
		</member>
		<member name="M:strcopy" syntax="strcopy(dest[], source[], maxlength)">
			<stacksize value="5"/>
			<referrer name="Account_SetPassword"/>
			<referrer name="Account_SetName"/>
			<referrer name="Account_SetEmail"/>
			<dependency name="EOS"/>
			<dependency name="strcat"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
				The string to copy the source string into
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
				The source string
			</param>
			<param name="maxlength">
				The maximum length of the destination (optional=<b><c>sizeof dest</c></b>)
			</param>
			<summary>Copies a string into the destination string.</summary>    <seealso name="strcat"/> <returns>The length of the new destination string.</returns>
		</member>
		<member name="M:strcpy_undefined__" syntax="strcpy_undefined__()">
			<stacksize value="1"/>
		</member>
		<member name="M:strdel" syntax="strdel(string[], start, end)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_IsolateName"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				The string to delete part of
			</param>
			<param name="start">
				The position of the first character to delete
			</param>
			<param name="end">
				The position of the last character to delete
			</param>
			<summary>Delete part of a string.</summary>    <seealso name="strcmp"/> <seealso name="strfind"/> <seealso name="strtok"/> <seealso name="strins"/> <seealso name="strlen"/> <seealso name="strmid"/> <seealso name="strpack"/> <seealso name="strval"/> <seealso name="strcat"/>
		</member>
		<member name="M:strequal" syntax="strequal(string1[], string2[], ignorecase, length)">
			<tagname value="bool"/>
			<stacksize value="6"/>
			<dependency name="strcmp"/>
			<param name="string1">
				<paraminfo> [] </paraminfo>
				The first string to compare
			</param>
			<param name="string2">
				<paraminfo> [] </paraminfo>
				The second string to compare
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
				When set to true, the case doesn't matter - HeLLo is the same as Hello. When false, they're not the same (optional=<b><c>0</c></b>)
			</param>
			<param name="length">
				When this length is set, the first x chars will be compared - doing "Hello" and "Hell No" with a length of 4 will say it's the same string (optional=<b><c>cellmax</c></b>)
			</param>
			<summary>Compares two strings to see if they are the same.</summary>     <seealso name="strcmp"/> <remarks>This is a conveniece function that depends on <a href="#strcmp">strcmp</a>.</remarks> <returns><b><c>true</c></b> if the strings match each other on given length, <b><c>false</c></b> otherwise.</returns>
		</member>
		<member name="M:strfind" syntax="strfind(string[], sub[], ignorecase, pos)">
			<attribute name="native"/>
			<referrer name="YVers_Callback"/>
			<referrer name="AMX_GetEntry"/>
			<referrer name="AMX_GetName"/>
			<referrer name="SetColour"/>
			<referrer name="GetColour"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_IsolateName"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				The string you want to search in (haystack)
			</param>
			<param name="sub">
				<paraminfo> [] </paraminfo>
				The string you want to search for (needle)
			</param>
			<param name="ignorecase">
				<paraminfo>bool </paraminfo>
				When set to true, the case doesn't matter - HeLLo is the same as Hello. When false, they're not the same (optional=<b><c>0</c></b>)
			</param>
			<param name="pos">
				The offset to start searching from (optional=<b><c>0</c></b>)
			</param>
			<summary>Search for a sub string in a string.</summary>     <seealso name="strcmp"/> <seealso name="strtok"/> <seealso name="strdel"/> <seealso name="strins"/> <seealso name="strlen"/> <seealso name="strmid"/> <seealso name="strpack"/> <seealso name="strval"/> <seealso name="strcat"/> <returns>The number of characters before the sub string (the sub string's start position) or <b><c>-1</c></b> if it's not found.</returns>
		</member>
		<member name="M:strins" syntax="strins(string[], substr[], pos, maxlength)">
			<tagname value="bool"/>
			<attribute name="native"/>
			<referrer name="Hooks_MakeLongName"/>
			<referrer name="Hooks_MakeShortName"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				The string you want to insert substr in
			</param>
			<param name="substr">
				<paraminfo> [] </paraminfo>
				The string you want to insert into string
			</param>
			<param name="pos">
				The position to start inserting
			</param>
			<param name="maxlength">
				The maximum size to insert (optional=<b><c>sizeof string</c></b>)
			</param>
			<summary>Insert a string into another string.</summary>     <seealso name="strcmp"/> <seealso name="strfind"/> <seealso name="strtok"/> <seealso name="strdel"/> <seealso name="strlen"/> <seealso name="strmid"/> <seealso name="strpack"/> <seealso name="strval"/> <seealso name="strcat"/>
		</member>
		<member name="M:strlen" syntax="strlen(string[])">
			<attribute name="native"/>
			<referrer name="StripNL"/>
			<referrer name="StripL"/>
			<referrer name="Strip"/>
			<referrer name="endofline"/>
			<referrer name="chrfind"/>
			<referrer name="unpack"/>
			<referrer name="Base64Decode"/>
			<referrer name="LevenshteinDistance"/>
			<referrer name="YHash"/>
			<referrer name="DisasmWriteCode"/>
			<referrer name="GetColourStream"/>
			<referrer name="Hooks_MakeShortName"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<referrer name="_Hooks_AddReplacement"/>
			<referrer name="Account_RegisterHandler"/>
			<referrer name="Account_EmailDialogHandler"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				The string to get the length of
			</param>
			<summary>Get the length of a string.</summary>  <seealso name="strcmp"/> <seealso name="strfind"/> <seealso name="strtok"/> <seealso name="strdel"/> <seealso name="strins"/> <seealso name="strmid"/> <seealso name="strpack"/> <seealso name="strval"/> <seealso name="strcat"/> <returns>The length of the string as an integer.</returns>
		</member>
		<member name="M:strpack" syntax="strpack(dest[], source[], maxlength)">
			<attribute name="native"/>
			<referrer name="Hooks_GetPointerRewrite"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
				The destination string to save the packed string in, passed by reference
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
				The source, original string
			</param>
			<param name="maxlength">
				The maximum size to insert (optional=<b><c>sizeof dest</c></b>)
			</param>
			<summary>Pack a string. Packed strings use 75% less memory.</summary>    <seealso name="strcmp"/> <seealso name="strfind"/> <seealso name="strtok"/> <seealso name="strdel"/> <seealso name="strins"/> <seealso name="strlen"/> <seealso name="strmid"/> <seealso name="strval"/> <seealso name="strcat"/> <returns>The number of characters packed.</returns>
		</member>
		<member name="M:strunpack" syntax="strunpack(dest[], source[], maxlength)">
			<attribute name="native"/>
			<referrer name="AMX_DumpHeader"/>
			<referrer name="K@"/>
			<referrer name="unpack"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<referrer name="Hooks_GetAllHooks"/>
			<referrer name="Hooks_Collate"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
				The destination string to save the unpacked string in, passed by reference
			</param>
			<param name="source">
				<paraminfo> [] </paraminfo>
				The source, original packed string
			</param>
			<param name="maxlength">
				The maximum size to insert (optional=<b><c>sizeof dest</c></b>)
			</param>
			<summary>This function can be used to unpack a string.</summary>    <seealso name="ispacked"/> <seealso name="strpack"/> <seealso name="strcmp"/> <seealso name="strfind"/> <seealso name="strtok"/> <seealso name="strdel"/> <seealso name="strins"/> <seealso name="strlen"/> <seealso name="strmid"/> <seealso name="strval"/> <seealso name="strcat"/> <returns>The number of characters packed.</returns>
		</member>
		<member name="M:strval" syntax="strval(string[])">
			<attribute name="native"/>
			<referrer name="IPToInt"/>
			<param name="string">
				<paraminfo> [] </paraminfo>
				The string you want to convert to an integer
			</param>
			<summary>Convert a string to an integer.</summary>  <seealso name="strcmp"/> <seealso name="strfind"/> <seealso name="strtok"/> <seealso name="strdel"/> <seealso name="strins"/> <seealso name="strlen"/> <seealso name="strmid"/> <seealso name="strpack"/> <seealso name="strcat"/> <returns>The integer value of the string. <b><c>0</c></b> if the string is not numeric.</returns>
		</member>
		<member name="M:swapchars" syntax="swapchars(c)">
			<attribute name="native"/>
			<referrer name="AMX_ReadString"/>
			<referrer name="Cell_ReverseBits"/>
			<referrer name="Cell_ReverseNibbles"/>
			<referrer name="Cell_ReverseBytes"/>
			<param name="c">
				The value for which to swap the bytes.
			</param>
			<summary>Swap bytes in a cell</summary>  <returns>A value where the bytes are swapped (the lowest byte becomes the highest byte)</returns>
		</member>
		<member name="M:task_await" syntax="task_await(task)">
			<stacksize value="4"/>
			<referrer name="AwaitAsyncDialog"/>
			<referrer name="AwaitAsyncDialogStr"/>
			<dependency name="task_get_result"/>
			<dependency name="task_wait"/>
			<param name="task">
				<paraminfo>Task </paraminfo>
			</param>
		</member>
		<member name="M:task_await_arr" syntax="task_await_arr(task, result[], size)">
			<stacksize value="5"/>
			<referrer name="Account_RegisterHandler"/>
			<referrer name="Account_EmailDialogHandler"/>
			<referrer name="Account_LoginDialog"/>
			<dependency name="task_get_result_arr"/>
			<dependency name="task_wait"/>
			<param name="task">
				<paraminfo>Task </paraminfo>
			</param>
			<param name="result">
				<paraminfo> {_,bool,Float,Variant,String,List,LinkedList,Map,Pool,Iter,Handle,Task,Expression} [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:task_await_var" syntax="task_await_var(task)">
			<tagname value="Variant"/>
			<stacksize value="3"/>
			<dependency name="task_get_result_var"/>
			<dependency name="task_wait"/>
			<param name="task">
				<paraminfo>Task </paraminfo>
			</param>
		</member>
		<member name="M:task_delete" syntax="task_delete(task)">
			<attribute name="native"/>
			<referrer name="AwaitAsyncDialog"/>
			<referrer name="AwaitAsyncDialogStr"/>
			<referrer name="ShowPlayerAsyncDialog"/>
			<referrer name="ShowPlayerAsyncDialogStr"/>
			<param name="task">
				<paraminfo>Task </paraminfo>
			</param>
		</member>
		<member name="M:task_get_result" syntax="task_get_result(task, offset)">
			<attribute name="native"/>
			<referrer name="task_await"/>
			<param name="task">
				<paraminfo>Task </paraminfo>
			</param>
			<param name="offset">
			</param>
		</member>
		<member name="M:task_get_result_arr" syntax="task_get_result_arr(task, result[], size)">
			<attribute name="native"/>
			<referrer name="task_await_arr"/>
			<referrer name="AwaitAsyncDialog"/>
			<referrer name="AwaitAsyncDialogStr"/>
			<param name="task">
				<paraminfo>Task </paraminfo>
			</param>
			<param name="result">
				<paraminfo> {_,bool,Float,Variant,String,List,LinkedList,Map,Pool,Iter,Handle,Task,Expression} [] </paraminfo>
			</param>
			<param name="size">
			</param>
		</member>
		<member name="M:task_get_result_var" syntax="task_get_result_var(task)">
			<tagname value="Variant"/>
			<attribute name="native"/>
			<referrer name="task_await_var"/>
			<param name="task">
				<paraminfo>Task </paraminfo>
			</param>
		</member>
		<member name="M:task_new" syntax="task_new()">
			<tagname value="Task"/>
			<attribute name="native"/>
			<referrer name="mysql_aquery"/>
			<referrer name="mysql_aquery_s"/>
			<referrer name="AwaitAsyncDialog"/>
			<referrer name="AwaitAsyncDialogStr"/>
			<referrer name="ShowPlayerAsyncDialog"/>
			<referrer name="ShowPlayerAsyncDialogStr"/>
		</member>
		<member name="M:task_set_error" syntax="task_set_error(task, error)">
			<attribute name="native"/>
			<referrer name="__ppAsyncMySQLError"/>
			<param name="task">
				<paraminfo>Task </paraminfo>
			</param>
			<param name="error">
				<paraminfo>amx_err </paraminfo>
			</param>
		</member>
		<member name="M:task_set_error_ms" syntax="task_set_error_ms(task, error, interval)">
			<attribute name="native"/>
			<referrer name="mysql_aquery"/>
			<referrer name="mysql_aquery_s"/>
			<param name="task">
				<paraminfo>Task </paraminfo>
			</param>
			<param name="error">
				<paraminfo>amx_err </paraminfo>
			</param>
			<param name="interval">
			</param>
		</member>
		<member name="M:task_set_result" syntax="task_set_result(task, result, tag_id)">
			<attribute name="native"/>
			<referrer name="__ppAsyncMySQLHandler"/>
			<param name="task">
				<paraminfo>Task </paraminfo>
			</param>
			<param name="result">
				<paraminfo> {_,bool,Float,Variant,String,List,LinkedList,Map,Pool,Iter,Handle,Task,Expression} </paraminfo>
			</param>
			<param name="tag_id">
				<paraminfo> {_,tag_uid} </paraminfo>
			</param>
		</member>
		<member name="M:task_set_result_arr" syntax="task_set_result_arr(task, result[], size, tag_id)">
			<attribute name="native"/>
			<referrer name="AsyncDialogsHandler"/>
			<param name="task">
				<paraminfo>Task </paraminfo>
			</param>
			<param name="result">
				<paraminfo> {_,bool,Float,Variant,String,List,LinkedList,Map,Pool,Iter,Handle,Task,Expression} [] </paraminfo>
			</param>
			<param name="size">
			</param>
			<param name="tag_id">
				<paraminfo> {_,tag_uid} </paraminfo>
			</param>
		</member>
		<member name="M:task_wait" syntax="task_wait(task)">
			<tagname value="task_state"/>
			<attribute name="native"/>
			<referrer name="task_await"/>
			<referrer name="task_await_arr"/>
			<referrer name="task_await_var"/>
			<param name="task">
				<paraminfo>Task </paraminfo>
			</param>
		</member>
		<member name="M:task_yield" syntax="task_yield(value, tag_id)">
			<attribute name="native"/>
			<referrer name="Account_RegisterHandler"/>
			<referrer name="Account_EmailDialogHandler"/>
			<param name="value">
				<paraminfo> {_,bool,Float,Variant,String,List,LinkedList,Map,Pool,Iter,Handle,Task,Expression} </paraminfo>
			</param>
			<param name="tag_id">
				<paraminfo> {_,tag_uid} </paraminfo>
			</param>
		</member>
		<member name="M:tolower" syntax="tolower(c)">
			<attribute name="native"/>
			<referrer name="StrToLower"/>
			<param name="c">
				The character to change to lowercase
			</param>
			<summary>This function changes a single character to lowercase.</summary>  <remarks>Support for accented characters is platform-dependent.</remarks> <returns>The lower case variant of the input character, if one exists, or the unchanged character code of c if the letter c has no lower case equivalent.</returns>
		</member>
		<member name="M:toupper" syntax="toupper(c)">
			<attribute name="native"/>
			<referrer name="StrToUpper"/>
			<param name="c">
				The character to change to uppercase
			</param>
			<summary>This function changes a single character to uppercase.</summary>  <remarks>Support for accented characters is platform-dependent.</remarks> <returns>The upper case variant of the input character, if one exists, or the unchanged character code of c if the letter c has no upper case equivalent.</returns>
		</member>
		<member name="M:u@" syntax="u@(u[])">
			<stacksize value="1"/>
			<param name="u">
				<paraminfo> [] </paraminfo>
			</param>
		</member>
		<member name="M:unpack" syntax="unpack(str[])">
			<stacksize value="149"/>
			<referrer name="Hooks_IsolateName"/>
			<referrer name="Hooks_GetPreloadLibraries"/>
			<dependency name="strlen"/>
			<dependency name="strunpack"/>
			<dependency name="unpack"/>
			<param name="str">
				<paraminfo> [] </paraminfo>
				String to unpack
			</param>
			  <returns>  unpacked string  </returns>  <remarks>  Mainly used for debugging.  </remarks> 
		</member>
		<member name="M:va_fprintf" syntax="va_fprintf()">
			<stacksize value="1"/>
			<referrer name="y_profile_WTF"/>
		</member>
		<member name="M:va_return" syntax="va_return(fmat[], ...)">
			<stacksize value="145"/>
			<dependency name="format"/>
			<dependency name="va_return"/>
			<param name="fmat">
				<paraminfo> [] </paraminfo>
				String format.
			</param>
			<param name="...">
				<paraminfo> {_,Bit,Text,Group,File,Float,Text3D} </paraminfo>
				Parameters.
			</param>
			    <returns>  Formatted string.  </returns>  <remarks>  Just wraps `format` and returns a string instead.  Has extra code to ensure that it works correct on the old compiler.  </remarks> 
		</member>
		<member name="M:valstr" syntax="valstr(dest[], value, pack)">
			<attribute name="native"/>
			<referrer name="Hooks_Ordinal"/>
			<param name="dest">
				<paraminfo> [] </paraminfo>
				The destination of the string
			</param>
			<param name="value">
				The value to convert to a string
			</param>
			<param name="pack">
				<paraminfo>bool </paraminfo>
				Whether to pack the destination (optional=<b><c>0</c></b>)
			</param>
			<summary>Convert an integer into a string.</summary>    <seealso name="strval"/> <seealso name="strcmp"/> <remarks>Passing a high value to this function can cause the server to freeze/crash. Fixes are available. Below is a fix that can be put straight in to your script.</remarks> <remarks> <code> // valstr fix by Slice<p/> stock FIX_valstr(dest[], value, bool:pack = false)<p/> {<p/> &#9;// format can't handle cellmin properly<p/> &#9;static const cellmin_value[] = !"-2147483648";<p/> &#9;<p/> &#9;if (value == cellmin)<p/> &#9;&#9;pack &amp;&amp; strpack(dest, cellmin_value, 12) || strunpack(dest, cellmin_value, 12);<p/> &#9;else<p/> &#9;&#9;format(dest, 12, "%d", value), pack &amp;&amp; strpack(dest, dest, 12);<p/> }<p/> #define valstr FIX_valstr </code> </remarks>
		</member>
		<member name="M:wait_ms" syntax="wait_ms(interval)">
			<attribute name="native"/>
			<referrer name="AK_Kick"/>
			<referrer name="AdvancedKick"/>
			<param name="interval">
			</param>
		</member>
		<member name="M:wait_ticks" syntax="wait_ticks(ticks)">
			<attribute name="native"/>
			<referrer name="_pp@on_init@PPAsyncDialogs"/>
			<param name="ticks">
			</param>
		</member>
		<member name="M:y_profile_WTF" syntax="y_profile_WTF(name[], timings[], iters, size)">
			<stacksize value="11"/>
			<dependency name="Debug_Print0"/>
			<dependency name="fclose"/>
			<dependency name="fexist"/>
			<dependency name="fopen"/>
			<dependency name="fwrite"/>
			<dependency name="gettime"/>
			<dependency name="io_append"/>
			<dependency name="io_write"/>
			<dependency name="va_fprintf"/>
			<param name="name">
				<paraminfo> [] </paraminfo>
				The name of the profile.
			</param>
			<param name="timings">
				<paraminfo> [] </paraminfo>
				The raw profiling results.
			</param>
			<param name="iters">
				The number of iterations per run.
			</param>
			<param name="size">
				The number of repeats.
			</param>
			        <remarks>  "WTF" here stands for "Write To File".  The output looks like:  <code>  timestamp,runs,repeats,results (ms)  1546082820,10,1000000,122,121,121,120,121,121,121,119,119,121  1546082822,10,1000000,123,124,123,123,121,121,121,120,122,122  </code>  The timestamp is the unix timestamp at which the line was WRITTEN, not the  time at which the profilings started or ended.  "runs" is the number of times the whole profile was repeated.  "repeats" is the number of times the code was run for each repeat.  "results" are the total times for each repeat, in milliseconds.  The time  for an individual piece of code is <c>result[n] / repeats</c>.  This is  equivalent to:  <code>  for (new i = 0; i != runs; ++i)  {  start = GetTickCount();  for (new i = 0; i != repeats; ++i)  {  USER_CODE_HERE();  }  end = GetTickCount();  WriteToFile(end - start);  }  </code>  The repeats help to time very short pieces of code.  The runs help to  average.  The console reports average results (mean, mode, median, range).  Thus the even more accurate result for a single iteration would be:  <c>sum(results) / (runs * repeats)</c>.  </remarks> 
		</member>

	</members>
</doc>
